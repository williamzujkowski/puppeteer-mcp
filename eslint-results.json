
> puppeteer-mcp@0.1.0 lint
> eslint src tests --ext .ts --format json

[{"filePath":"/home/william/git/puppeteer-mcp/src/auth/combined-middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/auth/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/auth/jwt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/auth/middleware.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/auth/permissions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/auth/refresh.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/errors/app-error.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/middleware/error-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/middleware/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/middleware/request-id.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/middleware/request-logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/middleware/security-headers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/core/middleware/validate-request.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/interceptors/auth.interceptor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/interceptors/error.interceptor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/interceptors/logging.interceptor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/interceptors/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/server.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":154,"column":16,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":154,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-var-requires","severity":2,"message":"Require statement not part of import statement.","line":156,"column":18,"nodeType":"CallExpression","messageId":"noVarReqs","endLine":156,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/command-executor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/context-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/context.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/health.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/session-auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/session-crud.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/session-list.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/session-operations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/session-stream.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/session-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/services/session.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/types/context.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/types/session-stream.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/grpc/types/session.types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/adapter.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/grpc-adapter.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/grpc-adapter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":94,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":94,"endColumn":22,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2869,2880],"text":"Boolean(params.auth)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":123,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":123,"endColumn":35,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3834,3850],"text":"(Boolean(params.operation))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":163,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":163,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5024,5033],"text":"(sessionId != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5024,5033],"text":"(sessionId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5024,5033],"text":"(Boolean(sessionId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":168,"column":9,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":168,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5171,5180],"text":"requestId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5171,5180],"text":"requestId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5171,5180],"text":"Boolean(requestId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5499,5502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5499,5502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":184,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":184,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5636,5643],"text":"(Boolean(service))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":189,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":189,"endColumn":16,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5782,5788],"text":"(Boolean(method))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":206,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6324,6327],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6324,6327],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6366,6369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6366,6369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6413,6416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6413,6416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":214,"column":18,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":214,"endColumn":25,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[6585,6592],"text":"(Boolean(request))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":222,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":222,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6815,6818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6815,6818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":222,"column":74,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":222,"endColumn":76},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7275,7278],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7275,7278],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7317,7320],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7317,7320],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7364,7367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7364,7367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":248,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":248,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7442,7445],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7442,7445],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":252,"column":18,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":252,"endColumn":25,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7579,7586],"text":"(Boolean(request))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":256,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7706,7709],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7706,7709],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8391,8394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8391,8394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":293,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8770,8773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8770,8773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":296,"column":11,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":296,"endColumn":36,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[8841,8866],"text":"Boolean(key.includes(serviceName))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":309,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9077,9080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9077,9080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":363,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":363,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[10439,10444],"text":"(Boolean(error))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":364,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10549,10552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10549,10552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":365,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":365,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10603,10606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10603,10606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":366,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":366,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10679,10682],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10679,10682],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":232,"column":7,"nodeType":"MemberExpression","endLine":232,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":275,"column":9,"nodeType":"MemberExpression","endLine":275,"endColumn":28,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"max-lines","severity":2,"message":"File has too many lines (361). Maximum allowed is 300.","line":447,"column":1,"nodeType":null,"messageId":"exceed","endLine":514,"endColumn":1,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable max-lines */\n/**\n * gRPC Adapter for MCP\n * @module mcp/adapters/grpc-adapter\n * @description Translates MCP API calls to gRPC service calls and handles authentication\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n * @nist ia-2 \"Identification and authentication\"\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n */\n\nimport * as grpc from '@grpc/grpc-js';\nimport * as protoLoader from '@grpc/proto-loader';\nimport { join } from 'path';\nimport { z } from 'zod';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { logSecurityEvent, SecurityEventType } from '../../utils/logger.js';\nimport type { ProtocolAdapter, MCPResponse, AuthParams } from './adapter.interface.js';\nimport type { GrpcServer } from '../../grpc/server.js';\n\n/**\n * gRPC operation parameters schema\n */\nconst GrpcOperationSchema = z.object({\n  service: z.enum(['SessionService', 'ContextService', 'HealthService']),\n  method: z.string(),\n  request: z.unknown().optional(),\n  streaming: z.boolean().optional().default(false),\n});\n\ntype GrpcOperation = z.infer<typeof GrpcOperationSchema>;\n\n/**\n * Authentication parameters schema\n */\nconst AuthParamsSchema = z.object({\n  type: z.enum(['jwt', 'apikey', 'session']),\n  credentials: z.string(),\n});\n\n/**\n * gRPC adapter for MCP protocol\n * @nist ac-3 \"Access enforcement\"\n * @nist ia-2 \"Identification and authentication\"\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n */\nexport class GrpcAdapter implements ProtocolAdapter {\n  constructor(\n    private readonly server: GrpcServer,\n    private readonly protoPath: string = join(process.cwd(), 'proto', 'control.proto'),\n  ) {\n    this.initializeProto();\n  }\n\n  /**\n   * Initialize proto definitions\n   * @nist cm-7 \"Least functionality\"\n   */\n  private initializeProto(): void {\n    // Load proto definitions\n    const packageDefinition = protoLoader.loadSync(this.protoPath, {\n      keepCase: true,\n      longs: String,\n      enums: String,\n      defaults: true,\n      oneofs: true,\n      includeDirs: [join(process.cwd(), 'proto')],\n    });\n\n    // Proto is loaded but not stored as it's not directly used\n    grpc.loadPackageDefinition(packageDefinition);\n  }\n\n  /**\n   * Execute a gRPC request through MCP\n   * @nist ac-3 \"Access enforcement\"\n   * @nist au-3 \"Content of audit records\"\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  async executeRequest(params: {\n    operation: unknown;\n    auth?: unknown;\n    sessionId?: string;\n  }): Promise<MCPResponse> {\n    const startTime = Date.now();\n    const requestId = `mcp-grpc-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    try {\n      // Validate operation parameters\n      const operation = GrpcOperationSchema.parse(params.operation);\n\n      // Validate auth if provided\n      let auth: AuthParams | undefined;\n      if (params.auth) {\n        auth = AuthParamsSchema.parse(params.auth) as AuthParams;\n      }\n\n      // Create gRPC metadata\n      const metadata = this.createMetadata(auth, params.sessionId, requestId);\n\n      // Execute the gRPC call\n      const response = await this.executeGrpcCall(operation, metadata);\n\n      // Log successful execution\n      await logSecurityEvent(SecurityEventType.API_ACCESS, {\n        userId: params.sessionId,\n        resource: `${operation.service}.${operation.method}`,\n        action: 'execute',\n        result: 'success',\n        metadata: {\n          protocol: 'mcp-grpc',\n          requestId,\n          duration: Date.now() - startTime,\n        },\n      });\n\n      // Transform to MCP response\n      return this.transformToMCPResponse(response, operation, requestId);\n    } catch (error) {\n      // Log failed execution\n      await logSecurityEvent(SecurityEventType.ACCESS_DENIED, {\n        userId: params.sessionId,\n        resource: params.operation ? JSON.stringify(params.operation) : 'unknown',\n        action: 'execute',\n        result: 'failure',\n        reason: error instanceof Error ? error.message : 'Unknown error',\n        metadata: {\n          protocol: 'mcp-grpc',\n          requestId,\n          duration: Date.now() - startTime,\n        },\n      });\n\n      // Transform error to MCP response\n      return this.transformErrorToMCPResponse(error, requestId);\n    }\n  }\n\n  /**\n   * Create gRPC metadata from authentication parameters\n   * @nist ia-2 \"Identification and authentication\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  private createMetadata(auth?: AuthParams, sessionId?: string, requestId?: string): grpc.Metadata {\n    const metadata = new grpc.Metadata();\n\n    // Add authentication\n    if (auth) {\n      switch (auth.type) {\n        case 'jwt':\n          metadata.add('authorization', `Bearer ${auth.credentials}`);\n          break;\n        case 'apikey':\n          metadata.add('x-api-key', auth.credentials);\n          break;\n        case 'session':\n          metadata.add('x-session-id', auth.credentials);\n          break;\n      }\n    }\n\n    // Add session ID if provided separately\n    if (sessionId && (!auth || auth.type !== 'session')) {\n      metadata.add('x-session-id', sessionId);\n    }\n\n    // Add request ID for tracing\n    if (requestId) {\n      metadata.add('x-request-id', requestId);\n    }\n\n    return metadata;\n  }\n\n  /**\n   * Execute a gRPC call with proper error handling\n   * @nist ac-3 \"Access enforcement\"\n   * @nist si-10 \"Information input validation\"\n   */\n  private executeGrpcCall(operation: GrpcOperation, metadata: grpc.Metadata): Promise<any> {\n    // Get the service implementation from the server\n    const service = this.getServiceFromServer(operation.service);\n\n    if (!service) {\n      throw new AppError(`Service ${operation.service} not found`, 404);\n    }\n\n    const method = service[operation.method];\n    if (!method || typeof method !== 'function') {\n      throw new AppError(`Method ${operation.method} not found in ${operation.service}`, 404);\n    }\n\n    // Handle streaming vs unary calls\n    if (operation.streaming) {\n      return this.handleStreamingCall(service, operation.method, operation.request, metadata);\n    } else {\n      return this.handleUnaryCall(service, operation.method, operation.request, metadata);\n    }\n  }\n\n  /**\n   * Handle unary gRPC calls\n   * @nist ac-3 \"Access enforcement\"\n   */\n  private handleUnaryCall(\n    service: any,\n    methodName: string,\n    request: any,\n    metadata: grpc.Metadata,\n  ): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // Create a mock call object that matches gRPC's ServerUnaryCall interface\n      const call = {\n        request: request || {},\n        metadata,\n        getPeer: () => 'mcp-internal',\n        sendMetadata: () => {},\n        end: () => {},\n      };\n\n      // Create callback\n      const callback = (error: grpc.ServiceError | null, response?: any) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve(response);\n        }\n      };\n\n      // Execute the method\n      // eslint-disable-next-line security/detect-object-injection\n      service[methodName](call, callback);\n    });\n  }\n\n  /**\n   * Handle streaming gRPC calls\n   * @nist ac-3 \"Access enforcement\"\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  private handleStreamingCall(\n    service: any,\n    methodName: string,\n    request: any,\n    metadata: grpc.Metadata,\n  ): Promise<any[]> {\n    return new Promise((resolve, reject) => {\n      const responses: any[] = [];\n\n      // Create a mock call object that matches gRPC's ServerWritableStream interface\n      const call = {\n        request: request || {},\n        metadata,\n        getPeer: () => 'mcp-internal',\n        sendMetadata: () => {},\n        write: (chunk: any) => {\n          responses.push(chunk);\n          return true;\n        },\n        end: () => {\n          resolve(responses);\n        },\n        destroy: (error?: Error) => {\n          if (error) {\n            reject(error);\n          }\n        },\n        on: () => call,\n        emit: () => true,\n      };\n\n      try {\n        // Execute the streaming method\n        // eslint-disable-next-line security/detect-object-injection\n        service[methodName](call);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Get service implementation from the server\n   * @nist cm-7 \"Least functionality\"\n   */\n  private getServiceFromServer(serviceName: string): any {\n    // Access the service implementations through the server's internal structure\n    // This is a simplified approach - in production, you might want to expose\n    // a proper API for accessing services\n\n    // The services are stored in the server's handlers\n    // This is implementation-specific and may need adjustment\n    const handlers = (this.server.getServer() as any).handlers;\n\n    for (const [key, handler] of handlers) {\n      if (key.includes(serviceName)) {\n        return handler;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Transform gRPC response to MCP format\n   * @nist au-3 \"Content of audit records\"\n   */\n  private transformToMCPResponse(\n    response: any,\n    operation: GrpcOperation,\n    requestId: string,\n  ): MCPResponse {\n    // Handle streaming responses\n    if (Array.isArray(response)) {\n      return {\n        content: response.map((item) => ({\n          type: 'text' as const,\n          text: JSON.stringify(item, null, 2),\n          data: item,\n        })),\n        metadata: {\n          requestId,\n          timestamp: new Date().toISOString(),\n          protocol: 'grpc',\n          service: operation.service,\n          method: operation.method,\n          streaming: true,\n          itemCount: response.length,\n        },\n      };\n    }\n\n    // Handle unary responses\n    return {\n      content: [\n        {\n          type: 'text' as const,\n          text: JSON.stringify(response, null, 2),\n          data: response,\n        },\n      ],\n      metadata: {\n        requestId,\n        timestamp: new Date().toISOString(),\n        protocol: 'grpc',\n        service: operation.service,\n        method: operation.method,\n        streaming: false,\n      },\n    };\n  }\n\n  /**\n   * Transform error to MCP response format\n   * @nist au-3 \"Content of audit records\"\n   * @nist si-11 \"Error handling\"\n   */\n  private transformErrorToMCPResponse(error: unknown, requestId: string): MCPResponse {\n    let errorMessage = 'Unknown error occurred';\n    let errorCode = 'UNKNOWN';\n    let statusCode = 500;\n\n    if (error && typeof error === 'object' && 'code' in error && 'message' in error) {\n      errorMessage = (error as any).message;\n      errorCode = grpc.status[(error as any).code] ?? 'UNKNOWN';\n      statusCode = this.grpcStatusToHttp((error as any).code);\n    } else if (error instanceof AppError) {\n      errorMessage = error.message;\n      errorCode = 'APP_ERROR';\n      statusCode = error.statusCode;\n    } else if (error instanceof Error) {\n      errorMessage = error.message;\n    }\n\n    return {\n      content: [\n        {\n          type: 'text' as const,\n          text: JSON.stringify(\n            {\n              error: {\n                code: errorCode,\n                message: errorMessage,\n              },\n            },\n            null,\n            2,\n          ),\n        },\n      ],\n      metadata: {\n        requestId,\n        timestamp: new Date().toISOString(),\n        protocol: 'grpc',\n        status: statusCode,\n        error: true,\n      },\n    };\n  }\n\n  /**\n   * gRPC to HTTP status code mapping\n   */\n  private readonly grpcToHttpStatus = new Map<grpc.status, number>([\n    [grpc.status.OK, 200],\n    [grpc.status.CANCELLED, 499],\n    [grpc.status.INVALID_ARGUMENT, 400],\n    [grpc.status.NOT_FOUND, 404],\n    [grpc.status.ALREADY_EXISTS, 409],\n    [grpc.status.PERMISSION_DENIED, 403],\n    [grpc.status.UNAUTHENTICATED, 401],\n    [grpc.status.RESOURCE_EXHAUSTED, 429],\n    [grpc.status.FAILED_PRECONDITION, 412],\n    [grpc.status.ABORTED, 409],\n    [grpc.status.OUT_OF_RANGE, 400],\n    [grpc.status.UNIMPLEMENTED, 501],\n    [grpc.status.INTERNAL, 500],\n    [grpc.status.UNAVAILABLE, 503],\n    [grpc.status.DATA_LOSS, 500],\n  ]);\n\n  /**\n   * Convert gRPC status code to HTTP status code\n   * @nist si-11 \"Error handling\"\n   */\n  private grpcStatusToHttp(grpcCode: grpc.status): number {\n    return this.grpcToHttpStatus.get(grpcCode) ?? 500;\n  }\n\n  /**\n   * List available gRPC endpoints\n   * @nist cm-7 \"Least functionality\"\n   */\n  listEndpoints(): Promise<MCPResponse> {\n    const services = [\n      {\n        name: 'SessionService',\n        methods: [\n          { name: 'CreateSession', type: 'unary' },\n          { name: 'GetSession', type: 'unary' },\n          { name: 'UpdateSession', type: 'unary' },\n          { name: 'DeleteSession', type: 'unary' },\n          { name: 'ListSessions', type: 'unary' },\n          { name: 'BatchGetSessions', type: 'unary' },\n          { name: 'StreamSessionEvents', type: 'server-streaming' },\n          { name: 'RefreshSession', type: 'unary' },\n          { name: 'ValidateSession', type: 'unary' },\n        ],\n      },\n      {\n        name: 'ContextService',\n        methods: [\n          { name: 'CreateContext', type: 'unary' },\n          { name: 'GetContext', type: 'unary' },\n          { name: 'UpdateContext', type: 'unary' },\n          { name: 'DeleteContext', type: 'unary' },\n          { name: 'ListContexts', type: 'unary' },\n          { name: 'StreamContextEvents', type: 'server-streaming' },\n          { name: 'ExecuteCommand', type: 'unary' },\n          { name: 'StreamCommand', type: 'server-streaming' },\n        ],\n      },\n      {\n        name: 'HealthService',\n        methods: [\n          { name: 'Check', type: 'unary' },\n          { name: 'Watch', type: 'server-streaming' },\n        ],\n      },\n    ];\n\n    return Promise.resolve({\n      content: [\n        {\n          type: 'text' as const,\n          text: JSON.stringify(services, null, 2),\n          data: services,\n        },\n      ],\n      metadata: {\n        protocol: 'grpc',\n        version: '1.0.0',\n        timestamp: new Date().toISOString(),\n      },\n    });\n  }\n\n  /**\n   * Get gRPC capabilities\n   * @nist cm-7 \"Least functionality\"\n   */\n  getCapabilities(): Promise<{\n    protocol: string;\n    version: string;\n    features: string[];\n  }> {\n    return Promise.resolve({\n      protocol: 'grpc',\n      version: '1.0.0',\n      features: [\n        'unary-calls',\n        'server-streaming',\n        'jwt-authentication',\n        'api-key-authentication',\n        'session-authentication',\n        'metadata-headers',\n        'error-details',\n        'tls-support',\n        'interceptors',\n      ],\n    });\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/rest-adapter.test.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":44,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":44,"endColumn":20,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1153,1161],"text":"(Boolean(req.user))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * REST Adapter Tests\n * @module mcp/adapters/rest-adapter.test\n */\n\nimport { describe, it, expect, beforeEach, jest } from '@jest/globals';\nimport express, { Application } from 'express';\nimport { RestAdapter } from './rest-adapter.js';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { sessionStore } from '../../store/session-store.js';\nimport { apiKeyStore } from '../../store/api-key-store.js';\n\n// Mock dependencies\njest.mock('../../store/session-store.js');\njest.mock('../../store/api-key-store.js');\njest.mock('../../utils/logger.js', () => ({\n  logger: {\n    info: jest.fn(),\n    error: jest.fn(),\n    warn: jest.fn(),\n    debug: jest.fn(),\n  },\n  logSecurityEvent: jest.fn(),\n  SecurityEventType: {\n    API_ACCESS: 'API_ACCESS',\n    ACCESS_DENIED: 'ACCESS_DENIED',\n  },\n}));\n\ndescribe('RestAdapter', () => {\n  let app: Application;\n  let adapter: RestAdapter;\n\n  beforeEach(() => {\n    app = express();\n    app.use(express.json());\n    \n    // Set up test routes\n    app.get('/api/v1/health', (_req, res) => {\n      res.json({ status: 'healthy' });\n    });\n    \n    app.get('/api/v1/sessions', (req, res) => {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Unauthorized' });\n      }\n      res.json({ sessions: [] });\n    });\n    \n    adapter = new RestAdapter(app);\n    \n    // Reset mocks\n    jest.clearAllMocks();\n  });\n\n  describe('executeRequest', () => {\n    it('should execute a public endpoint without authentication', async () => {\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/health',\n        },\n      });\n\n      expect(result.content).toHaveLength(1);\n      expect(result.content[0].type).toBe('text');\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response).toEqual({ status: 'healthy' });\n      expect(result.metadata?.status).toBe(200);\n    });\n\n    it('should handle JWT authentication', async () => {\n      // Mock JWT verification\n      const mockSession = {\n        id: 'session-123',\n        userId: 'user-123',\n        metadata: { username: 'testuser', roles: ['user'] },\n      };\n      (sessionStore.get as jest.Mock).mockResolvedValue(mockSession);\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/sessions',\n        },\n        auth: {\n          type: 'jwt',\n          credentials: 'valid-jwt-token',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(200);\n    });\n\n    it('should handle API key authentication', async () => {\n      // Mock API key verification\n      const mockKeyData = {\n        id: 'key-123',\n        userId: 'user-123',\n        name: 'test-key',\n        roles: ['user'],\n      };\n      (apiKeyStore.verify as jest.Mock).mockResolvedValue(mockKeyData);\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/sessions',\n        },\n        auth: {\n          type: 'apikey',\n          credentials: 'valid-api-key',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(200);\n    });\n\n    it('should handle session authentication', async () => {\n      // Mock session lookup\n      const mockSession = {\n        id: 'session-123',\n        userId: 'user-123',\n        metadata: { username: 'testuser', roles: ['user'] },\n      };\n      (sessionStore.get as jest.Mock).mockResolvedValue(mockSession);\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/sessions',\n        },\n        auth: {\n          type: 'session',\n          credentials: 'session-123',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(200);\n    });\n\n    it('should handle validation errors', async () => {\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'INVALID',\n          endpoint: '/api/v1/health',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(400);\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.error.message).toBe('Validation error');\n    });\n\n    it('should handle authentication failures', async () => {\n      (sessionStore.get as jest.Mock).mockResolvedValue(null);\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/sessions',\n        },\n        auth: {\n          type: 'jwt',\n          credentials: 'invalid-jwt-token',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(401);\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.error.message).toBe('Invalid session');\n    });\n\n    it('should handle route not found errors', async () => {\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/nonexistent',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(404);\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.error.message).toContain('Route not found');\n    });\n\n    it('should include request metadata in response', async () => {\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/health',\n          headers: {\n            'x-custom-header': 'test-value',\n          },\n        },\n      });\n\n      expect(result.metadata).toBeDefined();\n      expect(result.metadata?.timestamp).toBeDefined();\n      expect(result.metadata?.requestId).toBeDefined();\n      expect(result.metadata?.requestId).toMatch(/^mcp-rest-/);\n    });\n\n    it('should pass query parameters', async () => {\n      app.get('/api/v1/test', (req, res) => {\n        res.json({ query: req.query });\n      });\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/test',\n          query: {\n            foo: 'bar',\n            baz: 'qux',\n          },\n        },\n      });\n\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.query).toEqual({ foo: 'bar', baz: 'qux' });\n    });\n\n    it('should pass request body', async () => {\n      app.post('/api/v1/test', (req, res) => {\n        res.json({ body: req.body });\n      });\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'POST',\n          endpoint: '/api/v1/test',\n          body: {\n            name: 'test',\n            value: 123,\n          },\n        },\n      });\n\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.body).toEqual({ name: 'test', value: 123 });\n    });\n  });\n\n  describe('listEndpoints', () => {\n    it('should return a list of available endpoints', () => {\n      const result = adapter.listEndpoints();\n\n      expect(result.content).toHaveLength(1);\n      expect(result.content[0].type).toBe('text');\n      \n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.baseUrl).toBe('/api/v1');\n      expect(response.endpoints).toBeInstanceOf(Array);\n      expect(response.endpoints.length).toBeGreaterThan(0);\n      \n      // Check for expected endpoints\n      const healthEndpoint = response.endpoints.find(\n        (e: any) => e.path === '/health'\n      );\n      expect(healthEndpoint).toBeDefined();\n      expect(healthEndpoint.methods).toContain('GET');\n    });\n  });\n\n  describe('error handling', () => {\n    it('should handle unexpected errors gracefully', async () => {\n      // Create a route that throws an error\n      app.get('/api/v1/error', () => {\n        throw new Error('Unexpected error');\n      });\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/error',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(500);\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.error.message).toBe('Unexpected error');\n      expect(response.error.requestId).toBeDefined();\n    });\n\n    it('should handle AppError with custom status codes', async () => {\n      app.get('/api/v1/app-error', () => {\n        throw new AppError('Custom error', 403, { reason: 'forbidden' });\n      });\n\n      const result = await adapter.executeRequest({\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/app-error',\n        },\n      });\n\n      expect(result.metadata?.status).toBe(403);\n      const response = JSON.parse(result.content[0].text as string);\n      expect(response.error.message).toBe('Custom error');\n      expect(response.error.details).toEqual({ reason: 'forbidden' });\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/rest-adapter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":70,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":70,"endColumn":22,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2153,2164],"text":"Boolean(params.auth)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":98,"column":19,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":98,"endColumn":35,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3048,3064],"text":"(Boolean(params.operation))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":142,"column":16,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":142,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4394,4403],"text":"sessionId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4394,4403],"text":"sessionId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4394,4403],"text":"Boolean(sessionId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":208,"column":13,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":208,"endColumn":18,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[6317,6322],"text":"Boolean(error)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":222,"column":12,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":222,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[6667,6672],"text":"(Boolean(layer))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":239,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7058,7061],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7058,7061],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7216,7219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7216,7219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":244,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":244,"endColumn":16,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7240,7246],"text":"(Boolean(router))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":250,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":250,"endColumn":53,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[7353,7395],"text":"(Boolean((layer.route?.methods[method.toLowerCase()])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":196,"column":11,"nodeType":"MemberExpression","endLine":196,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":201,"column":11,"nodeType":"MemberExpression","endLine":201,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * REST Adapter for MCP\n * @module mcp/adapters/rest-adapter\n * @description Translates MCP API calls to Express route calls and handles authentication\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n * @nist ia-2 \"Identification and authentication\"\n */\n\nimport { Application, Response, NextFunction } from 'express';\nimport { z } from 'zod';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { logSecurityEvent, SecurityEventType } from '../../utils/logger.js';\nimport type { AuthenticatedRequest } from '../../types/express.js';\nimport type { ProtocolAdapter, MCPResponse } from './adapter.interface.js';\nimport { applyAuthentication, createUserFromSession } from './rest-auth-helper.js';\nimport {\n  transformToMCPResponse,\n  transformErrorToMCPResponse,\n} from './rest-response-transformer.js';\n\n/**\n * REST operation parameters\n */\nconst RestOperationSchema = z.object({\n  method: z.enum(['GET', 'POST', 'PUT', 'PATCH', 'DELETE']),\n  endpoint: z.string(),\n  headers: z.record(z.string()).optional(),\n  body: z.unknown().optional(),\n  query: z.record(z.string()).optional(),\n});\n\ntype RestOperation = z.infer<typeof RestOperationSchema>;\n\n/**\n * Authentication parameters schema\n */\nconst AuthParamsSchema = z.object({\n  type: z.enum(['jwt', 'apikey', 'session']),\n  credentials: z.string(),\n});\n\n/**\n * REST adapter for MCP protocol\n * @nist ac-3 \"Access enforcement\"\n * @nist ia-2 \"Identification and authentication\"\n */\nexport class RestAdapter implements ProtocolAdapter {\n  constructor(private readonly app: Application) {}\n\n  /**\n   * Execute a REST API request through MCP\n   * @nist ac-3 \"Access enforcement\"\n   * @nist au-3 \"Content of audit records\"\n   */\n  async executeRequest(params: {\n    operation: unknown;\n    auth?: unknown;\n    sessionId?: string;\n  }): Promise<MCPResponse> {\n    const startTime = Date.now();\n    const requestId = `mcp-rest-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n\n    try {\n      // Validate operation parameters\n      const operation = RestOperationSchema.parse(params.operation);\n\n      // Validate auth if provided\n      let auth;\n      if (params.auth) {\n        auth = AuthParamsSchema.parse(params.auth);\n      }\n\n      // Create mock request object\n      const req = await this.createMockRequest(operation, auth, params.sessionId, requestId);\n\n      // Execute request\n      const response = await this.forwardToExpress(req, operation);\n\n      // Log successful execution\n      await logSecurityEvent(SecurityEventType.API_ACCESS, {\n        userId: req.user?.userId,\n        resource: operation.endpoint,\n        action: operation.method,\n        result: 'success',\n        metadata: {\n          protocol: 'mcp-rest',\n          requestId,\n          duration: Date.now() - startTime,\n        },\n      });\n\n      // Transform to MCP response\n      return transformToMCPResponse(response, requestId);\n    } catch (error) {\n      // Log failed execution\n      await logSecurityEvent(SecurityEventType.ACCESS_DENIED, {\n        resource: params.operation ? String(params.operation) : 'unknown',\n        action: 'execute',\n        result: 'failure',\n        reason: error instanceof Error ? error.message : 'Unknown error',\n        metadata: {\n          protocol: 'mcp-rest',\n          requestId,\n          duration: Date.now() - startTime,\n        },\n      });\n\n      // Transform error to MCP response\n      return transformErrorToMCPResponse(error, requestId);\n    }\n  }\n\n  /**\n   * Create a mock Express request object\n   * @nist ia-2 \"Identification and authentication\"\n   */\n  private async createMockRequest(\n    operation: RestOperation,\n    auth: z.infer<typeof AuthParamsSchema> | undefined,\n    sessionId: string | undefined,\n    requestId: string,\n  ): Promise<AuthenticatedRequest> {\n    const req = {\n      method: operation.method,\n      path: operation.endpoint,\n      url: operation.endpoint,\n      body: operation.body ?? {},\n      query: operation.query ?? {},\n      headers: {\n        ...operation.headers,\n        'x-request-id': requestId,\n        'user-agent': 'MCP-REST-Adapter/1.0',\n      },\n      ip: '127.0.0.1', // Local MCP request\n      get: (header: string) => req.headers[header.toLowerCase()],\n    } as unknown as AuthenticatedRequest;\n\n    // Handle authentication\n    if (auth) {\n      await applyAuthentication(req, auth, sessionId);\n    } else if (sessionId) {\n      // Use session ID directly\n      req.user = await createUserFromSession(sessionId);\n    }\n\n    // Add request context\n    req.context = {\n      requestId,\n      userId: req.user?.userId,\n      sessionId: req.user?.sessionId,\n      ip: req.ip,\n      userAgent: req.headers['user-agent'] as string,\n    };\n\n    return req;\n  }\n\n  /**\n   * Forward request to Express application\n   * @nist ac-3 \"Access enforcement\"\n   */\n  private forwardToExpress(\n    req: AuthenticatedRequest,\n    operation: RestOperation,\n  ): Promise<{ status: number; body: unknown; headers: Record<string, string> }> {\n    return new Promise((resolve, reject) => {\n      // Create mock response object\n      let responseData: unknown;\n      let responseStatus = 200;\n      const responseHeaders: Record<string, string> = {};\n\n      const res = {\n        status: (code: number) => {\n          responseStatus = code;\n          return res;\n        },\n        json: (data: unknown) => {\n          responseData = data;\n          resolve({\n            status: responseStatus,\n            body: responseData,\n            headers: responseHeaders,\n          });\n        },\n        send: (data: unknown) => {\n          responseData = data;\n          resolve({\n            status: responseStatus,\n            body: responseData,\n            headers: responseHeaders,\n          });\n        },\n        set: (header: string, value: string) => {\n          // eslint-disable-next-line security/detect-object-injection\n          responseHeaders[header] = value;\n          return res;\n        },\n        setHeader: (header: string, value: string) => {\n          // eslint-disable-next-line security/detect-object-injection\n          responseHeaders[header] = value;\n          return res;\n        },\n      } as unknown as Response;\n\n      // Create next function for error handling\n      const next: NextFunction = (error?: unknown) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve({\n            status: responseStatus,\n            body: responseData,\n            headers: responseHeaders,\n          });\n        }\n      };\n\n      // Find and execute the matching route\n      const layer = this.findMatchingRoute(operation.method, operation.endpoint);\n\n      if (!layer) {\n        reject(new AppError(`Route not found: ${operation.method} ${operation.endpoint}`, 404));\n        return;\n      }\n\n      // Execute route handler\n      try {\n        layer.handle(req, res, next);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Find matching route in Express app\n   */\n  private findMatchingRoute(method: string, path: string): any {\n    // This is a simplified implementation\n    // In production, we would need to properly match routes with parameters\n    const router = (this.app as any)._router;\n\n    if (!router) {\n      return null;\n    }\n\n    // Find matching layer\n    for (const layer of router.stack) {\n      if (layer.route?.methods[method.toLowerCase()] && this.pathMatches(layer.route.path, path)) {\n        return layer;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if path matches route pattern\n   */\n  private pathMatches(routePath: string | RegExp, requestPath: string): boolean {\n    if (typeof routePath === 'string') {\n      // Simple string matching (doesn't handle parameters)\n      return routePath === requestPath;\n    } else if (routePath instanceof RegExp) {\n      return routePath.test(requestPath);\n    }\n    return false;\n  }\n\n  /**\n   * Get REST adapter capabilities\n   */\n  getCapabilities(): Promise<{\n    protocol: string;\n    version: string;\n    features: string[];\n    authentication: string[];\n    contentTypes: string[];\n  }> {\n    return Promise.resolve({\n      protocol: 'rest',\n      version: '1.0.0',\n      features: [\n        'http-methods',\n        'query-parameters',\n        'request-body',\n        'custom-headers',\n        'authentication',\n        'error-handling',\n        'rate-limiting',\n      ],\n      authentication: ['jwt', 'apikey', 'session'],\n      contentTypes: ['application/json', 'application/x-www-form-urlencoded'],\n    });\n  }\n\n  /**\n   * List available REST endpoints\n   * @nist ac-3 \"Access enforcement\"\n   */\n  listEndpoints(): Promise<MCPResponse> {\n    return Promise.resolve({\n      content: [\n        {\n          type: 'text',\n          text: JSON.stringify(\n            {\n              baseUrl: '/api/v1',\n              endpoints: [\n                {\n                  path: '/sessions',\n                  methods: ['GET', 'POST', 'DELETE'],\n                  description: 'Session management',\n                },\n                {\n                  path: '/sessions/:id',\n                  methods: ['GET', 'DELETE'],\n                  description: 'Individual session operations',\n                },\n                {\n                  path: '/contexts',\n                  methods: ['GET', 'POST'],\n                  description: 'Context management',\n                },\n                {\n                  path: '/contexts/:id',\n                  methods: ['GET', 'PUT', 'DELETE'],\n                  description: 'Individual context operations',\n                },\n                {\n                  path: '/contexts/:id/execute',\n                  methods: ['POST'],\n                  description: 'Execute commands in context',\n                },\n                {\n                  path: '/api-keys',\n                  methods: ['GET', 'POST'],\n                  description: 'API key management',\n                },\n                {\n                  path: '/api-keys/:id',\n                  methods: ['DELETE'],\n                  description: 'Individual API key operations',\n                },\n                {\n                  path: '/health',\n                  methods: ['GET'],\n                  description: 'Health check',\n                },\n              ],\n            },\n            null,\n            2,\n          ),\n        },\n      ],\n      metadata: {\n        status: 200,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  }\n}\n\n/**\n * Create REST adapter instance\n */\nexport function createRestAdapter(app: Application): RestAdapter {\n  return new RestAdapter(app);\n}\n","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/rest-auth-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/rest-response-transformer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/ws-adapter.test.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":103,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":103,"endColumn":51,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":137,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":137,"endColumn":54,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":199,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":199,"endColumn":52,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":410,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":410,"endColumn":52,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/adapters/ws-adapter.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":154,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":154,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5011,5027],"text":"operation.topic == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5012,5027],"text":"(operation.topic ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5011,5027],"text":"!Boolean(operation.topic)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":173,"column":37,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":173,"endColumn":39},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":188,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":188,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6015,6033],"text":"operation.duration != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[6015,6033],"text":"operation.duration ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6015,6033],"text":"Boolean(operation.duration)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":216,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":216,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[6676,6692],"text":"operation.topic == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[6677,6692],"text":"(operation.topic ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[6676,6692],"text":"!Boolean(operation.topic)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":229,"column":10,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":229,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[7018,7033],"text":"subscriptionId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[7019,7033],"text":"(subscriptionId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[7018,7033],"text":"!Boolean(subscriptionId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":286,"column":10,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":286,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8398,8414],"text":"(operation.topic == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8399,8414],"text":"(operation.topic ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8398,8414],"text":"(!Boolean(operation.topic))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":286,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":286,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[8418,8434],"text":"(operation.event == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[8419,8434],"text":"(operation.event ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[8418,8434],"text":"(!Boolean(operation.event))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":544,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":544,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[15671,15686],"text":"eventData.topic != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[15671,15686],"text":"eventData.topic ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[15671,15686],"text":"Boolean(eventData.topic)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":756,"column":39,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":756,"endColumn":41},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":770,"column":24,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":770,"endColumn":38,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[21908,21922],"text":"(Boolean(events.shift()))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"max-lines","severity":2,"message":"File has too many lines (555). Maximum allowed is 300.","line":450,"column":1,"nodeType":null,"messageId":"exceed","endLine":792,"endColumn":2,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-this-alias","severity":2,"message":"Unexpected aliasing of 'this' to local variable.","line":749,"column":11,"nodeType":"Identifier","messageId":"thisAssignment","endLine":749,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/* eslint-disable max-lines */\n/**\n * WebSocket Adapter for MCP\n * @module mcp/adapters/ws-adapter\n * @description Translates MCP API calls to WebSocket operations and handles real-time communication\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n * @nist ia-2 \"Identification and authentication\"\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n */\n\nimport { WebSocket } from 'ws';\nimport { z } from 'zod';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EventEmitter } from 'events';\nimport { pino } from 'pino';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { logSecurityEvent, SecurityEventType } from '../../utils/logger.js';\nimport type { ProtocolAdapter, MCPResponse, AuthParams } from './adapter.interface.js';\nimport { WSConnectionManager } from '../../ws/connection-manager.js';\nimport { WSSubscriptionManager } from '../../ws/subscription-manager.js';\nimport { \n  WSMessageType,\n  type WSMessage,\n  type WSRequestMessage,\n  type WSResponseMessage,\n  type WSEventMessage,\n  type WSSubscriptionMessage,\n  type WSAuthMessage\n} from '../../types/websocket.js';\n\n/**\n * WebSocket operation parameters\n */\nconst WebSocketOperationSchema = z.object({\n  type: z.enum(['subscribe', 'unsubscribe', 'send', 'broadcast']),\n  topic: z.string().optional(),\n  event: z.string().optional(),\n  data: z.unknown().optional(),\n  filters: z.record(z.unknown()).optional(),\n  duration: z.number().positive().optional(),\n  timeout: z.number().positive().default(30000),\n});\n\ntype WebSocketOperation = z.infer<typeof WebSocketOperationSchema>;\n\n/**\n * WebSocket connection wrapper for MCP\n */\ninterface MCPWebSocketConnection {\n  ws: WebSocket;\n  connectionId: string;\n  authenticated: boolean;\n  pendingRequests: Map<string, {\n    resolve: (response: MCPResponse) => void;\n    reject: (error: Error) => void;\n    timeout: NodeJS.Timeout;\n  }>;\n  subscriptions: Map<string, {\n    topic: string;\n    filters?: Record<string, unknown>;\n    handler: (data: unknown) => void;\n  }>;\n}\n\n/**\n * WebSocket adapter for MCP protocol\n * @nist ac-3 \"Access enforcement\"\n * @nist ia-2 \"Identification and authentication\"\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n */\nexport class WebSocketAdapter implements ProtocolAdapter {\n  private readonly logger: pino.Logger;\n  private readonly connectionManager: WSConnectionManager;\n  private readonly subscriptionManager: WSSubscriptionManager;\n  private readonly activeConnections: Map<string, MCPWebSocketConnection> = new Map();\n  private readonly eventEmitter: EventEmitter = new EventEmitter();\n\n  constructor(\n    logger: pino.Logger,\n    connectionManager: WSConnectionManager,\n    subscriptionManager: WSSubscriptionManager\n  ) {\n    this.logger = logger.child({ module: 'mcp-ws-adapter' });\n    this.connectionManager = connectionManager;\n    this.subscriptionManager = subscriptionManager;\n    \n    // Set up event listeners for subscription updates\n    this.setupEventListeners();\n  }\n\n  /**\n   * Execute a WebSocket operation through MCP\n   * @nist ac-3 \"Access enforcement\"\n   * @nist au-3 \"Content of audit records\"\n   */\n  async executeRequest(params: {\n    operation: unknown;\n    auth?: AuthParams;\n    sessionId?: string;\n    [key: string]: unknown;\n  }): Promise<MCPResponse> {\n    try {\n      // Validate operation parameters\n      const operation = WebSocketOperationSchema.parse(params.operation);\n      \n      // Ensure connection is established and authenticated\n      const connection = await this.ensureConnection(params.auth, params.sessionId);\n      \n      // Log security event\n      await logSecurityEvent(SecurityEventType.API_ACCESS, {\n        userId: params.sessionId,\n        action: `websocket_${operation.type}`,\n        resource: operation.topic ?? 'websocket',\n        result: 'success',\n        metadata: { operation: operation.type },\n      });\n\n      // Execute operation based on type\n      switch (operation.type) {\n        case 'subscribe':\n          return await this.handleSubscribe(connection, operation);\n        case 'unsubscribe':\n          return await this.handleUnsubscribe(connection, operation);\n        case 'send':\n          return await this.handleSend(connection, operation);\n        case 'broadcast':\n          return await this.handleBroadcast(connection, operation);\n        default:\n          throw new AppError('Invalid WebSocket operation', 400);\n      }\n    } catch (error) {\n      // Log security event for failures\n      await logSecurityEvent(SecurityEventType.ACCESS_DENIED, {\n        userId: params.sessionId,\n        action: 'websocket_operation',\n        resource: 'websocket',\n        result: 'failure',\n        reason: error instanceof Error ? error.message : 'Unknown error',\n      });\n\n      throw error;\n    }\n  }\n\n  /**\n   * Handle subscription operation\n   * @nist ac-3 \"Access enforcement\"\n   */\n  private async handleSubscribe(\n    connection: MCPWebSocketConnection,\n    operation: WebSocketOperation\n  ): Promise<MCPResponse> {\n    if (!operation.topic) {\n      throw new AppError('Topic is required for subscription', 400);\n    }\n\n    const subscriptionId = uuidv4();\n    \n    // Create subscription message\n    const subscriptionMessage: WSSubscriptionMessage = {\n      type: WSMessageType.SUBSCRIBE,\n      id: subscriptionId,\n      timestamp: new Date().toISOString(),\n      topic: operation.topic,\n      filters: operation.filters,\n    };\n\n    // Send subscription request\n    await this.sendMessage(connection, subscriptionMessage);\n\n    // Set up subscription handler\n    const handler = (data: unknown) => {\n      this.eventEmitter.emit(`subscription:${subscriptionId}`, data);\n    };\n\n    // Store subscription info\n    connection.subscriptions.set(subscriptionId, {\n      topic: operation.topic,\n      filters: operation.filters,\n      handler,\n    });\n\n    // Add to connection manager\n    this.connectionManager.addSubscription(connection.connectionId, operation.topic);\n\n    // Set up auto-cleanup if duration specified\n    if (operation.duration) {\n      setTimeout(() => {\n        void this.cleanupSubscription(connection, subscriptionId);\n      }, operation.duration);\n    }\n\n    return {\n      content: [{\n        type: 'text',\n        text: `Subscribed to ${operation.topic}`,\n      }],\n      metadata: {\n        subscriptionId,\n        topic: operation.topic,\n        filters: operation.filters,\n        duration: operation.duration,\n      },\n    };\n  }\n\n  /**\n   * Handle unsubscribe operation\n   * @nist ac-3 \"Access enforcement\"\n   */\n  private async handleUnsubscribe(\n    connection: MCPWebSocketConnection,\n    operation: WebSocketOperation\n  ): Promise<MCPResponse> {\n    if (!operation.topic) {\n      throw new AppError('Topic is required for unsubscription', 400);\n    }\n\n    // Find subscription by topic\n    let subscriptionId: string | undefined;\n    for (const [id, sub] of connection.subscriptions) {\n      if (sub.topic === operation.topic) {\n        subscriptionId = id;\n        break;\n      }\n    }\n\n    if (!subscriptionId) {\n      throw new AppError('Subscription not found', 404);\n    }\n\n    // Clean up subscription\n    await this.cleanupSubscription(connection, subscriptionId);\n\n    return {\n      content: [{\n        type: 'text',\n        text: `Unsubscribed from ${operation.topic}`,\n      }],\n      metadata: {\n        topic: operation.topic,\n      },\n    };\n  }\n\n  /**\n   * Handle send operation\n   * @nist ac-3 \"Access enforcement\"\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  private async handleSend(\n    connection: MCPWebSocketConnection,\n    operation: WebSocketOperation\n  ): Promise<MCPResponse> {\n    const requestId = uuidv4();\n    \n    // Create request message\n    const requestMessage: WSRequestMessage = {\n      type: WSMessageType.REQUEST,\n      id: requestId,\n      timestamp: new Date().toISOString(),\n      method: operation.event ?? 'send',\n      path: operation.topic ?? '/',\n      data: operation.data,\n    };\n\n    // Send request and wait for response\n    const response = await this.sendRequestAndWaitForResponse(\n      connection,\n      requestMessage,\n      operation.timeout\n    );\n\n    return response;\n  }\n\n  /**\n   * Handle broadcast operation\n   * @nist ac-3 \"Access enforcement\"\n   */\n  private handleBroadcast(\n    _connection: MCPWebSocketConnection,\n    operation: WebSocketOperation\n  ): Promise<MCPResponse> {\n    if (!operation.topic || !operation.event) {\n      throw new AppError('Topic and event are required for broadcast', 400);\n    }\n\n    // Broadcast event through subscription manager\n    this.subscriptionManager.broadcastEvent(\n      operation.topic,\n      operation.event,\n      operation.data\n    );\n\n    return Promise.resolve({\n      content: [{\n        type: 'text',\n        text: `Broadcast sent to topic ${operation.topic}`,\n      }],\n      metadata: {\n        topic: operation.topic,\n        event: operation.event,\n        timestamp: new Date().toISOString(),\n      },\n    });\n  }\n\n  /**\n   * Ensure WebSocket connection is established and authenticated\n   * @nist ia-2 \"Identification and authentication\"\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  private async ensureConnection(\n    auth?: AuthParams,\n    sessionId?: string\n  ): Promise<MCPWebSocketConnection> {\n    const connectionId = sessionId ?? uuidv4();\n    \n    // Check if connection already exists\n    let connection = this.activeConnections.get(connectionId);\n    if (connection && connection.ws.readyState === WebSocket.OPEN) {\n      return connection;\n    }\n\n    // Create new connection\n    const ws = await this.createWebSocketConnection();\n    \n    connection = {\n      ws,\n      connectionId,\n      authenticated: false,\n      pendingRequests: new Map(),\n      subscriptions: new Map(),\n    };\n\n    // Store connection\n    this.activeConnections.set(connectionId, connection);\n\n    // Set up message handler\n    ws.on('message', (data) => {\n      // Handle different WebSocket data types\n      let message: string;\n      if (typeof data === 'string') {\n        message = data;\n      } else if (data instanceof Buffer) {\n        message = data.toString('utf8');\n      } else {\n        // For ArrayBuffer or other types, convert to string\n        message = String(data);\n      }\n      this.handleIncomingMessage(connection, message);\n    });\n\n    // Set up close handler\n    ws.on('close', () => {\n      this.cleanupConnection(connectionId);\n    });\n\n    // Authenticate if credentials provided\n    if (auth) {\n      await this.authenticateConnection(connection, auth);\n    }\n\n    return connection;\n  }\n\n  /**\n   * Create WebSocket connection\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  private createWebSocketConnection(): Promise<WebSocket> {\n    return new Promise((_, reject) => {\n      // In a real implementation, this would connect to the WebSocket server\n      // For this adapter, we're assuming we have access to the server-side WebSocket\n      // This is a placeholder that would need to be adapted based on your architecture\n      \n      // For now, we'll throw an error indicating this needs implementation\n      reject(new AppError(\n        'WebSocket connection creation not implemented. This adapter needs to be integrated with your WebSocket server.',\n        501\n      ));\n    });\n  }\n\n  /**\n   * Authenticate WebSocket connection\n   * @nist ia-2 \"Identification and authentication\"\n   * @nist au-3 \"Content of audit records\"\n   */\n  private async authenticateConnection(\n    connection: MCPWebSocketConnection,\n    auth: AuthParams\n  ): Promise<void> {\n    const authMessage: WSAuthMessage = {\n      type: WSMessageType.AUTH,\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      data: {\n        token: auth.type === 'jwt' ? auth.credentials : '',\n        apiKey: auth.type === 'apikey' ? auth.credentials : undefined,\n      },\n    };\n\n    // Send auth message and wait for response\n    const response = await this.sendRequestAndWaitForResponse(\n      connection,\n      authMessage,\n      10000 // 10 second timeout for auth\n    );\n\n    if (response.metadata?.status !== 200) {\n      throw new AppError('Authentication failed', 401);\n    }\n\n    connection.authenticated = true;\n    \n    // Log security event\n    await logSecurityEvent(SecurityEventType.AUTH_SUCCESS, {\n      userId: connection.connectionId,\n      action: 'websocket_auth',\n      resource: 'websocket',\n      result: 'success',\n      metadata: { authType: auth.type },\n    });\n  }\n\n  /**\n   * Send message through WebSocket\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  private sendMessage(\n    connection: MCPWebSocketConnection,\n    message: WSMessage\n  ): Promise<void> {\n    if (connection.ws.readyState !== WebSocket.OPEN) {\n      throw new AppError('WebSocket connection not open', 503);\n    }\n\n    connection.ws.send(JSON.stringify(message));\n    return Promise.resolve();\n  }\n\n  /**\n   * Send request and wait for response\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  private sendRequestAndWaitForResponse(\n    connection: MCPWebSocketConnection,\n    message: WSMessage,\n    timeout: number\n  ): Promise<MCPResponse> {\n    return new Promise((resolve, reject) => {\n      const requestId = message.id ?? uuidv4();\n      \n      // Set up timeout\n      const timeoutHandle = setTimeout(() => {\n        connection.pendingRequests.delete(requestId);\n        reject(new AppError('Request timeout', 408));\n      }, timeout);\n\n      // Store pending request\n      connection.pendingRequests.set(requestId, {\n        resolve,\n        reject,\n        timeout: timeoutHandle,\n      });\n\n      // Send message\n      this.sendMessage(connection, { ...message, id: requestId }).catch(reject);\n    });\n  }\n\n  /**\n   * Handle incoming WebSocket message\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  private handleIncomingMessage(\n    connection: MCPWebSocketConnection,\n    data: string\n  ): void {\n    try {\n      const message = JSON.parse(data) as WSMessage;\n\n      switch (message.type) {\n        case WSMessageType.RESPONSE:\n          this.handleResponseMessage(connection, message);\n          break;\n        case WSMessageType.EVENT:\n          this.handleEventMessage(connection, message);\n          break;\n        case WSMessageType.ERROR:\n          this.handleErrorMessage(connection, message);\n          break;\n        case WSMessageType.SUBSCRIPTION_UPDATE:\n          this.handleSubscriptionUpdate(connection, message);\n          break;\n        default:\n          this.logger.debug('Unhandled message type', { type: message.type });\n      }\n    } catch (error) {\n      this.logger.error('Failed to parse WebSocket message', error);\n    }\n  }\n\n  /**\n   * Handle response message\n   */\n  private handleResponseMessage(\n    connection: MCPWebSocketConnection,\n    message: WSResponseMessage\n  ): void {\n    const pending = connection.pendingRequests.get(message.id);\n    if (pending) {\n      clearTimeout(pending.timeout);\n      connection.pendingRequests.delete(message.id);\n\n      const mcpResponse: MCPResponse = {\n        content: [{\n          type: 'text',\n          text: JSON.stringify(message.data),\n        }],\n        metadata: {\n          status: message.status,\n          timestamp: message.timestamp,\n          requestId: message.id,\n        },\n      };\n\n      pending.resolve(mcpResponse);\n    }\n  }\n\n  /**\n   * Handle event message\n   */\n  private handleEventMessage(\n    connection: MCPWebSocketConnection,\n    message: WSEventMessage\n  ): void {\n    // Emit event for subscriptions\n    const eventData = message.data as { topic?: string; data?: unknown };\n    if (eventData.topic) {\n      for (const [id, sub] of connection.subscriptions) {\n        if (sub.topic === eventData.topic) {\n          sub.handler(eventData.data);\n          this.eventEmitter.emit(`subscription:${id}`, eventData.data);\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle error message\n   */\n  private handleErrorMessage(\n    connection: MCPWebSocketConnection,\n    message: WSMessage\n  ): void {\n    const errorMessage = message as { error: { code: string; message: string } };\n    const pending = connection.pendingRequests.get(message.id ?? '');\n    \n    if (pending) {\n      clearTimeout(pending.timeout);\n      connection.pendingRequests.delete(message.id ?? '');\n      pending.reject(new AppError(\n        errorMessage.error.message,\n        400\n      ));\n    }\n  }\n\n\n  /**\n   * Handle subscription update\n   */\n  private handleSubscriptionUpdate(\n    connection: MCPWebSocketConnection,\n    message: WSMessage\n  ): void {\n    const updateMessage = message as { topic: string; data: unknown };\n    \n    // Find matching subscriptions and emit events\n    for (const [id, sub] of connection.subscriptions) {\n      if (sub.topic === updateMessage.topic) {\n        sub.handler(updateMessage.data);\n        this.eventEmitter.emit(`subscription:${id}`, updateMessage.data);\n      }\n    }\n  }\n\n  /**\n   * Clean up subscription\n   */\n  private async cleanupSubscription(\n    connection: MCPWebSocketConnection,\n    subscriptionId: string\n  ): Promise<void> {\n    const subscription = connection.subscriptions.get(subscriptionId);\n    if (!subscription) {\n      return;\n    }\n\n    // Send unsubscribe message\n    const unsubscribeMessage: WSSubscriptionMessage = {\n      type: WSMessageType.UNSUBSCRIBE,\n      id: uuidv4(),\n      timestamp: new Date().toISOString(),\n      topic: subscription.topic,\n    };\n\n    await this.sendMessage(connection, unsubscribeMessage);\n\n    // Remove from connection manager\n    this.connectionManager.removeSubscription(connection.connectionId, subscription.topic);\n\n    // Remove subscription\n    connection.subscriptions.delete(subscriptionId);\n  }\n\n  /**\n   * Clean up connection\n   */\n  private cleanupConnection(connectionId: string): void {\n    const connection = this.activeConnections.get(connectionId);\n    if (!connection) {\n      return;\n    }\n\n    // Clear all pending requests\n    for (const [, pending] of connection.pendingRequests) {\n      clearTimeout(pending.timeout);\n      pending.reject(new AppError('Connection closed', 503));\n    }\n\n    // Clear all subscriptions\n    for (const [id] of connection.subscriptions) {\n      this.cleanupSubscription(connection, id).catch(error => {\n        this.logger.error('Failed to cleanup subscription', error);\n      });\n    }\n\n    // Remove from connection manager\n    this.connectionManager.removeConnection(connectionId);\n\n    // Remove from active connections\n    this.activeConnections.delete(connectionId);\n\n    this.logger.info('Connection cleaned up', { connectionId });\n  }\n\n  /**\n   * Set up event listeners for real-time updates\n   */\n  private setupEventListeners(): void {\n    // This would typically connect to your WebSocket server's event system\n    // For now, this is a placeholder\n    this.logger.debug('WebSocket adapter event listeners set up');\n  }\n\n  /**\n   * List available WebSocket endpoints\n   */\n  listEndpoints(): Promise<MCPResponse> {\n    return Promise.resolve({\n      content: [{\n        type: 'text',\n        text: JSON.stringify({\n          endpoints: [\n            {\n              operation: 'subscribe',\n              description: 'Subscribe to real-time updates on a topic',\n              parameters: {\n                topic: 'string (required)',\n                filters: 'object (optional)',\n                duration: 'number in ms (optional)',\n              },\n            },\n            {\n              operation: 'unsubscribe',\n              description: 'Unsubscribe from a topic',\n              parameters: {\n                topic: 'string (required)',\n              },\n            },\n            {\n              operation: 'send',\n              description: 'Send a message through WebSocket',\n              parameters: {\n                topic: 'string (optional)',\n                event: 'string (optional)',\n                data: 'any (optional)',\n                timeout: 'number in ms (default: 30000)',\n              },\n            },\n            {\n              operation: 'broadcast',\n              description: 'Broadcast a message to all subscribers of a topic',\n              parameters: {\n                topic: 'string (required)',\n                event: 'string (required)',\n                data: 'any (optional)',\n              },\n            },\n          ],\n        }, null, 2),\n      }],\n    });\n  }\n\n  /**\n   * Get WebSocket capabilities\n   */\n  getCapabilities(): Promise<{\n    protocol: string;\n    version: string;\n    features: string[];\n    [key: string]: unknown;\n  }> {\n    return Promise.resolve({\n      protocol: 'websocket',\n      version: '1.0.0',\n      features: [\n        'real-time-messaging',\n        'pub-sub',\n        'authentication',\n        'heartbeat',\n        'auto-reconnect',\n        'message-filtering',\n        'broadcast',\n      ],\n      authentication: ['jwt', 'apikey'],\n      subscriptionTopics: [\n        'sessions.*',\n        'contexts.*',\n        'system.*',\n      ],\n      messageTypes: Object.values(WSMessageType),\n    });\n  }\n\n  /**\n   * Create a streaming response helper for MCP\n   * @nist sc-8 \"Transmission confidentiality and integrity\"\n   */\n  createStreamingResponse(subscriptionId: string): AsyncGenerator<MCPResponse> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    \n    return (async function* () {\n      const events: unknown[] = [];\n      let resolveNext: ((value: unknown) => void) | null = null;\n\n      // Set up event listener\n      const handler = (data: unknown) => {\n        if (resolveNext) {\n          resolveNext(data);\n          resolveNext = null;\n        } else {\n          events.push(data);\n        }\n      };\n\n      self.eventEmitter.on(`subscription:${subscriptionId}`, handler);\n\n      try {\n        while (true) {\n          // Get next event\n          const data = events.shift() || await new Promise(resolve => {\n            resolveNext = resolve;\n          });\n\n          // Yield MCP response\n          yield {\n            content: [{\n              type: 'text',\n              text: JSON.stringify(data),\n            }],\n            metadata: {\n              subscriptionId,\n              timestamp: new Date().toISOString(),\n            },\n          };\n        }\n      } finally {\n        // Clean up listener\n        self.eventEmitter.off(`subscription:${subscriptionId}`, handler);\n      }\n    })();\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/auth/credential-extractor.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":13,"column":8,"nodeType":"ChainExpression","messageId":"conditionErrorOther","endLine":13,"endColumn":30},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":21,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":21,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[535,545],"text":"(authHeader != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[535,545],"text":"(authHeader ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[535,545],"text":"(Boolean(authHeader))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":33,"column":8,"nodeType":"Identifier","messageId":"conditionErrorOther","endLine":33,"endColumn":20},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":44,"column":8,"nodeType":"ChainExpression","messageId":"conditionErrorOther","endLine":44,"endColumn":20},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":54,"column":8,"nodeType":"ChainExpression","messageId":"conditionErrorOther","endLine":54,"endColumn":21},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected value in conditional. A boolean expression is required.","line":64,"column":8,"nodeType":"ChainExpression","messageId":"conditionErrorOther","endLine":64,"endColumn":24},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":74,"column":8,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":74,"endColumn":22,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2018,2032],"text":"(Boolean((metadata?.auth)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":79,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":79,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2144,2153],"text":"(auth.type != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2144,2153],"text":"(auth.type ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2144,2153],"text":"(Boolean(auth.type))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":79,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":79,"endColumn":36,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2157,2173],"text":"(auth.credentials != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2157,2173],"text":"(auth.credentials ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2157,2173],"text":"(Boolean(auth.credentials))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":101,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":101,"endColumn":10,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2891,2894],"text":"jwt != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2891,2894],"text":"jwt ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2891,2894],"text":"Boolean(jwt)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":107,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":107,"endColumn":19,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3052,3064],"text":"apiKeyHeader != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3052,3064],"text":"apiKeyHeader ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3052,3064],"text":"Boolean(apiKeyHeader)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":113,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":113,"endColumn":12,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3220,3225],"text":"token != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3220,3225],"text":"token ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3220,3225],"text":"Boolean(token)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":118,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":118,"endColumn":18,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3350,3361],"text":"apiKeyQuery != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3350,3361],"text":"apiKeyQuery ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3350,3361],"text":"Boolean(apiKeyQuery)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":123,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":123,"endColumn":16,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3496,3505],"text":"sessionId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3496,3505],"text":"sessionId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3496,3505],"text":"Boolean(sessionId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Credential Extraction Utilities\n * @module mcp/auth/credential-extractor\n * @nist ia-2 \"Identification and authentication\"\n */\n\nimport { MCPAuthCredentials } from './mcp-auth.js';\n\n/**\n * Extract JWT token from headers\n */\nfunction extractJwtFromHeaders(headers?: Record<string, string | string[] | undefined>): string | undefined {\n  if (!headers?.authorization) {\n    return undefined;\n  }\n  \n  const authHeader = Array.isArray(headers.authorization) \n    ? headers.authorization[0] \n    : headers.authorization;\n  \n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    return authHeader.substring(7);\n  }\n  \n  return undefined;\n}\n\n/**\n * Extract API key from headers\n */\nfunction extractApiKeyFromHeaders(headers?: Record<string, string | string[] | undefined>): string | undefined {\n  const apiKeyHeader = headers?.['x-api-key'] ?? headers?.['apikey'];\n  if (!apiKeyHeader) {\n    return undefined;\n  }\n  \n  return Array.isArray(apiKeyHeader) ? apiKeyHeader[0] : apiKeyHeader;\n}\n\n/**\n * Extract token from query parameters\n */\nfunction extractTokenFromQuery(query?: Record<string, string | string[] | undefined>): string | undefined {\n  if (!query?.token) {\n    return undefined;\n  }\n  return Array.isArray(query.token) ? query.token[0] : query.token;\n}\n\n/**\n * Extract API key from query parameters\n */\nfunction extractApiKeyFromQuery(query?: Record<string, string | string[] | undefined>): string | undefined {\n  if (!query?.apikey) {\n    return undefined;\n  }\n  return Array.isArray(query.apikey) ? query.apikey[0] : query.apikey;\n}\n\n/**\n * Extract session ID from query parameters\n */\nfunction extractSessionIdFromQuery(query?: Record<string, string | string[] | undefined>): string | undefined {\n  if (!query?.sessionId) {\n    return undefined;\n  }\n  return Array.isArray(query.sessionId) ? query.sessionId[0] : query.sessionId;\n}\n\n/**\n * Extract credentials from WebSocket metadata\n */\nfunction extractFromMetadata(metadata?: Record<string, unknown>): MCPAuthCredentials | undefined {\n  if (!metadata?.auth) {\n    return undefined;\n  }\n  \n  const auth = metadata.auth as { type?: string; credentials?: string };\n  if (auth.type && auth.credentials && ['jwt', 'apikey', 'session'].includes(auth.type)) {\n    return {\n      type: auth.type as 'jwt' | 'apikey' | 'session',\n      credentials: auth.credentials\n    };\n  }\n  \n  return undefined;\n}\n\n/**\n * Extract authentication credentials from various sources\n * Supports Authorization header, query params, or WebSocket metadata\n * @nist ia-2 \"Identification and authentication\"\n */\nexport function extractCredentials(source: {\n  headers?: Record<string, string | string[] | undefined>;\n  query?: Record<string, string | string[] | undefined>;\n  metadata?: Record<string, unknown>;\n}): MCPAuthCredentials | undefined {\n  // Check JWT in Authorization header\n  const jwt = extractJwtFromHeaders(source.headers);\n  if (jwt) {\n    return { type: 'jwt', credentials: jwt };\n  }\n  \n  // Check API key in headers\n  const apiKeyHeader = extractApiKeyFromHeaders(source.headers);\n  if (apiKeyHeader) {\n    return { type: 'apikey', credentials: apiKeyHeader };\n  }\n  \n  // Check query parameters\n  const token = extractTokenFromQuery(source.query);\n  if (token) {\n    return { type: 'jwt', credentials: token };\n  }\n  \n  const apiKeyQuery = extractApiKeyFromQuery(source.query);\n  if (apiKeyQuery) {\n    return { type: 'apikey', credentials: apiKeyQuery };\n  }\n  \n  const sessionId = extractSessionIdFromQuery(source.query);\n  if (sessionId) {\n    return { type: 'session', credentials: sessionId };\n  }\n  \n  // Check WebSocket metadata\n  return extractFromMetadata(source.metadata);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/auth/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/auth/mcp-auth.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":304,"column":32,"nodeType":"MemberExpression","endLine":304,"endColumn":62,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":323,"column":34,"nodeType":"MemberExpression","endLine":323,"endColumn":64,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/auth/user-service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/examples/grpc-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/examples/rest-integration.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":13,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":13,"endColumn":35},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":29,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":29,"endColumn":29},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":132,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":132,"endColumn":31},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":199,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":199,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * REST Integration Example for MCP\n * @module mcp/examples/rest-integration\n * @description Shows how to integrate the Express app with MCP server\n */\n\nimport { createApp } from '../../server.js';\nimport { createMCPServer } from '../server.js';\n\n/**\n * Example: Integrating MCP with existing Express app\n */\nasync function setupMCPWithExpress() {\n  // Create the Express app with all routes and middleware\n  const app = createApp();\n  \n  // Create MCP server with the Express app\n  const mcpServer = createMCPServer({ app });\n  \n  // Start MCP server\n  await mcpServer.start();\n  \n  // MCP server started with REST adapter enabled\n}\n\n/**\n * Example: Using MCP to execute REST API calls\n */\nfunction exampleMCPRestCalls() {\n  // These examples show the MCP tool call format\n  \n  // Example 1: Health check (no auth required)\n  const healthCheck = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'GET',\n        endpoint: '/api/v1/health',\n      },\n    },\n  };\n  \n  // Example 2: Create session with JWT auth\n  const createSession = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'POST',\n        endpoint: '/api/v1/sessions',\n        body: {\n          username: 'testuser',\n          password: 'password123',\n        },\n      },\n      auth: {\n        type: 'jwt',\n        credentials: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\n      },\n    },\n  };\n  \n  // Example 3: List contexts with API key auth\n  const listContexts = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'GET',\n        endpoint: '/api/v1/contexts',\n        query: {\n          status: 'active',\n          limit: '10',\n        },\n      },\n      auth: {\n        type: 'apikey',\n        credentials: 'pk_test_123456789',\n      },\n    },\n  };\n  \n  // Example 4: Execute command in context with session auth\n  const executeCommand = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'POST',\n        endpoint: '/api/v1/contexts/ctx-123/execute',\n        body: {\n          command: 'page.goto',\n          params: ['https://example.com'],\n        },\n      },\n      auth: {\n        type: 'session',\n        credentials: 'session-abc123',\n      },\n    },\n  };\n  \n  // Example 5: Delete session\n  const deleteSession = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'DELETE',\n        endpoint: '/api/v1/sessions/session-123',\n      },\n      auth: {\n        type: 'jwt',\n        credentials: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\n      },\n    },\n  };\n  \n  return {\n    healthCheck,\n    createSession,\n    listContexts,\n    executeCommand,\n    deleteSession,\n  };\n}\n\n/**\n * Example: Error handling scenarios\n */\nfunction exampleErrorScenarios() {\n  // Example 1: Invalid authentication\n  const invalidAuth = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'GET',\n        endpoint: '/api/v1/sessions',\n      },\n      auth: {\n        type: 'jwt',\n        credentials: 'invalid-token',\n      },\n    },\n  };\n  // Expected response: 401 Unauthorized\n  \n  // Example 2: Validation error\n  const validationError = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'INVALID_METHOD', // Invalid HTTP method\n        endpoint: '/api/v1/health',\n      },\n    },\n  };\n  // Expected response: 400 Bad Request with validation errors\n  \n  // Example 3: Route not found\n  const notFound = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'rest',\n      operation: {\n        method: 'GET',\n        endpoint: '/api/v1/nonexistent',\n      },\n    },\n  };\n  // Expected response: 404 Not Found\n  \n  // Example 4: Unsupported protocol\n  const unsupportedProtocol = {\n    name: 'execute-api',\n    arguments: {\n      protocol: 'graphql', // Not supported\n      operation: {\n        query: '{ health }',\n      },\n    },\n  };\n  // Expected response: Error - Unsupported protocol\n  \n  return {\n    invalidAuth,\n    validationError,\n    notFound,\n    unsupportedProtocol,\n  };\n}\n\n/**\n * Example: Using the API catalog resource\n */\nfunction exampleApiCatalog() {\n  // MCP resource request to get API catalog\n  const catalogRequest = {\n    method: 'resources/read',\n    params: {\n      uri: 'api://catalog',\n    },\n  };\n  \n  // Expected response includes:\n  // - REST endpoints with methods and descriptions\n  // - gRPC services and methods\n  // - WebSocket topics\n  // - Authentication methods\n  \n  return catalogRequest;\n}\n\n// Export examples\nexport {\n  setupMCPWithExpress,\n  exampleMCPRestCalls,\n  exampleErrorScenarios,\n  exampleApiCatalog,\n};","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/examples/session-management.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/examples/ws-integration.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/examples/ws-server-integration.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":142,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":142,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4861,4864],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4861,4864],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":144,"column":11,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":144,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5004,5016],"text":"connectionId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5004,5016],"text":"connectionId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5004,5016],"text":"Boolean(connectionId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5812,5815],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5812,5815],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebSocket Server Integration Example\n * @module mcp/examples/ws-server-integration\n * @description Shows how to integrate the WebSocket adapter with the actual WebSocket server\n * @nist ac-3 \"Access enforcement\"\n * @nist ia-2 \"Identification and authentication\"\n */\n\nimport { pino } from 'pino';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { createServer } from 'http';\nimport { WebSocketAdapter } from '../adapters/ws-adapter.js';\nimport { WSConnectionManager } from '../../ws/connection-manager.js';\nimport { WSSubscriptionManager } from '../../ws/subscription-manager.js';\nimport { WSMessageHandler } from '../../ws/message-handler.js';\nimport { WSAuthHandler } from '../../ws/auth-handler.js';\nimport { WSApiKeyAuthHandler } from '../../ws/auth-handler-apikey.js';\nimport { WSContextHandler } from '../../ws/context-handler.js';\nimport { WSRequestProcessor } from '../../ws/request-processor.js';\nimport { InMemorySessionStore } from '../../store/in-memory-session-store.js';\nimport type { MCPResponse } from '../adapters/adapter.interface.js';\n\n// Initialize logger\nconst logger = pino({\n  level: 'info',\n  transport: {\n    target: 'pino-pretty',\n    options: {\n      colorize: true,\n    },\n  },\n});\n\n/**\n * Create integrated WebSocket server with MCP adapter\n */\nexport function createIntegratedWebSocketServer(port: number = 8080): {\n  server: WebSocketServer;\n  adapter: WebSocketAdapter;\n  connectionManager: WSConnectionManager;\n} {\n  // Create HTTP server\n  const httpServer = createServer();\n\n  // Initialize WebSocket infrastructure\n  const connectionManager = new WSConnectionManager(logger);\n  const subscriptionManager = new WSSubscriptionManager(logger, connectionManager);\n  \n  // Create WebSocket server\n  const wss = new WebSocketServer({ server: httpServer });\n\n  // Create session store\n  const sessionStore = new InMemorySessionStore(logger);\n  \n  // Set up authentication handlers\n  const authHandler = new WSAuthHandler(logger, sessionStore);\n  const apiKeyAuthHandler = new WSApiKeyAuthHandler(logger, sessionStore);\n  \n  // Create message handler  \n  const messageHandler = new WSMessageHandler(logger, sessionStore, connectionManager, authHandler);\n  \n  // Set up other handlers\n  const contextHandler = new WSContextHandler();\n  const requestProcessor = new WSRequestProcessor(logger, sessionStore, connectionManager, authHandler);\n  \n  // Note: In a real integration, you would wire these handlers to the WebSocket server\n  // This example focuses on showing the adapter integration\n  void authHandler;\n  void apiKeyAuthHandler;\n  void messageHandler;\n  void contextHandler;\n  void requestProcessor;\n\n  // Create MCP adapter\n  const adapter = new WebSocketAdapter(logger, connectionManager, subscriptionManager);\n\n  // Extend adapter to work with actual WebSocket connections\n  extendAdapterForServer(adapter, wss, connectionManager);\n\n  // Handle WebSocket connections\n  wss.on('connection', (ws, req) => {\n    const connectionId = req.headers['x-connection-id'] as string || `conn-${Date.now()}`;\n    \n    // Add connection to manager\n    connectionManager.addConnection(connectionId, ws, {\n      id: connectionId,\n      authenticated: false,\n      subscriptions: new Set(),\n      lastActivity: new Date(),\n    });\n\n    // Handle messages through the message handler\n    ws.on('message', (data) => {\n      let message: string;\n      if (typeof data === 'string') {\n        message = data;\n      } else if (Buffer.isBuffer(data)) {\n        message = data.toString('utf8');\n      } else if (data instanceof ArrayBuffer) {\n        message = Buffer.from(data).toString('utf8');\n      } else if (Array.isArray(data)) {\n        message = Buffer.concat(data.map(d => Buffer.isBuffer(d) ? d : Buffer.from(d))).toString('utf8');\n      } else {\n        message = String(data);\n      }\n      messageHandler.handleMessage(ws, connectionId, message);\n    });\n\n    // Handle disconnection\n    ws.on('close', () => {\n      connectionManager.removeConnection(connectionId);\n      logger.info(`Connection ${connectionId} closed`);\n    });\n\n    // Send connection acknowledgment\n    ws.send(JSON.stringify({\n      type: 'connect',\n      id: connectionId,\n      timestamp: new Date().toISOString(),\n    }));\n  });\n\n  // Start HTTP server\n  httpServer.listen(port, () => {\n    logger.info(`WebSocket server listening on port ${port}`);\n  });\n\n  return { server: wss, adapter, connectionManager };\n}\n\n/**\n * Extend the MCP adapter to work with real WebSocket connections\n */\nfunction extendAdapterForServer(\n  adapter: WebSocketAdapter,\n  wss: WebSocketServer, // Used in production, example simplified for clarity\n  connectionManager: WSConnectionManager\n): void {\n  void wss; // Would be used in production for connection management\n  \n  // Override the createWebSocketConnection method to use existing connections\n  (adapter as any).createWebSocketConnection = function(connectionId?: string): Promise<WebSocket> {\n    return new Promise((resolve, reject) => {\n      if (connectionId) {\n        // Try to get existing connection\n        const existingWs = connectionManager.getWebSocket(connectionId);\n        if (existingWs) {\n          resolve(existingWs);\n          return;\n        }\n      }\n\n      // For new connections, we need to wait for a client to connect\n      // In a real implementation, you might want to:\n      // 1. Return an existing idle connection from a pool\n      // 2. Create a new internal connection\n      // 3. Throw an error indicating that external connections are required\n      \n      reject(new Error(\n        'WebSocket connections must be established externally. ' +\n        'Use the WebSocket server directly or provide a valid connectionId.'\n      ));\n    });\n  };\n\n  // Add method to execute MCP requests for existing connections\n  (adapter as any).executeForConnection = async function(\n    connectionId: string,\n    operation: unknown\n  ): Promise<MCPResponse> {\n    const connectionState = connectionManager.getConnectionState(connectionId);\n    if (!connectionState) {\n      throw new Error('Connection not found');\n    }\n\n    // Use 'this' with proper typing context\n    const response = await this.executeRequest({\n      operation,\n      sessionId: connectionId,\n      auth: connectionState.authenticated ? {\n        type: 'session' as const,\n        credentials: connectionState.sessionId ?? '',\n      } : undefined,\n    }) as MCPResponse;\n    \n    return response;\n  };\n}\n\n/**\n * Example usage of the integrated server\n */\nfunction runExample(): void {\n  const { server, adapter, connectionManager } = createIntegratedWebSocketServer(8080);\n\n  // Example: Handle MCP requests from existing WebSocket connections\n  connectionManager.getAllConnections().forEach(({ connectionId, state }) => {\n    if (state.authenticated) {\n      // Execute MCP operations for authenticated connections\n      void adapter.executeRequest({\n        operation: {\n          type: 'subscribe',\n          topic: 'system.status',\n        },\n        sessionId: connectionId,\n      }).then(response => {\n        logger.info('Subscription created for connection', { connectionId, response });\n      }).catch(error => {\n        logger.error('Failed to create subscription', { connectionId, error });\n      });\n    }\n  });\n\n  // Example: Broadcast system events through MCP\n  setInterval(() => {\n    void (async () => {\n      try {\n        await adapter.executeRequest({\n          operation: {\n            type: 'broadcast',\n            topic: 'system.status',\n            event: 'heartbeat',\n            data: {\n              timestamp: new Date().toISOString(),\n              connections: connectionManager.getStats(),\n            },\n          },\n          sessionId: 'system',\n        });\n      } catch (error) {\n        logger.error('Failed to broadcast heartbeat', error);\n      }\n    })();\n  }, 30000); // Every 30 seconds\n\n  // Graceful shutdown\n  process.on('SIGTERM', () => {\n    logger.info('Shutting down WebSocket server...');\n    server.close(() => {\n      logger.info('WebSocket server closed');\n      process.exit(0);\n    });\n  });\n}\n\n// Run example if this is the main module\nif (import.meta.url === `file://${process.argv[1]}`) {\n  try {\n    runExample();\n  } catch (error) {\n    console.error('Failed to run example:', error);\n  }\n}\n\nexport { extendAdapterForServer };","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/resources/api-catalog.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":83,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableString","endLine":83,"endColumn":45,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2143,2177],"text":"(endpointsResponse.content[0]?.text) != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2143,2177],"text":"(endpointsResponse.content[0]?.text) ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2143,2177],"text":"Boolean((endpointsResponse.content[0]?.text))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * API Catalog Resource Implementation\n * @module mcp/resources/api-catalog\n */\n\nimport type { RestAdapter } from '../adapters/rest-adapter.js';\nimport type { ApiCatalog, RestEndpoint, ResourceResponse } from '../types/resource-types.js';\n\n/**\n * API Catalog resource handler\n * @nist ac-3 \"Access enforcement\"\n */\nexport class ApiCatalogResource {\n  constructor(private restAdapter?: RestAdapter) {}\n\n  /**\n   * Get API catalog\n   */\n  async getApiCatalog(): Promise<ResourceResponse> {\n    // Get REST endpoints from adapter if available\n    const restEndpoints: RestEndpoint[] = await this.getRestEndpoints();\n    \n    const catalog: ApiCatalog = {\n      rest: {\n        baseUrl: '/api/v1',\n        endpoints: restEndpoints,\n        authentication: {\n          methods: ['jwt', 'apikey', 'session'],\n          headers: {\n            jwt: 'Authorization: Bearer <token>',\n            apikey: 'X-API-Key: <key>',\n          },\n        },\n      },\n      grpc: {\n        services: [\n          {\n            name: 'SessionService',\n            methods: ['CreateSession', 'GetSession', 'DeleteSession', 'ListSessions'],\n          },\n          {\n            name: 'ContextService',\n            methods: ['CreateContext', 'GetContext', 'ExecuteCommand'],\n          },\n          {\n            name: 'HealthService',\n            methods: ['Check', 'Watch'],\n          },\n        ],\n      },\n      websocket: {\n        endpoint: '/ws',\n        topics: [\n          {\n            name: 'session-updates',\n            description: 'Real-time session events',\n          },\n          {\n            name: 'context-updates',\n            description: 'Real-time context events',\n          },\n        ],\n      },\n    };\n    \n    return {\n      contents: [\n        {\n          uri: 'api://catalog',\n          mimeType: 'application/json',\n          text: JSON.stringify(catalog, null, 2),\n        },\n      ],\n    };\n  }\n\n  /**\n   * Get REST endpoints from adapter or use defaults\n   */\n  private async getRestEndpoints(): Promise<RestEndpoint[]> {\n    if (this.restAdapter) {\n      const endpointsResponse = await this.restAdapter.listEndpoints();\n      if (endpointsResponse.content[0]?.text) {\n        const data = JSON.parse(endpointsResponse.content[0].text);\n        return data.endpoints as RestEndpoint[];\n      }\n    }\n    \n    // Return default endpoints if adapter not available\n    return [\n      {\n        path: '/sessions',\n        methods: ['GET', 'POST', 'DELETE'],\n        description: 'Session management',\n      },\n      {\n        path: '/sessions/:id',\n        methods: ['GET', 'DELETE'],\n        description: 'Individual session operations',\n      },\n      {\n        path: '/contexts',\n        methods: ['GET', 'POST', 'PUT', 'DELETE'],\n        description: 'Context management',\n      },\n      {\n        path: '/contexts/:id',\n        methods: ['GET', 'PUT', 'DELETE'],\n        description: 'Individual context operations',\n      },\n      {\n        path: '/contexts/:id/execute',\n        methods: ['POST'],\n        description: 'Execute commands in context',\n      },\n      {\n        path: '/api-keys',\n        methods: ['GET', 'POST'],\n        description: 'API key management',\n      },\n      {\n        path: '/api-keys/:id',\n        methods: ['DELETE'],\n        description: 'Individual API key operations',\n      },\n      {\n        path: '/health',\n        methods: ['GET'],\n        description: 'Health check',\n      },\n    ];\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/resources/system-health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/server.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2759,2762],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2759,2762],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3336,3339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3336,3339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":109,"column":9,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":109,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3361,3369],"text":"Boolean(wsServer)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":303,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9409,9412],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9409,9412],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Server Implementation\n * @module mcp/server\n * @description Model Context Protocol server that exposes our multi-protocol platform to LLMs\n */\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport {\n  CallToolRequestSchema,\n  ListResourcesRequestSchema,\n  ReadResourceRequestSchema,\n  ListToolsRequestSchema,\n  ErrorCode,\n  McpError,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { logger } from '../utils/logger.js';\nimport { InMemorySessionStore } from '../store/in-memory-session-store.js';\nimport { MCPAuthBridge } from './auth/mcp-auth.js';\nimport { \n  TransportType, \n  getTransportType, \n  createStdioTransport, \n  createHttpTransport \n} from './transport/index.js';\nimport { RestAdapter } from './adapters/rest-adapter.js';\nimport { GrpcAdapter } from './adapters/grpc-adapter.js';\nimport { WebSocketAdapter } from './adapters/ws-adapter.js';\nimport { WSConnectionManager } from '../ws/connection-manager.js';\nimport { WSSubscriptionManager } from '../ws/subscription-manager.js';\nimport { Application } from 'express';\nimport type { Server as GrpcServer } from '@grpc/grpc-js';\n\n// Import tool handlers\nimport { ExecuteApiTool } from './tools/execute-api.js';\nimport { SessionTools } from './tools/session-tools.js';\nimport { BrowserContextTool } from './tools/browser-context.js';\nimport { ExecuteInContextTool } from './tools/execute-in-context.js';\nimport { TOOL_DEFINITIONS } from './tools/tool-definitions.js';\n\n// Import resource handlers\nimport { ApiCatalogResource } from './resources/api-catalog.js';\nimport { SystemHealthResource } from './resources/system-health.js';\n\n// Import types\nimport type { \n  ExecuteApiArgs,\n  CreateSessionArgs,\n  ListSessionsArgs,\n  DeleteSessionArgs,\n  CreateBrowserContextArgs,\n  ExecuteInContextArgs \n} from './types/tool-types.js';\n\n// Create store instance\nconst sessionStore = new InMemorySessionStore(logger.child({ module: 'session-store' }));\nconst authBridge = new MCPAuthBridge(sessionStore, logger.child({ module: 'mcp-auth' }));\n\n/**\n * MCP Server implementation for multi-protocol API platform\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n */\nexport class MCPServer {\n  private server: Server;\n  private restAdapter?: RestAdapter;\n  private grpcAdapter?: GrpcAdapter;\n  private wsAdapter?: WebSocketAdapter;\n  \n  // Tool handlers\n  private executeApiTool: ExecuteApiTool;\n  private sessionTools: SessionTools;\n  private browserContextTool: BrowserContextTool;\n  private executeInContextTool: ExecuteInContextTool;\n  \n  // Resource handlers\n  private apiCatalogResource: ApiCatalogResource;\n  private systemHealthResource: SystemHealthResource;\n\n  constructor(\n    app?: Application,\n    grpcServer?: GrpcServer,\n    wsServer?: any\n  ) {\n    this.server = new Server(\n      {\n        name: 'puppeteer-mcp',\n        version: '0.1.0',\n      },\n      {\n        capabilities: {\n          resources: {},\n          tools: {},\n          prompts: {},\n        },\n      }\n    );\n    \n    // Initialize protocol adapters\n    if (app) {\n      this.restAdapter = new RestAdapter(app);\n    }\n    \n    if (grpcServer) {\n      // GrpcAdapter expects a specific GrpcServer type, not the generic grpc.Server\n      // For now, we'll cast it as any to avoid type issues\n      this.grpcAdapter = new GrpcAdapter(grpcServer as any);\n    }\n    \n    if (wsServer) {\n      // WebSocketAdapter needs logger and managers, we'll create minimal ones\n      const wsLogger = logger.child({ module: 'ws-adapter' });\n      const connectionManager = new WSConnectionManager(wsLogger);\n      const subscriptionManager = new WSSubscriptionManager(wsLogger, connectionManager);\n      this.wsAdapter = new WebSocketAdapter(wsLogger, connectionManager, subscriptionManager);\n    }\n    \n    // Initialize tool handlers\n    this.executeApiTool = new ExecuteApiTool(this.restAdapter, this.grpcAdapter, this.wsAdapter);\n    this.sessionTools = new SessionTools(sessionStore);\n    this.browserContextTool = new BrowserContextTool(authBridge);\n    this.executeInContextTool = new ExecuteInContextTool(this.restAdapter);\n    \n    // Initialize resource handlers\n    this.apiCatalogResource = new ApiCatalogResource(this.restAdapter);\n    this.systemHealthResource = new SystemHealthResource();\n    \n    this.setupHandlers();\n  }\n\n  /**\n   * Set up request handlers for MCP protocol\n   */\n  private setupHandlers(): void {\n    this.setupToolHandlers();\n    this.setupResourceHandlers();\n  }\n\n  /**\n   * Set up tool-related handlers\n   */\n  private setupToolHandlers(): void {\n    // List available tools\n    this.server.setRequestHandler(ListToolsRequestSchema, () => {\n      return {\n        tools: TOOL_DEFINITIONS,\n      };\n    });\n\n    // Execute tool calls\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const { name, arguments: args } = request.params;\n      \n      logger.info({\n        msg: 'MCP tool execution',\n        tool: name,\n        timestamp: new Date().toISOString(),\n      });\n\n      try {\n        switch (name) {\n          case 'execute-api':\n            return await this.executeApiTool.execute(args as unknown as ExecuteApiArgs);\n          case 'create-session':\n            return await this.sessionTools.createSession(args as unknown as CreateSessionArgs);\n          case 'list-sessions':\n            return await this.sessionTools.listSessions(args as unknown as ListSessionsArgs);\n          case 'delete-session':\n            return await this.sessionTools.deleteSession(args as unknown as DeleteSessionArgs);\n          case 'create-browser-context':\n            return await this.browserContextTool.createBrowserContext(args as unknown as CreateBrowserContextArgs);\n          case 'execute-in-context':\n            return await this.executeInContextTool.execute(args as unknown as ExecuteInContextArgs);\n          default:\n            throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`);\n        }\n      } catch (error) {\n        logger.error({\n          msg: 'MCP tool execution failed',\n          tool: name,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        });\n        throw error;\n      }\n    });\n  }\n\n  /**\n   * Set up resource-related handlers\n   */\n  private setupResourceHandlers(): void {\n    // List available resources\n    this.server.setRequestHandler(ListResourcesRequestSchema, () => {\n      return {\n        resources: [\n          {\n            uri: 'api://catalog',\n            name: 'API Catalog',\n            description: 'Complete catalog of available APIs',\n            mimeType: 'application/json',\n          },\n          {\n            uri: 'api://health',\n            name: 'System Health',\n            description: 'Current system health and status',\n            mimeType: 'application/json',\n          },\n        ],\n      };\n    });\n\n    // Read resource content\n    this.server.setRequestHandler(ReadResourceRequestSchema, async (request) => {\n      const { uri } = request.params;\n      \n      logger.info({\n        msg: 'MCP resource access',\n        resource: uri,\n        timestamp: new Date().toISOString(),\n      });\n\n      switch (uri) {\n        case 'api://catalog': {\n          const catalog = await this.apiCatalogResource.getApiCatalog();\n          return {\n            contents: catalog.contents,\n          };\n        }\n        case 'api://health': {\n          const health = this.systemHealthResource.getSystemHealth();\n          return {\n            contents: health.contents,\n          };\n        }\n        default:\n          throw new McpError(ErrorCode.InvalidRequest, `Unknown resource: ${uri}`);\n      }\n    });\n  }\n\n  /**\n   * Start the MCP server\n   */\n  async start(): Promise<void> {\n    const transportType = getTransportType();\n    \n    logger.info({\n      msg: 'Starting MCP server',\n      transportType,\n      timestamp: new Date().toISOString(),\n    });\n\n    switch (transportType) {\n      case TransportType.STDIO: {\n        const stdioTransport = createStdioTransport();\n        await this.server.connect(stdioTransport.getTransport());\n        // Await any async connection setup\n        await new Promise<void>(resolve => { setImmediate(resolve); });\n        \n        logger.info({\n          msg: 'MCP server started with stdio transport',\n          timestamp: new Date().toISOString(),\n        });\n        break;\n      }\n      \n      case TransportType.HTTP: {\n        // HTTP transport requires a different approach\n        // The MCP SDK doesn't directly support HTTP transport yet\n        // We'll need to implement a custom bridge\n        const httpTransport = createHttpTransport();\n        await httpTransport.start();\n        \n        logger.info({\n          msg: 'MCP HTTP transport started',\n          note: 'HTTP transport bridge implementation pending',\n          timestamp: new Date().toISOString(),\n        });\n        break;\n      }\n      \n      default:\n        throw new Error(`Unsupported transport type: ${String(transportType)}`);\n    }\n  }\n\n  /**\n   * Stop the MCP server\n   */\n  async stop(): Promise<void> {\n    await this.server.close();\n    \n    logger.info({\n      msg: 'MCP server stopped',\n      timestamp: new Date().toISOString(),\n    });\n  }\n}\n\n// Export factory function to create MCP server with protocol adapters\nexport function createMCPServer(options?: {\n  app?: Application;\n  grpcServer?: GrpcServer;\n  wsServer?: any;\n}): MCPServer {\n  return new MCPServer(options?.app ?? undefined, options?.grpcServer ?? undefined, options?.wsServer ?? undefined);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/start-mcp.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":17,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":17,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * MCP Server Startup Script\n * @module mcp/start-mcp\n * @description Standalone script to start the MCP server with all protocol adapters\n */\n\nimport { createMCPServer } from './server.js';\nimport { createApp } from '../server.js';\nimport { logger } from '../utils/logger.js';\n\nconst log = logger.child({ module: 'mcp-startup' });\n\n/**\n * Start the MCP server with all protocol integrations\n */\nasync function startMCPServer() {\n  try {\n    log.info('Starting MCP server with all protocol adapters...');\n    \n    // Create the Express app with all REST routes\n    const app = createApp();\n    \n    // Create MCP server with REST adapter\n    // Note: gRPC and WebSocket adapters require additional integration work\n    // with the actual server instances, not just the factory functions\n    const mcpServer = createMCPServer({\n      app,\n      // grpcServer and wsServer can be added later when properly integrated\n    });\n    \n    // Start the MCP server\n    await mcpServer.start();\n    \n    log.info('MCP server started successfully');\n    log.info('Transport type:', process.env.MCP_TRANSPORT ?? 'stdio');\n    \n    // Handle graceful shutdown\n    process.on('SIGINT', () => {\n      void (async () => {\n        log.info('Shutting down MCP server...');\n        await mcpServer.stop();\n        process.exit(0);\n      })();\n    });\n    \n    process.on('SIGTERM', () => {\n      void (async () => {\n        log.info('Shutting down MCP server...');\n        await mcpServer.stop();\n        process.exit(0);\n      })();\n    });\n    \n  } catch (error) {\n    log.error('Failed to start MCP server:', error);\n    process.exit(1);\n  }\n}\n\n// Run if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  void startMCPServer();\n}\n\nexport { startMCPServer };","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/tools/browser-context.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":25,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":25,"endColumn":26,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[716,731],"text":"args.sessionId == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[717,731],"text":"(args.sessionId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[716,731],"text":"!Boolean(args.sessionId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2594,2597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2594,2597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Context Tool Implementation\n * @module mcp/tools/browser-context\n */\n\nimport { logger } from '../../utils/logger.js';\nimport { contextStore } from '../../store/context-store.js';\nimport type { MCPAuthBridge } from '../auth/mcp-auth.js';\nimport type { CreateBrowserContextArgs, ToolResponse } from '../types/tool-types.js';\n\n/**\n * Browser context tool handler\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n */\nexport class BrowserContextTool {\n  constructor(private authBridge: MCPAuthBridge) {}\n\n  /**\n   * Create a browser context\n   */\n  async createBrowserContext(args: CreateBrowserContextArgs): Promise<ToolResponse> {\n    try {\n      // Validate session\n      if (!args.sessionId) {\n        return this.errorResponse('Session ID is required', 'INVALID_SESSION');\n      }\n      \n      // Authenticate using session\n      const authContext = await this.authBridge.authenticate({\n        type: 'session',\n        credentials: args.sessionId,\n      });\n      \n      // Check permissions\n      await this.authBridge.requireToolPermission(authContext, 'createContext');\n      \n      // Create context\n      const context = await contextStore.create({\n        sessionId: args.sessionId,\n        name: args.name ?? 'browser-context',\n        type: 'puppeteer',\n        config: args.options ?? {},\n        metadata: {\n          createdBy: 'mcp',\n          username: authContext.username,\n        },\n        status: 'active',\n        userId: authContext.userId,\n      });\n      \n      logger.info({\n        msg: 'MCP browser context created',\n        contextId: context.id,\n        userId: authContext.userId,\n        sessionId: args.sessionId,\n      });\n      \n      return this.successResponse({\n        contextId: context.id,\n        name: context.name,\n        type: context.type,\n        status: context.status,\n        createdAt: context.createdAt,\n      });\n    } catch (error) {\n      logger.error({\n        msg: 'MCP browser context creation failed',\n        error: error instanceof Error ? error.message : 'Unknown error',\n        sessionId: args.sessionId,\n      });\n      \n      return this.errorResponse(\n        error instanceof Error ? error.message : 'Failed to create context',\n        'CONTEXT_CREATION_FAILED'\n      );\n    }\n  }\n\n  /**\n   * Create error response\n   */\n  private errorResponse(error: string, code: string): ToolResponse {\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify({ error, code }),\n      }],\n    };\n  }\n\n  /**\n   * Create success response\n   */\n  private successResponse(data: any): ToolResponse {\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(data),\n      }],\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/tools/execute-api.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":72,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":72,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2142,2156],"text":"args.sessionId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2142,2156],"text":"args.sessionId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2142,2156],"text":"Boolean(args.sessionId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2414,2417],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2414,2417],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3055,3058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3055,3058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3462,3465],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3462,3465],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":144,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":144,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3879,3882],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3879,3882],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Execute API Tool Implementation\n * @module mcp/tools/execute-api\n */\n\nimport { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { logger } from '../../utils/logger.js';\nimport type { RestAdapter } from '../adapters/rest-adapter.js';\nimport type { GrpcAdapter } from '../adapters/grpc-adapter.js';\nimport type { WebSocketAdapter } from '../adapters/ws-adapter.js';\nimport type { ExecuteApiArgs, ToolResponse } from '../types/tool-types.js';\nimport type { MCPResponse } from '../adapters/adapter.interface.js';\n\n/**\n * Execute API tool handler\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n */\nexport class ExecuteApiTool {\n  constructor(\n    private restAdapter?: RestAdapter,\n    private grpcAdapter?: GrpcAdapter,\n    private wsAdapter?: WebSocketAdapter\n  ) {}\n\n  /**\n   * Execute the API tool with reduced complexity\n   */\n  async execute(args: ExecuteApiArgs): Promise<ToolResponse> {\n    const { protocol } = args;\n    \n    try {\n      // Validate and normalize authentication\n      const normalizedAuth = this.normalizeAuth(args);\n      \n      // Execute based on protocol\n      const result = await this.executeForProtocol(protocol, {\n        operation: args.operation,\n        auth: normalizedAuth,\n        sessionId: args.sessionId,\n      });\n      \n      return result;\n    } catch (error) {\n      // If it's already an McpError, re-throw it\n      if (error instanceof McpError) {\n        throw error;\n      }\n      \n      // Otherwise, wrap it\n      logger.error({\n        msg: 'MCP API execution failed',\n        protocol,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      \n      throw new McpError(\n        ErrorCode.InternalError,\n        error instanceof Error ? error.message : 'API execution failed'\n      );\n    }\n  }\n\n  /**\n   * Normalize authentication credentials\n   */\n  private normalizeAuth(args: ExecuteApiArgs): ExecuteApiArgs['auth'] {\n    const { auth } = args;\n    \n    // If session type but no credentials, try to use sessionId from args\n    if (auth && auth.type === 'session' && !auth.credentials) {\n      if (args.sessionId) {\n        return {\n          ...auth,\n          credentials: args.sessionId,\n        };\n      }\n    }\n    \n    return auth;\n  }\n\n  /**\n   * Execute request for specific protocol\n   */\n  private async executeForProtocol(\n    protocol: string, \n    request: any\n  ): Promise<ToolResponse> {\n    switch (protocol) {\n      case 'rest': {\n        const result = await this.executeRestRequest(request);\n        return result;\n      }\n      case 'grpc': {\n        const result = await this.executeGrpcRequest(request);\n        return result;\n      }\n      case 'websocket': {\n        const result = await this.executeWebSocketRequest(request);\n        return result;\n      }\n      default:\n        throw new McpError(\n          ErrorCode.InvalidRequest,\n          `Unsupported protocol: ${protocol}`\n        );\n    }\n  }\n\n  /**\n   * Execute REST request\n   */\n  private async executeRestRequest(request: any): Promise<ToolResponse> {\n    if (!this.restAdapter) {\n      throw new McpError(\n        ErrorCode.InvalidRequest, \n        'REST adapter not initialized. Express app required.'\n      );\n    }\n    \n    const response = await this.restAdapter.executeRequest(request);\n    return this.convertToToolResponse(response);\n  }\n\n  /**\n   * Execute gRPC request\n   */\n  private async executeGrpcRequest(request: any): Promise<ToolResponse> {\n    if (!this.grpcAdapter) {\n      throw new McpError(\n        ErrorCode.InvalidRequest, \n        'gRPC adapter not initialized. gRPC server required.'\n      );\n    }\n    \n    const response = await this.grpcAdapter.executeRequest(request);\n    return this.convertToToolResponse(response);\n  }\n\n  /**\n   * Execute WebSocket request\n   */\n  private async executeWebSocketRequest(request: any): Promise<ToolResponse> {\n    if (!this.wsAdapter) {\n      throw new McpError(\n        ErrorCode.InvalidRequest, \n        'WebSocket adapter not initialized. WebSocket server required.'\n      );\n    }\n    \n    const response = await this.wsAdapter.executeRequest(request);\n    return this.convertToToolResponse(response);\n  }\n\n  /**\n   * Convert MCPResponse to ToolResponse\n   */\n  private convertToToolResponse(response: MCPResponse): ToolResponse {\n    return {\n      content: response.content,\n      _meta: response.metadata,\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/tools/execute-in-context.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2361,2364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2361,2364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":105,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":105,"endColumn":27,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2843,2857],"text":"(args.sessionId != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2843,2857],"text":"(args.sessionId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2843,2857],"text":"(Boolean(args.sessionId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3276,3279],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3276,3279],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":128,"column":9,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":128,"endColumn":28,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3337,3356],"text":"(Boolean((result.content?.[0])))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":128,"column":69,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":128,"endColumn":91,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3397,3419],"text":"(Boolean(result.content[0].text))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Execute In Context Tool Implementation\n * @module mcp/tools/execute-in-context\n */\n\nimport { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js';\nimport { logger } from '../../utils/logger.js';\nimport type { RestAdapter } from '../adapters/rest-adapter.js';\nimport type { ExecuteInContextArgs, ToolResponse } from '../types/tool-types.js';\n\n/**\n * Execute in context tool handler\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n */\nexport class ExecuteInContextTool {\n  constructor(private restAdapter?: RestAdapter) {}\n\n  /**\n   * Execute command in context with reduced complexity\n   */\n  async execute(args: ExecuteInContextArgs): Promise<ToolResponse> {\n    try {\n      // Validate inputs\n      const validation = this.validateArgs(args);\n      if (validation) {\n        return validation;\n      }\n      \n      // Check adapter availability\n      this.ensureRestAdapter();\n      \n      // Execute the command\n      const result = await this.executeCommand(args);\n      \n      // Parse and return response\n      return this.parseResponse(result);\n    } catch (error) {\n      logger.error({\n        msg: 'MCP context execution failed',\n        error: error instanceof Error ? error.message : 'Unknown error',\n        contextId: args.contextId,\n        command: args.command,\n      });\n      \n      // Handle specific error types\n      if (error instanceof McpError) {\n        throw error;\n      }\n      \n      return this.errorResponse(\n        error instanceof Error ? error.message : 'Failed to execute command',\n        'EXECUTION_FAILED'\n      );\n    }\n  }\n\n  /**\n   * Validate input arguments\n   */\n  private validateArgs(args: ExecuteInContextArgs): ToolResponse | null {\n    if (!args.contextId) {\n      return this.errorResponse('Context ID is required', 'INVALID_CONTEXT_ID');\n    }\n    \n    if (!args.command) {\n      return this.errorResponse('Command is required', 'INVALID_COMMAND');\n    }\n    \n    return null;\n  }\n\n  /**\n   * Ensure REST adapter is available\n   */\n  private ensureRestAdapter(): void {\n    if (!this.restAdapter) {\n      throw new McpError(\n        ErrorCode.InvalidRequest, \n        'REST adapter not initialized. Express app required.'\n      );\n    }\n  }\n\n  /**\n   * Execute the command via REST adapter\n   */\n  private async executeCommand(args: ExecuteInContextArgs): Promise<any> {\n    if (!this.restAdapter) {\n      throw new McpError(\n        ErrorCode.InvalidRequest, \n        'REST adapter not initialized'\n      );\n    }\n    const result = await this.restAdapter.executeRequest({\n      operation: {\n        method: 'POST',\n        endpoint: `/v1/contexts/${args.contextId}/execute`,\n        body: {\n          action: args.command,\n          params: args.parameters ?? {},\n        },\n      },\n      // Use session authentication if provided\n      auth: args.sessionId ? {\n        type: 'session',\n        credentials: args.sessionId,\n      } : undefined,\n      sessionId: args.sessionId,\n    });\n    \n    logger.info({\n      msg: 'MCP context command executed',\n      contextId: args.contextId,\n      command: args.command,\n      hasParameters: !!args.parameters,\n    });\n    \n    return result;\n  }\n\n  /**\n   * Parse the response from the adapter\n   */\n  private parseResponse(result: any): ToolResponse {\n    let responseBody = {};\n    \n    if (result.content?.[0] && result.content[0].type === 'text' && result.content[0].text) {\n      try {\n        responseBody = JSON.parse(result.content[0].text);\n      } catch (parseError) {\n        // If parsing fails, return the raw text\n        responseBody = { result: result.content[0].text };\n      }\n    }\n    \n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(responseBody),\n      }],\n    };\n  }\n\n  /**\n   * Create error response\n   */\n  private errorResponse(error: string, code: string): ToolResponse {\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify({ error, code }),\n      }],\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/tools/session-tools.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3117,3120],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3117,3120],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":114,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":114,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3146,3157],"text":"args.userId != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3146,3157],"text":"args.userId ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3146,3157],"text":"Boolean(args.userId)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6264,6267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6264,6267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Tools Implementation\n * @module mcp/tools/session-tools\n */\n\nimport { logger } from '../../utils/logger.js';\nimport { generateTokenPair } from '../../auth/jwt.js';\nimport { userService } from '../auth/user-service.js';\nimport type { InMemorySessionStore } from '../../store/in-memory-session-store.js';\nimport type { SessionData } from '../../types/session.js';\nimport type { \n  CreateSessionArgs, \n  ListSessionsArgs, \n  DeleteSessionArgs, \n  ToolResponse,\n  ToolErrorResponse\n} from '../types/tool-types.js';\n\n/**\n * Session tools handler\n * @nist ia-2 \"Identification and authentication\"\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n */\nexport class SessionTools {\n  constructor(private sessionStore: InMemorySessionStore) {}\n\n  /**\n   * Create a new session\n   * @evidence code, test\n   */\n  async createSession(args: CreateSessionArgs): Promise<ToolResponse> {\n    try {\n      // Validate input\n      if (!args.username || !args.password) {\n        return this.errorResponse('Username and password are required', 'INVALID_CREDENTIALS');\n      }\n\n      // Authenticate user\n      const user = await userService.authenticateUser(args.username, args.password);\n      \n      // Calculate session duration (default 1 hour)\n      const duration = args.duration ?? 3600;\n      const expiresAt = new Date(Date.now() + duration * 1000);\n      \n      // Create session data\n      const sessionData: SessionData = {\n        userId: user.id,\n        username: user.username,\n        roles: user.roles,\n        metadata: {\n          ...user.metadata,\n          authMethod: 'password',\n          createdBy: 'mcp',\n        },\n        createdAt: new Date().toISOString(),\n        expiresAt: expiresAt.toISOString(),\n      };\n      \n      // Create session in store\n      const sessionId = await this.sessionStore.create(sessionData);\n      \n      // Generate JWT tokens\n      const tokens = generateTokenPair(\n        user.id,\n        user.username,\n        user.roles,\n        sessionId\n      );\n      \n      // Log session creation\n      logger.info({\n        msg: 'MCP session created',\n        userId: user.id,\n        username: user.username,\n        sessionId,\n        duration,\n      });\n      \n      return this.successResponse({\n        sessionId,\n        userId: user.id,\n        username: user.username,\n        roles: user.roles,\n        createdAt: sessionData.createdAt,\n        expiresAt: sessionData.expiresAt,\n        tokens: {\n          accessToken: tokens.accessToken,\n          refreshToken: tokens.refreshToken,\n          expiresIn: tokens.expiresIn,\n        },\n      });\n    } catch (error) {\n      logger.error({\n        msg: 'MCP session creation failed',\n        error: error instanceof Error ? error.message : 'Unknown error',\n        username: args.username,\n      });\n      \n      return this.errorResponse(\n        error instanceof Error ? error.message : 'Authentication failed',\n        'AUTH_FAILED'\n      );\n    }\n  }\n\n  /**\n   * List sessions\n   */\n  async listSessions(args: ListSessionsArgs): Promise<ToolResponse> {\n    try {\n      let sessions: any[] = [];\n      \n      if (args.userId) {\n        // Get sessions for specific user\n        const userSessions = await this.sessionStore.getByUserId(args.userId);\n        sessions = userSessions.map(session => ({\n          id: session.id,\n          userId: session.data.userId,\n          username: session.data.username,\n          roles: session.data.roles,\n          createdAt: session.data.createdAt,\n          expiresAt: session.data.expiresAt,\n          lastAccessedAt: session.lastAccessedAt,\n          metadata: session.data.metadata,\n        }));\n        \n        logger.info({\n          msg: 'Listed sessions for user',\n          userId: args.userId,\n          count: sessions.length,\n        });\n      } else {\n        // Note: In production, this should require admin permissions\n        // For now, return empty array for non-user-specific queries\n        logger.warn({\n          msg: 'Session listing without userId not implemented',\n          note: 'Admin functionality required',\n        });\n      }\n      \n      return this.successResponse({\n        sessions,\n        count: sessions.length,\n      });\n    } catch (error) {\n      logger.error({\n        msg: 'MCP session listing failed',\n        error: error instanceof Error ? error.message : 'Unknown error',\n        userId: args.userId,\n      });\n      \n      return this.errorResponse(\n        error instanceof Error ? error.message : 'Failed to list sessions',\n        'LIST_FAILED'\n      );\n    }\n  }\n\n  /**\n   * Delete a session\n   */\n  async deleteSession(args: DeleteSessionArgs): Promise<ToolResponse> {\n    try {\n      // Validate input\n      if (!args.sessionId) {\n        return this.errorResponse('Session ID is required', 'INVALID_SESSION_ID');\n      }\n      \n      // Get session to verify it exists\n      const session = await this.sessionStore.get(args.sessionId);\n      if (!session) {\n        return this.errorResponse('Session not found', 'SESSION_NOT_FOUND');\n      }\n      \n      // Delete the session\n      const deleted = await this.sessionStore.delete(args.sessionId);\n      \n      logger.info({\n        msg: 'MCP session deleted',\n        sessionId: args.sessionId,\n        userId: session.data.userId,\n        deleted,\n      });\n      \n      return this.successResponse({\n        success: deleted,\n        sessionId: args.sessionId,\n        message: deleted ? 'Session deleted successfully' : 'Failed to delete session',\n      });\n    } catch (error) {\n      logger.error({\n        msg: 'MCP session deletion failed',\n        error: error instanceof Error ? error.message : 'Unknown error',\n        sessionId: args.sessionId,\n      });\n      \n      return this.errorResponse(\n        error instanceof Error ? error.message : 'Failed to delete session',\n        'DELETE_FAILED'\n      );\n    }\n  }\n\n  /**\n   * Create error response\n   */\n  private errorResponse(error: string, code: string): ToolResponse {\n    const errorData: ToolErrorResponse = { error, code };\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(errorData),\n      }],\n    };\n  }\n\n  /**\n   * Create success response\n   */\n  private successResponse(data: any): ToolResponse {\n    return {\n      content: [{\n        type: 'text',\n        text: JSON.stringify(data),\n      }],\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/tools/tool-definitions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/transport/http.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":52,"column":12,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":52,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1678,1702],"text":"(this.config.tlsCertPath == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1679,1702],"text":"(this.config.tlsCertPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1678,1702],"text":"(!Boolean(this.config.tlsCertPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":52,"column":40,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":52,"endColumn":62,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1706,1729],"text":"(this.config.tlsKeyPath == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1707,1729],"text":"(this.config.tlsKeyPath ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1706,1729],"text":"(!Boolean(this.config.tlsKeyPath))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":57,"column":15,"nodeType":"CallExpression","endLine":57,"endColumn":52},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":58,"column":14,"nodeType":"CallExpression","endLine":58,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * HTTP Transport for MCP Server\n * @module mcp/transport/http\n * @description Handles MCP communication via HTTP/HTTPS\n */\n\nimport { createServer, Server as HttpServer } from 'http';\nimport { createServer as createHttpsServer, Server as HttpsServer } from 'https';\nimport { readFileSync } from 'fs';\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { logger } from '@utils/logger.js';\nimport { config } from '@core/config.js';\n\ninterface HttpTransportConfig {\n  port: number;\n  host: string;\n  useTls: boolean;\n  tlsCertPath?: string;\n  tlsKeyPath?: string;\n}\n\n/**\n * HTTP/WebSocket transport for MCP\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n * @nist au-3 \"Content of audit records\"\n */\nexport class HttpTransport {\n  private server: HttpServer | HttpsServer;\n  private wsServer: WebSocketServer;\n  private config: HttpTransportConfig;\n  private connections = new Set<WebSocket>();\n\n  constructor(transportConfig?: Partial<HttpTransportConfig>) {\n    this.config = {\n      port: transportConfig?.port ?? parseInt(process.env.MCP_HTTP_PORT ?? '3001'),\n      host: transportConfig?.host ?? process.env.MCP_HTTP_HOST ?? 'localhost',\n      useTls: transportConfig?.useTls ?? config.TLS_ENABLED,\n      tlsCertPath: transportConfig?.tlsCertPath ?? config.TLS_CERT_PATH,\n      tlsKeyPath: transportConfig?.tlsKeyPath ?? config.TLS_KEY_PATH,\n    };\n\n    this.server = this.createServer();\n    this.wsServer = new WebSocketServer({ server: this.server });\n    this.setupWebSocketHandlers();\n  }\n\n  /**\n   * Create HTTP or HTTPS server based on configuration\n   */\n  private createServer(): HttpServer | HttpsServer {\n    if (this.config.useTls) {\n      if (!this.config.tlsCertPath || !this.config.tlsKeyPath) {\n        throw new Error('TLS certificate and key paths required when TLS is enabled');\n      }\n\n      const tlsOptions = {\n        cert: readFileSync(this.config.tlsCertPath),\n        key: readFileSync(this.config.tlsKeyPath),\n      };\n\n      logger.info({\n        msg: 'Creating HTTPS server for MCP',\n        port: this.config.port,\n        host: this.config.host,\n        timestamp: new Date().toISOString(),\n      });\n\n      return createHttpsServer(tlsOptions);\n    }\n\n    logger.info({\n      msg: 'Creating HTTP server for MCP',\n      port: this.config.port,\n      host: this.config.host,\n      timestamp: new Date().toISOString(),\n    });\n\n    return createServer();\n  }\n\n  /**\n   * Set up WebSocket event handlers\n   */\n  private setupWebSocketHandlers(): void {\n    this.wsServer.on('connection', (ws, request) => {\n      const clientIp = request.socket.remoteAddress;\n      \n      logger.info({\n        msg: 'MCP HTTP transport connection established',\n        clientIp,\n        timestamp: new Date().toISOString(),\n      });\n\n      this.connections.add(ws);\n\n      ws.on('error', (error) => {\n        logger.error({\n          msg: 'MCP WebSocket error',\n          error: error.message,\n          clientIp,\n          timestamp: new Date().toISOString(),\n        });\n      });\n\n      ws.on('close', () => {\n        logger.info({\n          msg: 'MCP WebSocket connection closed',\n          clientIp,\n          timestamp: new Date().toISOString(),\n        });\n        this.connections.delete(ws);\n      });\n    });\n\n    this.wsServer.on('error', (error) => {\n      logger.error({\n        msg: 'MCP WebSocket server error',\n        error: error.message,\n        timestamp: new Date().toISOString(),\n      });\n    });\n  }\n\n  /**\n   * Start the HTTP transport\n   */\n  async start(): Promise<void> {\n    await new Promise<void>((resolve, reject) => {\n      this.server.listen(this.config.port, this.config.host, () => {\n        logger.info({\n          msg: 'MCP HTTP transport started',\n          url: `${this.config.useTls ? 'https' : 'http'}://${this.config.host}:${this.config.port}`,\n          timestamp: new Date().toISOString(),\n        });\n        resolve();\n      });\n\n      this.server.on('error', (error) => {\n        logger.error({\n          msg: 'MCP HTTP server error',\n          error: error.message,\n          timestamp: new Date().toISOString(),\n        });\n        reject(error);\n      });\n    });\n  }\n\n  /**\n   * Stop the HTTP transport\n   */\n  async stop(): Promise<void> {\n    logger.info({\n      msg: 'Stopping MCP HTTP transport',\n      timestamp: new Date().toISOString(),\n    });\n\n    // Close all WebSocket connections\n    for (const ws of this.connections) {\n      ws.close();\n    }\n    this.connections.clear();\n\n    // Close WebSocket server\n    await new Promise<void>((resolve) => {\n      this.wsServer.close(() => {\n        logger.info({\n          msg: 'MCP WebSocket server closed',\n          timestamp: new Date().toISOString(),\n        });\n        resolve();\n      });\n    });\n\n    // Close HTTP server\n    await new Promise<void>((resolve) => {\n      this.server.close(() => {\n        logger.info({\n          msg: 'MCP HTTP server closed',\n          timestamp: new Date().toISOString(),\n        });\n        resolve();\n      });\n    });\n  }\n\n  /**\n   * Get the WebSocket server instance\n   */\n  getWebSocketServer(): WebSocketServer {\n    return this.wsServer;\n  }\n\n  /**\n   * Get the HTTP server instance\n   */\n  getHttpServer(): HttpServer | HttpsServer {\n    return this.server;\n  }\n}\n\n/**\n * Factory function to create HTTP transport\n */\nexport function createHttpTransport(config?: Partial<HttpTransportConfig>): HttpTransport {\n  return new HttpTransport(config);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/transport/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/transport/stdio.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/types/resource-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/mcp/types/tool-types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[584,587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[584,587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":82,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":82,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1426,1429],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1426,1429],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1873,1876],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1873,1876],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Tool Type Definitions\n * @module mcp/types/tool-types\n */\n\n/**\n * Authentication types for MCP tools\n */\nexport interface MCPAuth {\n  type: 'jwt' | 'apikey' | 'session';\n  credentials: string;\n}\n\n/**\n * Base tool arguments\n */\nexport interface BaseToolArgs {\n  sessionId?: string;\n  auth?: MCPAuth;\n}\n\n/**\n * Execute API tool arguments\n */\nexport interface ExecuteApiArgs extends BaseToolArgs {\n  protocol: 'rest' | 'grpc' | 'websocket';\n  operation: {\n    method?: string;\n    endpoint?: string;\n    service?: string;\n    procedure?: string;\n    type?: string;\n    body?: any;\n    headers?: Record<string, string>;\n    metadata?: Record<string, string>;\n  };\n}\n\n/**\n * Create session tool arguments\n */\nexport interface CreateSessionArgs {\n  username: string;\n  password: string;\n  duration?: number;\n}\n\n/**\n * List sessions tool arguments\n */\nexport interface ListSessionsArgs {\n  userId?: string;\n}\n\n/**\n * Delete session tool arguments\n */\nexport interface DeleteSessionArgs {\n  sessionId: string;\n}\n\n/**\n * Create browser context arguments\n */\nexport interface CreateBrowserContextArgs extends BaseToolArgs {\n  name?: string;\n  options?: {\n    headless?: boolean;\n    viewport?: {\n      width: number;\n      height: number;\n    };\n  };\n}\n\n/**\n * Execute in context arguments\n */\nexport interface ExecuteInContextArgs extends BaseToolArgs {\n  contextId: string;\n  command: string;\n  parameters?: Record<string, any>;\n}\n\n/**\n * Standard tool response format\n */\nexport interface ToolResponse {\n  content: Array<{\n    type: 'text' | 'image' | 'resource';\n    text?: string;\n    data?: unknown;\n    mimeType?: string;\n  }>;\n  isError?: boolean;\n  _meta?: Record<string, unknown>;\n}\n\n/**\n * Tool error response\n */\nexport interface ToolErrorResponse {\n  error: string;\n  code: string;\n}\n\n/**\n * Tool success response\n */\nexport interface ToolSuccessResponse<T = any> {\n  data?: T;\n  success?: boolean;\n  message?: string;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/action-executor.ts","messages":[],"suppressedMessages":[{"ruleId":"require-await","severity":2,"message":"Async method 'validate' has no 'await' expression.","line":166,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":166,"endColumn":17,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'validate' has no 'await' expression.","line":166,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":166,"endColumn":17,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"require-await","severity":2,"message":"Async method 'validateBatch' has no 'await' expression.","line":225,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":225,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"require-await","severity":2,"message":"Async method 'getHistory' has no 'await' expression.","line":280,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":280,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getHistory' has no 'await' expression.","line":280,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":280,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"require-await","severity":2,"message":"Async method 'clearHistory' has no 'await' expression.","line":300,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":300,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'clearHistory' has no 'await' expression.","line":300,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":300,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"require-await","severity":2,"message":"Async method 'getMetrics' has no 'await' expression.","line":311,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":311,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'getMetrics' has no 'await' expression.","line":311,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":311,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/batch-executor.ts","messages":[],"suppressedMessages":[{"ruleId":"require-await","severity":2,"message":"Async method 'validateBatch' has no 'await' expression.","line":146,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":146,"endColumn":30,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'validateBatch' has no 'await' expression.","line":146,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":146,"endColumn":30,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/execution-helper.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handler-registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/content-helpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":29,"column":65,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":29,"endColumn":79,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[852,866],"text":"(action.quality != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[852,866],"text":"(action.quality ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[852,866],"text":"(Boolean(action.quality))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":69,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":69,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1974,1991],"text":"action.pageRanges != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1974,1991],"text":"action.pageRanges ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1974,1991],"text":"Boolean(action.pageRanges)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":91,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":91,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[2488,2504],"text":"action.selector == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[2489,2504],"text":"(action.selector ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[2488,2504],"text":"!Boolean(action.selector)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":156,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":156,"endColumn":28,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4208,4223],"text":"(action.fullPage ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4208,4223],"text":"(action.fullPage === true)"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Helper functions for content actions\n * @module puppeteer/actions/handlers/content-helpers\n */\n\nimport type { Page } from 'puppeteer';\nimport type {\n  ScreenshotAction,\n  PDFAction,\n  ActionResult,\n  ActionContext,\n} from '../../interfaces/action-executor.interface.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:content-helpers');\n\n/**\n * Build screenshot options from action\n */\nexport function buildScreenshotOptions(action: ScreenshotAction): Parameters<Page['screenshot']>[0] {\n  const options: Parameters<Page['screenshot']>[0] = {\n    type: action.format ?? 'png',\n    fullPage: action.fullPage ?? false,\n    encoding: 'binary',\n  };\n\n  // Add quality for JPEG/WebP\n  if ((action.format === 'jpeg' || action.format === 'webp') && action.quality) {\n    const qualityOptions = options as { quality?: number };\n    qualityOptions.quality = Math.max(1, Math.min(100, action.quality));\n  }\n\n  return options;\n}\n\n/**\n * Build PDF margin options\n */\nexport function buildPdfMargins(margin?: PDFAction['margin']): NonNullable<Parameters<Page['pdf']>[0]>['margin'] {\n  if (!margin) {\n    return undefined;\n  }\n  \n  return {\n    top: margin.top ?? '0.5in',\n    bottom: margin.bottom ?? '0.5in',\n    left: margin.left ?? '0.5in',\n    right: margin.right ?? '0.5in',\n  };\n}\n\n/**\n * Build PDF options from action\n */\nexport function buildPdfOptions(action: PDFAction): Parameters<Page['pdf']>[0] {\n  const pdfOptions: Parameters<Page['pdf']>[0] = {\n    format: action.format ?? 'letter',\n    landscape: action.landscape ?? false,\n    printBackground: action.printBackground ?? true,\n    scale: action.scale ?? 1,\n    displayHeaderFooter: action.displayHeaderFooter ?? false,\n    headerTemplate: action.headerTemplate,\n    footerTemplate: action.footerTemplate,\n    preferCSSPageSize: action.preferCSSPageSize ?? false,\n  };\n\n  // Add page ranges if specified\n  if (action.pageRanges) {\n    pdfOptions.pageRanges = action.pageRanges;\n  }\n\n  // Add margins if specified\n  const margins = buildPdfMargins(action.margin);\n  if (margins) {\n    pdfOptions.margin = margins;\n  }\n\n  return pdfOptions;\n}\n\n/**\n * Capture element screenshot\n */\nexport async function captureElementScreenshot(\n  action: ScreenshotAction,\n  page: Page,\n  screenshotOptions: Parameters<Page['screenshot']>[0],\n  context: ActionContext\n): Promise<Omit<ActionResult<Buffer>, 'duration' | 'timestamp'>> {\n  if (!action.selector) {\n    throw new Error('Selector is required for element screenshot');\n  }\n  const sanitizedSelector = sanitizeSelector(action.selector);\n  \n  // Wait for element to be visible\n  await page.waitForSelector(sanitizedSelector, {\n    timeout: action.timeout ?? 30000,\n    visible: true,\n  });\n\n  const element = await page.$(sanitizedSelector);\n  if (!element) {\n    throw new Error(`Element not found: ${sanitizedSelector}`);\n  }\n\n  // Take element screenshot\n  const screenshot = await element.screenshot(screenshotOptions) as Buffer;\n\n  logger.info('Element screenshot action completed', {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    pageId: action.pageId,\n    selector: sanitizedSelector,\n    size: screenshot.length,\n  });\n\n  return {\n    success: true,\n    actionType: 'screenshot',\n    data: screenshot,\n    metadata: {\n      type: 'element',\n      selector: sanitizedSelector,\n      originalSelector: action.selector,\n      format: action.format ?? 'png',\n      size: screenshot.length,\n    },\n  };\n}\n\n/**\n * Capture page screenshot\n */\nexport async function capturePageScreenshot(\n  action: ScreenshotAction,\n  page: Page,\n  screenshotOptions: Parameters<Page['screenshot']>[0],\n  context: ActionContext\n): Promise<Omit<ActionResult<Buffer>, 'duration' | 'timestamp'>> {\n  const screenshot = await page.screenshot(screenshotOptions) as Buffer;\n\n  logger.info('Page screenshot action completed', {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    pageId: action.pageId,\n    fullPage: action.fullPage,\n    size: screenshot.length,\n  });\n\n  return {\n    success: true,\n    actionType: 'screenshot',\n    data: screenshot,\n    metadata: {\n      type: action.fullPage ? 'fullPage' : 'viewport',\n      format: action.format ?? 'png',\n      size: screenshot.length,\n      viewport: page.viewport(),\n    },\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/content.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":55,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":55,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1485,1500],"text":"(action.selector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1485,1500],"text":"(action.selector ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1485,1500],"text":"(Boolean(action.selector))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":143,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":143,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3723,3740],"text":"(action.pageRanges != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3723,3740],"text":"(action.pageRanges ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3723,3740],"text":"(Boolean(action.pageRanges))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":199,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":199,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5044,5059],"text":"action.selector != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[5044,5059],"text":"action.selector ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5044,5059],"text":"Boolean(action.selector)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5564,5567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5564,5567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":212,"column":11,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":212,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5725,5728],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5725,5728],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":216,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":216,"endColumn":37,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Content-related browser action handlers\n * @module puppeteer/actions/handlers/content\n */\n\nimport { Page } from 'puppeteer';\nimport type {\n  ScreenshotAction,\n  PDFAction,\n  ContentAction,\n  ActionResult,\n  ActionContext,\n} from '../../interfaces/action-executor.interface.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { createLogger } from '../../../utils/logger.js';\nimport {\n  buildScreenshotOptions,\n  buildPdfOptions,\n  captureElementScreenshot,\n  capturePageScreenshot,\n} from './content-helpers.js';\n\nconst logger = createLogger('puppeteer:content');\n\n/**\n * Handle screenshot action\n * @param action - Screenshot action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result with screenshot data\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleScreenshot(\n  action: ScreenshotAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult<Buffer | string>> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing screenshot action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      fullPage: action.fullPage,\n      selector: action.selector,\n      format: action.format,\n      quality: action.quality,\n    });\n\n    const screenshotOptions = buildScreenshotOptions(action);\n\n    // Delegate to specific screenshot method\n    const result = action.selector \n      ? await captureElementScreenshot(action, page, screenshotOptions, context)\n      : await capturePageScreenshot(action, page, screenshotOptions, context);\n\n    const duration = Date.now() - startTime;\n    return {\n      ...result,\n      duration,\n      timestamp: new Date(),\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown screenshot error';\n\n    logger.error('Screenshot action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'screenshot',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        selector: action.selector,\n        format: action.format,\n        fullPage: action.fullPage,\n      },\n    };\n  }\n}\n\n/**\n * Handle PDF generation action\n * @param action - PDF action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result with PDF data\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handlePdf(\n  action: PDFAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult<Buffer>> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing PDF action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      format: action.format,\n      landscape: action.landscape,\n    });\n\n    // Build PDF options\n    const pdfOptions = buildPdfOptions(action);\n\n    // Generate PDF\n    const pdf = Buffer.from(await page.pdf(pdfOptions));\n    \n    const duration = Date.now() - startTime;\n\n    logger.info('PDF action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      size: pdf.length,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'pdf',\n      data: pdf,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        format: action.format ?? 'letter',\n        landscape: action.landscape ?? false,\n        size: pdf.length,\n        pageCount: action.pageRanges ? 'custom' : 'all',\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown PDF error';\n\n    logger.error('PDF action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'pdf',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        format: action.format,\n        landscape: action.landscape,\n      },\n    };\n  }\n}\n\n/**\n * Handle content retrieval action\n * @param action - Content action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result with page content\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleContent(\n  action: ContentAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult<string>> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing content action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n    });\n\n    let content: string;\n    let contentType: string;\n\n    if (action.selector) {\n      // Get content of specific element\n      const sanitizedSelector = sanitizeSelector(action.selector);\n      \n      await page.waitForSelector(sanitizedSelector, {\n        timeout: action.timeout ?? 30000,\n      });\n\n      content = await page.$eval(sanitizedSelector, (el) => {\n        // Check if element has a value property (input/textarea)\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any\n        if ('value' in el && typeof (el as any).value === 'string') {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any\n          return (el as any).value;\n        }\n        // Otherwise get text content\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return el.textContent ?? '';\n      });\n      \n      contentType = 'element';\n    } else {\n      // Get full page content\n      content = await page.content();\n      contentType = 'page';\n    }\n    \n    const duration = Date.now() - startTime;\n\n    logger.info('Content action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      contentType,\n      contentLength: content.length,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'content',\n      data: content,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        type: contentType,\n        selector: action.selector,\n        length: content.length,\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown content error';\n\n    logger.error('Content action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'content',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        selector: action.selector,\n      },\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/cookie-operations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/cookie-validation.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":34,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":34,"endColumn":12,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[794,799],"text":"(value != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[794,799],"text":"(value ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[794,799],"text":"(Boolean(value))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":47,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":47,"endColumn":14,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1215,1222],"text":"domain == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1216,1222],"text":"(domain ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1215,1222],"text":"!Boolean(domain)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":74,"column":7,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":74,"endColumn":11,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1954,1958],"text":"(path != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[1954,1958],"text":"(path ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1954,1958],"text":"(Boolean(path))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":101,"column":31,"nodeType":"Identifier","messageId":"conditionErrorNullableBoolean","endLine":101,"endColumn":37,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2781,2787],"text":"(secure ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareFalse","fix":{"range":[2780,2787],"text":"(secure === false)"},"desc":"Change condition to check if false (`value === false`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Cookie validation functions\n * @module puppeteer/actions/handlers/cookie-validation\n * @nist si-10 \"Information input validation\"\n */\n\nimport type { Cookie } from 'puppeteer';\n\n/**\n * Validate cookie name\n * @param name - Cookie name to validate\n * @throws Error if name is invalid\n */\nexport function validateCookieName(name: string): void {\n  if (!name || name.trim() === '') {\n    throw new Error('Cookie name is required');\n  }\n\n  if (!/^[a-zA-Z0-9_-]+$/.test(name)) {\n    throw new Error('Invalid cookie name format');\n  }\n\n  if (name.length > 255) {\n    throw new Error('Cookie name too long');\n  }\n}\n\n/**\n * Validate cookie value\n * @param value - Cookie value to validate\n * @throws Error if value is invalid\n */\nexport function validateCookieValue(value?: string): void {\n  if (value && value.length > 4096) {\n    throw new Error('Cookie value too long');\n  }\n}\n\n/**\n * Validate and normalize cookie domain\n * @param domain - Cookie domain to validate\n * @param currentUrl - Current page URL for domain validation\n * @returns Normalized domain\n * @throws Error if domain is invalid\n */\nexport function validateCookieDomain(domain: string | undefined, currentUrl: string): string | undefined {\n  if (!domain) {\n    return undefined;\n  }\n\n  // Remove leading dot if present\n  const normalizedDomain = domain.replace(/^\\./, '');\n  \n  // Validate domain format\n  if (!/^[a-zA-Z0-9.-]+$/.test(normalizedDomain)) {\n    throw new Error('Invalid cookie domain format');\n  }\n\n  // Check if domain is related to current URL\n  const currentDomain = new URL(currentUrl).hostname;\n  if (!currentDomain.endsWith(normalizedDomain) && normalizedDomain !== currentDomain) {\n    throw new Error('Cookie domain does not match current page domain');\n  }\n\n  return normalizedDomain;\n}\n\n/**\n * Validate cookie path\n * @param path - Cookie path to validate\n * @throws Error if path is invalid\n */\nexport function validateCookiePath(path?: string): void {\n  if (path && (path.length > 255 || !path.startsWith('/'))) {\n    throw new Error('Invalid cookie path');\n  }\n}\n\n/**\n * Validate cookie expiration\n * @param expires - Cookie expiration time\n * @throws Error if expiration is invalid\n */\nexport function validateCookieExpiration(expires?: number): void {\n  if (expires !== undefined && expires < 0) {\n    throw new Error('Invalid cookie expiration time');\n  }\n}\n\n/**\n * Validate cookie SameSite and security settings\n * @param sameSite - SameSite attribute\n * @param secure - Secure flag\n * @throws Error if settings are invalid\n */\nexport function validateCookieSecurity(sameSite?: 'Strict' | 'Lax' | 'None', secure?: boolean): void {\n  if (sameSite && !['Strict', 'Lax', 'None'].includes(sameSite)) {\n    throw new Error('Invalid SameSite value');\n  }\n\n  if (sameSite === 'None' && !secure) {\n    throw new Error('SameSite=None requires Secure flag');\n  }\n}\n\n/**\n * Validate cookie data for security and correctness\n * @param cookie - Cookie to validate\n * @param currentUrl - Current page URL for domain validation\n * @returns Validated cookie\n * @nist si-10 \"Information input validation\"\n */\nexport function validateCookie(\n  cookie: {\n    name: string;\n    value?: string;\n    domain?: string;\n    path?: string;\n    expires?: number;\n    httpOnly?: boolean;\n    secure?: boolean;\n    sameSite?: 'Strict' | 'Lax' | 'None';\n  },\n  currentUrl: string\n): Cookie {\n  // Validate individual components\n  validateCookieName(cookie.name);\n  validateCookieValue(cookie.value);\n  const domain = validateCookieDomain(cookie.domain, currentUrl);\n  validateCookiePath(cookie.path);\n  validateCookieExpiration(cookie.expires);\n  validateCookieSecurity(cookie.sameSite, cookie.secure);\n\n  // Build validated cookie object\n  const result: Cookie = {\n    name: cookie.name,\n    value: cookie.value ?? '',\n    domain: domain ?? new URL(currentUrl).hostname,\n    path: cookie.path ?? '/',\n    expires: cookie.expires ?? -1,\n    size: (cookie.name.length + (cookie.value ?? '').length),\n    httpOnly: cookie.httpOnly ?? false,\n    secure: cookie.secure ?? false,\n    session: cookie.expires === undefined,\n    sameSite: cookie.sameSite ?? 'Lax',\n  };\n\n  return result;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/cookies.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/evaluation-handle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/evaluation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/interaction-focus.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":218,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5305,5308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5305,5308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":219,"column":11,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":219,"endColumn":18,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[5325,5332],"text":"Boolean(el.blur)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Focus-related interaction handlers for browser automation\n * @module puppeteer/actions/handlers/interaction-focus\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { ActionResult, ActionContext } from '../../interfaces/action-executor.interface.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:interaction-focus');\n\n/**\n * Handle hover action\n * @param selector - CSS selector\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @param timeout - Optional timeout\n * @returns Action result\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleHover(\n  selector: string,\n  page: Page,\n  context: ActionContext,\n  timeout?: number\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing hover action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n    });\n\n    // Sanitize selector for security\n    const sanitizedSelector = sanitizeSelector(selector);\n\n    // Wait for element to be available\n    await page.waitForSelector(sanitizedSelector, {\n      timeout: timeout ?? 30000,\n      visible: true,\n    });\n\n    // Hover over element\n    await page.hover(sanitizedSelector);\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Hover action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector: sanitizedSelector,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'hover',\n      data: {\n        selector: sanitizedSelector,\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown hover error';\n\n    logger.error('Hover action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'hover',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n      },\n    };\n  }\n}\n\n/**\n * Handle focus action\n * @param selector - CSS selector\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @param timeout - Optional timeout\n * @returns Action result\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleFocus(\n  selector: string,\n  page: Page,\n  context: ActionContext,\n  timeout?: number\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing focus action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n    });\n\n    // Sanitize selector for security\n    const sanitizedSelector = sanitizeSelector(selector);\n\n    // Wait for element to be available\n    await page.waitForSelector(sanitizedSelector, {\n      timeout: timeout ?? 30000,\n      visible: true,\n    });\n\n    // Focus on element\n    await page.focus(sanitizedSelector);\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Focus action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector: sanitizedSelector,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'focus',\n      data: {\n        selector: sanitizedSelector,\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown focus error';\n\n    logger.error('Focus action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'focus',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n      },\n    };\n  }\n}\n\n/**\n * Handle blur action\n * @param selector - CSS selector\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @param timeout - Optional timeout\n * @returns Action result\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleBlur(\n  selector: string,\n  page: Page,\n  context: ActionContext,\n  timeout?: number\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing blur action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n    });\n\n    // Sanitize selector for security\n    const sanitizedSelector = sanitizeSelector(selector);\n\n    // Wait for element to be available\n    await page.waitForSelector(sanitizedSelector, {\n      timeout: timeout ?? 30000,\n    });\n\n    // Get element and blur it\n    const element = await page.$(sanitizedSelector);\n    if (!element) {\n      throw new Error(`Element not found: ${sanitizedSelector}`);\n    }\n\n    await element.evaluate((el: any) => {\n      if (el.blur) {\n        el.blur();\n      }\n    });\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Blur action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector: sanitizedSelector,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'blur',\n      data: {\n        selector: sanitizedSelector,\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown blur error';\n\n    logger.error('Blur action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'blur',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n      },\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/interaction-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/interaction.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":152,"column":9,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":152,"endColumn":26,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[4193,4210],"text":"action.clearFirst ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[4193,4210],"text":"action.clearFirst === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4248,4251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4248,4251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Interaction action handlers for browser automation\n * @module puppeteer/actions/handlers/interaction\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { \n  ClickAction,\n  TypeAction,\n  SelectAction,\n  ActionResult, \n  ActionContext \n} from '../../interfaces/action-executor.interface.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { createLogger } from '../../../utils/logger.js';\nimport { prepareElementForInteraction } from './interaction-helpers.js';\n\nconst logger = createLogger('puppeteer:interaction');\n// Re-export focus-related handlers\nexport { handleHover, handleFocus, handleBlur } from './interaction-focus.js';\n/**\n * Handle click action\n * @param action - Click action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleClick(\n  action: ClickAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  try {\n    logger.info('Executing click action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      button: action.button,\n      clickCount: action.clickCount,\n    });\n\n    // Prepare element for interaction\n    const element = await prepareElementForInteraction(page, action.selector, action.timeout);\n\n    // Perform click action\n    await element.click({\n      button: action.button ?? 'left',\n      clickCount: action.clickCount ?? 1,\n      delay: action.delay ?? 0,\n    });\n\n    const duration = Date.now() - startTime;\n    const sanitizedSelector = sanitizeSelector(action.selector);\n\n    logger.info('Click action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: sanitizedSelector,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'click',\n      data: {\n        selector: sanitizedSelector,\n        clickCount: action.clickCount ?? 1,\n        button: action.button ?? 'left',\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n      },\n    };\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown click error';\n    logger.error('Click action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'click',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n      },\n    };\n  }\n}\n\n/**\n * Handle type action\n * @param action - Type action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleType(\n  action: TypeAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  try {\n    logger.info('Executing type action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      textLength: action.text.length,\n      clearFirst: action.clearFirst,\n    });\n\n    // Sanitize selector for security\n    const sanitizedSelector = sanitizeSelector(action.selector);\n\n    // Wait for element to be available\n    await page.waitForSelector(sanitizedSelector, {\n      timeout: action.timeout ?? 30000,\n      visible: true,\n    });\n\n    // Get element\n    const element = await page.$(sanitizedSelector);\n    if (!element) {\n      throw new Error(`Element not found: ${sanitizedSelector}`);\n    }\n\n    // Focus on element\n    await element.focus();\n\n    // Clear existing content if requested\n    if (action.clearFirst) {\n      await element.evaluate((el: any) => {\n        if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {\n          el.value = '';\n        } else {\n          el.textContent = '';\n        }\n      });\n    }\n\n    // Type text with optional delay\n    await element.type(action.text, {\n      delay: action.delay ?? 0,\n    });\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Type action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: sanitizedSelector,\n      textLength: action.text.length,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'type',\n      data: {\n        selector: sanitizedSelector,\n        textLength: action.text.length,\n        clearFirst: action.clearFirst,\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n      },\n    };\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown type error';\n    logger.error('Type action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'type',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n      },\n    };\n  }\n}\n\n/**\n * Handle select action\n * @param action - Select action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleSelect(\n  action: SelectAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  try {\n    logger.info('Executing select action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      values: action.values,\n    });\n\n    // Sanitize selector for security\n    const sanitizedSelector = sanitizeSelector(action.selector);\n\n    // Wait for element to be available\n    await page.waitForSelector(sanitizedSelector, {\n      timeout: action.timeout ?? 30000,\n      visible: true,\n    });\n\n    // Select values\n    const selectedValues = await page.select(sanitizedSelector, ...action.values);\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Select action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: sanitizedSelector,\n      selectedValues,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'select',\n      data: {\n        selector: sanitizedSelector,\n        requestedValues: action.values,\n        selectedValues,\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n      },\n    };\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown select error';\n    logger.error('Select action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'select',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n      },\n    };\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/keyboard-shortcuts.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":51,"column":28,"nodeType":"MemberExpression","endLine":51,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":2,"message":"Variable Assigned to Object Injection Sink","line":141,"column":24,"nodeType":"MemberExpression","endLine":141,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/keyboard-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/keyboard.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/mouse-drag-scroll.ts","messages":[],"suppressedMessages":[{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":87,"column":36,"nodeType":"CallExpression","messageId":"returnsValue","endLine":87,"endColumn":59,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[2233,2256],"text":"{setTimeout(resolve, 10)}"},"desc":"Wrap the expression in `{}`."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/mouse-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/mouse.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/navigation-history.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/navigation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/scroll-dispatch.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":24,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":24,"endColumn":23,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[830,846],"text":"(action.toElement ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[830,846],"text":"(action.toElement === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":24,"column":27,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":24,"endColumn":42,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[850,865],"text":"(action.selector != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[850,865],"text":"(action.selector ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[850,865],"text":"(Boolean(action.selector))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":29,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":29,"endColumn":22,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[971,986],"text":"action.selector != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[971,986],"text":"action.selector ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[971,986],"text":"Boolean(action.selector)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":45,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":45,"endColumn":20,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[1386,1399],"text":"action.smooth ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[1386,1399],"text":"action.smooth === true"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[{"ruleId":"require-await","severity":2,"message":"Async function 'dispatchScrollAction' has no 'await' expression.","line":19,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":19,"endColumn":43,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Scroll action dispatcher\n * @module puppeteer/actions/handlers/scroll-dispatch\n */\n\nimport type { Page } from 'puppeteer';\nimport type { ScrollAction, ActionContext } from '../../interfaces/action-executor.interface.js';\nimport { handleScrollToElement, handleScrollWithinElement } from './scroll-element.js';\nimport { handleScrollPage, handleScrollToCoordinates, handleSmoothScroll } from './scroll-page.js';\n\n/**\n * Dispatch scroll action to appropriate handler\n * @param action - Scroll action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Scroll result\n */\n// eslint-disable-next-line @typescript-eslint/require-await, require-await\nexport async function dispatchScrollAction(\n  action: ScrollAction,\n  page: Page,\n  context: ActionContext\n): Promise<unknown> {\n  if (action.toElement && action.selector) {\n    // Scroll to element\n    return handleScrollToElement(action.selector, page, context);\n  }\n\n  if (action.selector) {\n    // Scroll within element\n    return handleScrollWithinElement({\n      selector: action.selector,\n      direction: action.direction ?? 'down',\n      distance: action.distance ?? 100,\n      page,\n      context\n    });\n  }\n\n  if (action.x !== undefined && action.y !== undefined) {\n    // Scroll to coordinates\n    return handleScrollToCoordinates(action.x, action.y, page, context);\n  }\n\n  if (action.smooth) {\n    // Smooth scroll\n    return handleSmoothScroll(action, page, context, action.duration);\n  }\n\n  // Normal page scroll\n  return handleScrollPage(action, page, context);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/scroll-element-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/scroll-element.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":32,"column":14,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":32,"endColumn":61,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1103,1150],"text":"(Boolean((globalThis as any).document.querySelector(sel)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1118,1121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1118,1121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1394,1397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1394,1397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":42,"column":10,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":42,"endColumn":17,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1437,1444],"text":"(Boolean(element))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":50,"column":23,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":50,"endColumn":54,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1672,1703],"text":"(Boolean((globalThis as any).pageXOffset))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1687,1690],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1687,1690],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":51,"column":22,"nodeType":"MemberExpression","messageId":"conditionErrorAny","endLine":51,"endColumn":53,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[1732,1763],"text":"(Boolean((globalThis as any).pageYOffset))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":51,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1747,1750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1747,1750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":86,"column":14,"nodeType":"CallExpression","messageId":"conditionErrorAny","endLine":86,"endColumn":61,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[2693,2740],"text":"(Boolean((globalThis as any).document.querySelector(sel)))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2708,2711],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2708,2711],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3042,3045],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3042,3045],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":97,"column":12,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":97,"endColumn":14,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3087,3089],"text":"(Boolean(el))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3124,3127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3124,3127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Element scroll handlers for browser automation\n * @module puppeteer/actions/handlers/scroll-element\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { ActionContext } from '../../interfaces/action-executor.interface.js';\nimport type { ScrollWithinElementParams } from './scroll-element-types.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:scroll-element');\n\n/**\n * Handle scroll to element\n * @param selector - CSS selector\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Scroll result\n */\nexport async function handleScrollToElement(\n  selector: string,\n  page: Page,\n  context: ActionContext\n): Promise<{ scrolledToElement: string; elementPosition?: { x: number; y: number } }> {\n  const sanitizedSelector = sanitizeSelector(selector);\n\n  // Check if element exists\n  const elementExists = await page.evaluate((sel: string) => {\n    return !!(globalThis as any).document.querySelector(sel);\n  }, sanitizedSelector);\n\n  if (!elementExists) {\n    throw new Error(`Element not found: ${sanitizedSelector}`);\n  }\n\n  // Scroll to element\n  const elementPosition = await page.evaluate((sel: string) => {\n    const element = (globalThis as any).document.querySelector(sel);\n    if (!element) {\n      throw new Error('Element not found');\n    }\n\n    element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });\n\n    const rect = element.getBoundingClientRect();\n    return {\n      x: rect.left + ((globalThis as any).pageXOffset || 0),\n      y: rect.top + ((globalThis as any).pageYOffset || 0),\n    };\n  }, sanitizedSelector);\n\n  logger.info('Scrolled to element', {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    selector: sanitizedSelector,\n    elementPosition,\n  });\n\n  return {\n    scrolledToElement: sanitizedSelector,\n    elementPosition,\n  };\n}\n\n/**\n * Handle scroll within element\n * @param params - Scroll within element parameters\n * @returns Scroll result\n */\nexport async function handleScrollWithinElement(\n  params: ScrollWithinElementParams\n): Promise<{ scrolledDistance: number; direction: string }> {\n  const { selector, direction, distance, page, context } = params;\n  const sanitizedSelector = sanitizeSelector(selector);\n\n  // Validate distance\n  if (distance < 1 || distance > 10000) {\n    throw new Error('Scroll distance must be between 1 and 10000 pixels');\n  }\n\n  // Check if element exists\n  const elementExists = await page.evaluate((sel: string) => {\n    return !!(globalThis as any).document.querySelector(sel);\n  }, sanitizedSelector);\n\n  if (!elementExists) {\n    throw new Error(`Element not found: ${sanitizedSelector}`);\n  }\n\n  // Scroll within the element\n  const actualDistance = await page.evaluate(\n    (sel: string, scrollDirection: string, scrollDistance: number) => {\n      const el = (globalThis as any).document.querySelector(sel);\n      if (!el || !(el instanceof (globalThis as any).HTMLElement)) {\n        throw new Error('Element not found or not scrollable');\n      }\n\n      let scrollX = 0;\n      let scrollY = 0;\n\n      switch (scrollDirection) {\n        case 'up':\n          scrollY = -scrollDistance;\n          break;\n        case 'down':\n          scrollY = scrollDistance;\n          break;\n        case 'left':\n          scrollX = -scrollDistance;\n          break;\n        case 'right':\n          scrollX = scrollDistance;\n          break;\n        default:\n          throw new Error(`Invalid scroll direction: ${scrollDirection}`);\n      }\n\n      const beforeScrollTop = el.scrollTop;\n      const beforeScrollLeft = el.scrollLeft;\n\n      el.scrollBy(scrollX, scrollY);\n\n      const afterScrollTop = el.scrollTop;\n      const afterScrollLeft = el.scrollLeft;\n\n      const actualX = afterScrollLeft - beforeScrollLeft;\n      const actualY = afterScrollTop - beforeScrollTop;\n\n      return Math.abs(actualX) + Math.abs(actualY);\n    },\n    sanitizedSelector,\n    direction,\n    distance\n  );\n\n  logger.info('Scrolled within element', {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    selector: sanitizedSelector,\n    direction,\n    requestedDistance: distance,\n    actualDistance,\n  });\n\n  return {\n    scrolledDistance: actualDistance,\n    direction,\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/scroll-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/scroll-page.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1196,1199],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1196,1199],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1241,1244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1241,1244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1467,1470],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1467,1470],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1617,1620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1617,1620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1662,1665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1662,1665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2839,2842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2839,2842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2884,2887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2884,2887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3020,3023],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3020,3023],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3163,3166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3163,3166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":110,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":110,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3208,3211],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3208,3211],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4418,4421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4418,4421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":156,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4463,4466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4463,4466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4838,4841],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4838,4841],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4899,4902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4899,4902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":177,"column":9,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":177,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5549,5552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5549,5552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5642,5645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5642,5645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5770,5773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5770,5773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":208,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":208,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5969,5972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5969,5972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6014,6017],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6014,6017],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page scroll handlers for browser automation\n * @module puppeteer/actions/handlers/scroll-page\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { \n  ScrollAction,\n  ActionContext \n} from '../../interfaces/action-executor.interface.js';\nimport { calculateScrollValues, calculateTargetPosition, validateScrollParams } from './scroll-helpers.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:scroll-page');\n\n/**\n * Handle page scroll\n * @param action - Scroll action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Scroll result\n */\nexport async function handleScrollPage(\n  action: ScrollAction,\n  page: Page,\n  context: ActionContext\n): Promise<{ scrolledDistance: number; direction: string; pagePosition: { x: number; y: number } }> {\n  const direction = action.direction ?? 'down';\n  const distance = action.distance ?? 100;\n\n  // Validate distance\n  validateScrollParams(distance);\n\n  // Get current scroll position\n  const beforePosition = await page.evaluate(() => ({\n    x: (globalThis as any).pageXOffset ?? 0,\n    y: (globalThis as any).pageYOffset ?? 0,\n  }));\n\n  // Calculate scroll amounts\n  const { scrollX, scrollY } = calculateScrollValues(direction, distance);\n\n  // Perform scroll\n  await page.evaluate((x: number, y: number) => {\n    (globalThis as any).scrollBy(x, y);\n  }, scrollX, scrollY);\n\n  // Get new scroll position\n  const afterPosition = await page.evaluate(() => ({\n    x: (globalThis as any).pageXOffset ?? 0,\n    y: (globalThis as any).pageYOffset ?? 0,\n  }));\n\n  // Calculate actual scrolled distance\n  const actualDistance = Math.abs(afterPosition.x - beforePosition.x) + \n                       Math.abs(afterPosition.y - beforePosition.y);\n\n  logger.info('Page scrolled', {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    direction,\n    requestedDistance: distance,\n    actualDistance,\n    beforePosition,\n    afterPosition,\n  });\n\n  return {\n    scrolledDistance: actualDistance,\n    direction,\n    pagePosition: afterPosition,\n  };\n}\n\n/**\n * Handle scroll to coordinates\n * @param x - X coordinate\n * @param y - Y coordinate\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Scroll result\n */\nexport async function handleScrollToCoordinates(\n  x: number,\n  y: number,\n  page: Page,\n  context: ActionContext\n): Promise<{ scrolledToPosition: { x: number; y: number }; scrollDistance: number }> {\n  // Validate coordinates\n  if (x < 0 || y < 0 || x > 100000 || y > 100000) {\n    throw new Error('Invalid scroll coordinates');\n  }\n\n  // Get current position\n  const beforePosition = await page.evaluate(() => ({\n    x: (globalThis as any).pageXOffset ?? 0,\n    y: (globalThis as any).pageYOffset ?? 0,\n  }));\n\n  // Scroll to position\n  await page.evaluate((targetX: number, targetY: number) => {\n    (globalThis as any).scrollTo(targetX, targetY);\n  }, x, y);\n\n  // Get new position\n  const afterPosition = await page.evaluate(() => ({\n    x: (globalThis as any).pageXOffset ?? 0,\n    y: (globalThis as any).pageYOffset ?? 0,\n  }));\n\n  // Calculate distance scrolled\n  const scrollDistance = Math.abs(afterPosition.x - beforePosition.x) + \n                        Math.abs(afterPosition.y - beforePosition.y);\n\n  logger.info('Scrolled to coordinates', {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    targetPosition: { x, y },\n    actualPosition: afterPosition,\n    scrollDistance,\n  });\n\n  return {\n    scrolledToPosition: afterPosition,\n    scrollDistance,\n  };\n}\n\n/**\n * Handle smooth scroll\n * @param action - Scroll action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @param duration - Animation duration in milliseconds\n * @returns Scroll result\n */\nexport async function handleSmoothScroll(\n  action: ScrollAction,\n  page: Page,\n  context: ActionContext,\n  duration: number = 500\n): Promise<{ scrolledDistance: number; duration: number }> {\n  const direction = action.direction ?? 'down';\n  const distance = action.distance ?? 100;\n\n  // Validate parameters\n  validateScrollParams(distance, duration);\n\n  const startTime = Date.now();\n\n  // Get current position\n  const startPosition = await page.evaluate(() => ({\n    x: (globalThis as any).pageXOffset ?? 0,\n    y: (globalThis as any).pageYOffset ?? 0,\n  }));\n\n  // Calculate target position\n  const { targetX, targetY } = calculateTargetPosition(\n    startPosition.x,\n    startPosition.y,\n    direction,\n    distance\n  );\n\n  // Perform smooth scroll\n  await page.evaluate(\n    (tX: number, tY: number, dur: number) => {\n      return new Promise<void>((resolve) => {\n        const startX = (globalThis as any).pageXOffset ?? 0;\n        const startY = (globalThis as any).pageYOffset ?? 0;\n        const distanceX = tX - startX;\n        const distanceY = tY - startY;\n        const startTime = performance.now();\n\n        function scrollStep(currentTime: number) {\n          const elapsed = currentTime - startTime;\n          const progress = Math.min(elapsed / dur, 1);\n          \n          // Easing function for smooth animation\n          const easeProgress = progress < 0.5\n            ? 2 * progress * progress\n            : -1 + (4 - 2 * progress) * progress;\n\n          const currentX = startX + distanceX * easeProgress;\n          const currentY = startY + distanceY * easeProgress;\n\n          (globalThis as any).scrollTo(currentX, currentY);\n\n          if (progress < 1) {\n            (globalThis as any).requestAnimationFrame(scrollStep);\n          } else {\n            resolve();\n          }\n        }\n\n        (globalThis as any).requestAnimationFrame(scrollStep);\n      });\n    },\n    targetX,\n    targetY,\n    duration\n  );\n\n  // Get final position\n  const endPosition = await page.evaluate(() => ({\n    x: (globalThis as any).pageXOffset ?? 0,\n    y: (globalThis as any).pageYOffset ?? 0,\n  }));\n\n  const actualDistance = Math.abs(endPosition.x - startPosition.x) + \n                        Math.abs(endPosition.y - startPosition.y);\n  const actualDuration = Date.now() - startTime;\n\n  logger.info('Smooth scroll completed', {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    direction,\n    requestedDistance: distance,\n    actualDistance,\n    duration: actualDuration,\n  });\n\n  return {\n    scrolledDistance: actualDistance,\n    duration: actualDuration,\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/scroll.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/upload-dragdrop.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":116,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":116,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":141,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":141,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4031,4034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4031,4034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":143,"column":12,"nodeType":"Identifier","messageId":"conditionErrorAny","endLine":143,"endColumn":20,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[4113,4121],"text":"(Boolean(dropZone))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4352,4355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4352,4355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4650,4653],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4650,4653],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5010,5013],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5010,5013],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"require-await","severity":2,"message":"Async function 'prepareFileData' has no 'await' expression.","line":116,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":116,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFile from package \"fs\" with non literal argument at index 0","line":121,"column":29,"nodeType":"CallExpression","endLine":121,"endColumn":51,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":155,"column":9,"nodeType":"ReturnStatement","messageId":"unsafeReturn","endLine":155,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4891,4894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4891,4894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":162,"column":39,"nodeType":"CallExpression","messageId":"unsafeReturn","endLine":162,"endColumn":67,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Drag and drop file upload handler\n * @module puppeteer/actions/handlers/upload-dragdrop\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport { promises as fs } from 'fs';\nimport type { Page } from 'puppeteer';\nimport type { ActionResult, ActionContext } from '../../interfaces/action-executor.interface.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { validateFilePaths } from './upload-validation.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:upload-dragdrop');\n\n/**\n * Handle drag and drop file upload\n * @param filePaths - Array of file paths to upload\n * @param selector - Target drop zone selector\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result\n */\nexport async function handleDragDropUpload(\n  filePaths: string[],\n  selector: string,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing drag and drop upload action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n      fileCount: filePaths.length,\n    });\n\n    const sanitizedSelector = sanitizeSelector(selector);\n    const validatedFiles = await validateFilePaths(filePaths, context);\n\n    // Wait for drop zone element\n    await page.waitForSelector(sanitizedSelector, {\n      timeout: 30000,\n      visible: true,\n    });\n\n    // Create file objects for drag and drop\n    const fileData = await prepareFileData(validatedFiles);\n\n    // Simulate drag and drop using JavaScript\n    await simulateDragDrop(page, sanitizedSelector, fileData);\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Drag and drop upload action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector: sanitizedSelector,\n      uploadedFiles: validatedFiles.length,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'dragDropUpload',\n      data: {\n        selector: sanitizedSelector,\n        uploadedFiles: validatedFiles.map(f => ({\n          name: f.name,\n          size: f.size,\n          type: f.type,\n        })),\n        totalSize: validatedFiles.reduce((sum, f) => sum + f.size, 0),\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n        originalFilePaths: filePaths,\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown drag drop upload error';\n\n    logger.error('Drag and drop upload action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'dragDropUpload',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n        originalFilePaths: filePaths,\n      },\n    };\n  }\n}\n\n/**\n * Prepare file data for drag and drop\n */\n// eslint-disable-next-line @typescript-eslint/require-await, require-await\nasync function prepareFileData(validatedFiles: Array<{ path: string; name: string; type: string }>) {\n  return Promise.all(\n    validatedFiles.map(async (file) => {\n      // Security: File path is validated by validateFilePaths\n      // eslint-disable-next-line security/detect-non-literal-fs-filename\n      const content = await fs.readFile(file.path);\n      return {\n        name: file.name,\n        type: file.type,\n        content: Array.from(content),\n      };\n    })\n  );\n}\n\n/**\n * Simulate drag and drop in the browser\n */\nasync function simulateDragDrop(\n  page: Page,\n  selector: string,\n  fileData: Array<{ name: string; type: string; content: number[] }>\n): Promise<void> {\n  await page.evaluate(\n    (dropSelector: string, files: typeof fileData) => {\n      const doc = (globalThis as any).document;\n      const dropZone = doc.querySelector(dropSelector);\n      if (!dropZone) {\n        throw new Error('Drop zone not found');\n      }\n\n      // Create file list\n      const fileList = files.map(fileData => {\n        const uint8Array = new Uint8Array(fileData.content);\n        const File = (globalThis as any).File;\n        const file = new File([uint8Array], fileData.name, {\n          type: fileData.type,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return file;\n      });\n\n      // Create data transfer object\n      const DataTransfer = (globalThis as any).DataTransfer;\n      const dataTransfer = new DataTransfer();\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-return\n      fileList.forEach((file: any) => dataTransfer.items.add(file));\n\n      // Create and dispatch drop event\n      const DragEvent = (globalThis as any).DragEvent;\n      const dropEvent = new DragEvent('drop', {\n        bubbles: true,\n        cancelable: true,\n        dataTransfer,\n      });\n\n      dropZone.dispatchEvent(dropEvent);\n    },\n    selector,\n    fileData\n  );\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/upload-validation.ts","messages":[{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":79,"column":10,"nodeType":"MemberExpression","endLine":79,"endColumn":31}],"suppressedMessages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found stat from package \"fs\" with non literal argument at index 0","line":106,"column":21,"nodeType":"CallExpression","endLine":106,"endColumn":38,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * File upload validation utilities\n * @module puppeteer/actions/handlers/upload-validation\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport { promises as fs } from 'fs';\nimport { extname, basename } from 'path';\nimport type { ActionContext } from '../../interfaces/action-executor.interface.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:upload-validation');\n\n/**\n * Allowed file extensions for security\n * @nist si-10 \"Information input validation\"\n */\nexport const ALLOWED_EXTENSIONS = [\n  '.txt', '.csv', '.json', '.xml', '.pdf', '.doc', '.docx', '.xls', '.xlsx',\n  '.ppt', '.pptx', '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.svg',\n  '.mp3', '.mp4', '.avi', '.mov', '.wav', '.zip', '.tar', '.gz', '.rar'\n];\n\n/**\n * Maximum file size (10MB)\n */\nexport const MAX_FILE_SIZE = 10 * 1024 * 1024;\n\n/**\n * MIME type mapping\n */\nconst MIME_TYPES: Record<string, string> = {\n  '.txt': 'text/plain',\n  '.csv': 'text/csv',\n  '.json': 'application/json',\n  '.xml': 'application/xml',\n  '.pdf': 'application/pdf',\n  '.doc': 'application/msword',\n  '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n  '.xls': 'application/vnd.ms-excel',\n  '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n  '.ppt': 'application/vnd.ms-powerpoint',\n  '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n  '.jpg': 'image/jpeg',\n  '.jpeg': 'image/jpeg',\n  '.png': 'image/png',\n  '.gif': 'image/gif',\n  '.bmp': 'image/bmp',\n  '.webp': 'image/webp',\n  '.svg': 'image/svg+xml',\n  '.mp3': 'audio/mpeg',\n  '.mp4': 'video/mp4',\n  '.avi': 'video/x-msvideo',\n  '.mov': 'video/quicktime',\n  '.wav': 'audio/wav',\n  '.zip': 'application/zip',\n  '.tar': 'application/x-tar',\n  '.gz': 'application/gzip',\n  '.rar': 'application/vnd.rar',\n};\n\n/**\n * Validated file information\n */\nexport interface ValidatedFile {\n  path: string;\n  name: string;\n  size: number;\n  type: string;\n}\n\n/**\n * Get MIME type from file extension\n * @param extension - File extension\n * @returns MIME type\n */\nexport function getMimeType(extension: string): string {\n  return MIME_TYPES[extension] ?? 'application/octet-stream';\n}\n\n/**\n * Validate file paths for security and accessibility\n * @param filePaths - Array of file paths to validate\n * @param context - Action execution context\n * @returns Array of validated file information\n * @nist si-10 \"Information input validation\"\n */\nexport async function validateFilePaths(\n  filePaths: string[],\n  context: ActionContext\n): Promise<ValidatedFile[]> {\n  const validatedFiles: ValidatedFile[] = [];\n\n  for (const filePath of filePaths) {\n    // Validate file path security\n    if (filePath.includes('..') || filePath.includes('./')) {\n      throw new Error(`Invalid file path: ${filePath}`);\n    }\n\n    // Check if file exists and get stats\n    let stats;\n    try {\n      // Security: File path is validated above\n      // eslint-disable-next-line security/detect-non-literal-fs-filename\n      stats = await fs.stat(filePath);\n    } catch (error) {\n      throw new Error(`File not found or not accessible: ${filePath}`);\n    }\n\n    // Check if it's a file (not directory)\n    if (!stats.isFile()) {\n      throw new Error(`Path is not a file: ${filePath}`);\n    }\n\n    // Check file size\n    if (stats.size > MAX_FILE_SIZE) {\n      throw new Error(`File too large: ${filePath} (${stats.size} bytes, max ${MAX_FILE_SIZE})`);\n    }\n\n    // Check file extension\n    const extension = extname(filePath).toLowerCase();\n    if (!ALLOWED_EXTENSIONS.includes(extension)) {\n      throw new Error(`File type not allowed: ${extension}`);\n    }\n\n    // Get file name and MIME type\n    const fileName = basename(filePath);\n    const mimeType = getMimeType(extension);\n\n    validatedFiles.push({\n      path: filePath,\n      name: fileName,\n      size: stats.size,\n      type: mimeType,\n    });\n\n    logger.info('File validated for upload', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      filePath,\n      fileName,\n      fileSize: stats.size,\n      mimeType,\n    });\n  }\n\n  // Check total size\n  const totalSize = validatedFiles.reduce((sum, f) => sum + f.size, 0);\n  if (totalSize > MAX_FILE_SIZE * 5) { // Max 50MB total\n    throw new Error('Total file size too large');\n  }\n\n  return validatedFiles;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/upload.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1694,1697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1694,1697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * File upload action handlers for browser automation\n * @module puppeteer/actions/handlers/upload\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { \n  UploadAction,\n  ActionResult, \n  ActionContext \n} from '../../interfaces/action-executor.interface.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { validateFilePaths } from './upload-validation.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:upload');\n\n/**\n * Handle file upload action\n * @param action - Upload action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleUpload(\n  action: UploadAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing upload action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      fileCount: action.filePaths.length,\n    });\n\n    // Sanitize selector for security\n    const sanitizedSelector = sanitizeSelector(action.selector);\n\n    // Validate file paths\n    const validatedFiles = await validateFilePaths(action.filePaths, context);\n\n    // Wait for file input element\n    await page.waitForSelector(sanitizedSelector, {\n      timeout: action.timeout ?? 30000,\n    });\n\n    // Verify element is a file input\n    const isFileInput = await page.$eval(sanitizedSelector, (el: any) => {\n      return el.tagName === 'INPUT' && el.type === 'file';\n    });\n\n    if (!isFileInput) {\n      throw new Error('Element is not a file input');\n    }\n\n    // Upload files\n    const fileInputElement = await page.$(sanitizedSelector);\n    if (!fileInputElement) {\n      throw new Error(`File input element not found: ${sanitizedSelector}`);\n    }\n\n    await fileInputElement.uploadFile(...validatedFiles.map(f => f.path));\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Upload action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: sanitizedSelector,\n      uploadedFiles: validatedFiles.length,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'upload',\n      data: {\n        selector: sanitizedSelector,\n        uploadedFiles: validatedFiles.map(f => ({\n          name: f.name,\n          size: f.size,\n          type: f.type,\n        })),\n        totalSize: validatedFiles.reduce((sum, f) => sum + f.size, 0),\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n        originalFilePaths: action.filePaths,\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown upload error';\n\n    logger.error('Upload action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      selector: action.selector,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'upload',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: action.selector,\n        originalFilePaths: action.filePaths,\n      },\n    };\n  }\n}\n\n// Re-export drag and drop handler from separate module\nexport { handleDragDropUpload } from './upload-dragdrop.js';","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/waiting-states-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/waiting-states.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":45,"column":16,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":45,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1416,1423],"text":"(timeout != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1416,1423],"text":"(timeout ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1416,1423],"text":"(Boolean(timeout))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":45,"column":24,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":45,"endColumn":26,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[1424,1426],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected any value in conditional. An explicit comparison or type cast is required.","line":127,"column":27,"nodeType":"ChainExpression","messageId":"conditionErrorAny","endLine":127,"endColumn":75,"suggestions":[{"messageId":"conditionFixCastBoolean","fix":{"range":[3323,3371],"text":"(Boolean(((globalThis as any).document?.querySelector(sel))))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3338,3341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3338,3341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/restrict-template-expressions","severity":2,"message":"Invalid type \"never\" of template literal expression.","line":136,"column":53,"nodeType":"Identifier","messageId":"invalidType","endLine":136,"endColumn":58},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":224,"column":28,"nodeType":"Identifier","messageId":"conditionErrorNullableNumber","endLine":224,"endColumn":35,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5755,5762],"text":"(timeout != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5755,5762],"text":"(timeout ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5755,5762],"text":"(Boolean(timeout))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":224,"column":36,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":224,"endColumn":38,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5763,5765],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * State-based waiting handlers for browser automation\n * @module puppeteer/actions/handlers/waiting-states\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { ActionResult, ActionContext } from '../../interfaces/action-executor.interface.js';\nimport type {\n  WaitForElementStateResultParams,\n  WaitForElementStateLogParams,\n  WaitForElementStateParams\n} from './waiting-states-types.js';\nimport { sanitizeSelector } from '../validation.js';\nimport { createLogger } from '../../../utils/logger.js';\n\nconst logger = createLogger('puppeteer:waiting-states');\n\n/**\n * Handle wait for load state\n * @param loadState - Load state to wait for\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @param timeout - Optional timeout\n * @returns Action result\n */\nexport async function handleWaitForLoadState(\n  loadState: 'load' | 'domcontentloaded' | 'networkidle0' | 'networkidle2',\n  page: Page,\n  context: ActionContext,\n  timeout?: number\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing wait for load state action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      loadState,\n    });\n\n    // Use page.waitForLoadState if available, otherwise use navigation\n    await page.waitForNavigation({\n      timeout: timeout || 30000,\n      waitUntil: loadState,\n    });\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Wait for load state action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      loadState,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'waitForLoadState',\n      data: {\n        loadState,\n        url: page.url(),\n      },\n      duration,\n      timestamp: new Date(),\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown wait for load state error';\n\n    logger.error('Wait for load state action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      loadState,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'waitForLoadState',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        loadState,\n      },\n    };\n  }\n}\n\n/**\n * Wait for element based on state\n * @param page - Puppeteer page instance\n * @param sanitizedSelector - Sanitized selector\n * @param state - Element state\n * @param timeout - Timeout in milliseconds\n */\nasync function waitForElementByState(\n  page: Page,\n  sanitizedSelector: string,\n  state: 'visible' | 'hidden' | 'attached' | 'detached',\n  timeout: number\n): Promise<void> {\n  switch (state) {\n    case 'visible':\n      await page.waitForSelector(sanitizedSelector, {\n        timeout,\n        visible: true,\n      });\n      break;\n    case 'hidden':\n      await page.waitForSelector(sanitizedSelector, {\n        timeout,\n        hidden: true,\n      });\n      break;\n    case 'attached':\n      await page.waitForSelector(sanitizedSelector, {\n        timeout,\n      });\n      break;\n    case 'detached':\n      await page.waitForFunction(\n        (sel: string) => !(globalThis as any).document?.querySelector(sel),\n        {\n          timeout,\n          polling: 'mutation',\n        },\n        sanitizedSelector\n      );\n      break;\n    default:\n      throw new Error(`Unsupported element state: ${state}`);\n  }\n}\n\n/**\n * Create wait for element state result\n * @param success - Whether the action succeeded\n * @param selector - Original selector\n * @param sanitizedSelector - Sanitized selector\n * @param state - Element state\n * @param duration - Action duration\n * @param error - Optional error message\n * @returns Action result\n */\nfunction createWaitForElementStateResult(\n  params: WaitForElementStateResultParams\n): ActionResult {\n  const { success, selector, sanitizedSelector, state, duration, error } = params;\n  if (success) {\n    return {\n      success: true,\n      actionType: 'waitForElementState',\n      data: {\n        selector: sanitizedSelector,\n        state,\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        originalSelector: selector,\n      },\n    };\n  }\n  \n  return {\n    success: false,\n    actionType: 'waitForElementState',\n    error: error ?? 'Unknown wait for element state error',\n    duration,\n    timestamp: new Date(),\n    metadata: {\n      originalSelector: selector,\n      state,\n    },\n  };\n}\n\n/**\n * Log wait for element state action\n * @param message - Log message\n * @param context - Action context\n * @param selector - CSS selector\n * @param state - Element state\n * @param additional - Additional log data\n */\nfunction logWaitForElementState(\n  params: WaitForElementStateLogParams\n): void {\n  const { message, context, selector, state, additional } = params;\n  const logData = {\n    sessionId: context.sessionId,\n    contextId: context.contextId,\n    selector,\n    state,\n    ...additional,\n  };\n  \n  if (message.includes('failed')) {\n    logger.error(message, logData);\n  } else {\n    logger.info(message, logData);\n  }\n}\n\n/**\n * Handle wait for element state\n * @param selector - CSS selector\n * @param state - Element state to wait for\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @param timeout - Optional timeout\n * @returns Action result\n */\nexport async function handleWaitForElementState(\n  params: WaitForElementStateParams\n): Promise<ActionResult> {\n  const { selector, state, page, context, timeout } = params;\n  const startTime = Date.now();\n  const effectiveTimeout = timeout || 30000;\n  \n  try {\n    logWaitForElementState({\n      message: 'Executing wait for element state action',\n      context,\n      selector,\n      state,\n    });\n\n    const sanitizedSelector = sanitizeSelector(selector);\n    await waitForElementByState(page, sanitizedSelector, state, effectiveTimeout);\n\n    const duration = Date.now() - startTime;\n    logWaitForElementState({\n      message: 'Wait for element state action completed',\n      context,\n      selector: sanitizedSelector,\n      state,\n      additional: { duration },\n    });\n\n    return createWaitForElementStateResult({\n      success: true,\n      selector,\n      sanitizedSelector,\n      state,\n      duration,\n    });\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown wait for element state error';\n    \n    logWaitForElementState({\n      message: 'Wait for element state action failed',\n      context,\n      selector,\n      state,\n      additional: { error: errorMessage, duration },\n    });\n    \n    return createWaitForElementStateResult({\n      success: false,\n      selector,\n      sanitizedSelector: selector,\n      state,\n      duration,\n      error: errorMessage,\n    });\n  }\n}\n\n/**\n * Create a safe wait function wrapper\n * @param functionString - Function string to wrap\n * @returns Safe function string\n * @nist si-10 \"Information input validation\"\n */\nexport function createSafeWaitFunction(functionString: string): string {\n  // Remove any potential dangerous patterns\n  const sanitizedFunction = functionString\n    .replace(/eval\\s*\\(/gi, 'void(')\n    .replace(/Function\\s*\\(/gi, 'void(')\n    .replace(/constructor/gi, 'void')\n    .replace(/prototype/gi, 'void')\n    .replace(/__proto__/gi, 'void');\n\n  // Wrap function in try-catch for safety\n  return `\n    (function() {\n      try {\n        return (${sanitizedFunction})();\n      } catch (error) {\n        console.error('Wait function error:', error);\n        return false;\n      }\n    })\n  `;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/handlers/waiting.ts","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":129,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":129,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":130,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":130,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3451,3467],"text":"action.selector == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3452,3467],"text":"(action.selector ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3451,3467],"text":"!Boolean(action.selector)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-return-await","severity":2,"message":"Redundant use of `await` on a return value.","line":136,"column":10,"nodeType":"Identifier","messageId":"redundantUseOfAwait","endLine":139,"endColumn":5,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3616,3622],"text":""},"desc":"Remove redundant `await`."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":137,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":137,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3677,3691],"text":"(action.timeout != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3677,3691],"text":"(action.timeout ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3677,3691],"text":"(Boolean(action.timeout))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":137,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":137,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[3692,3694],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":148,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":148,"endColumn":39},{"ruleId":"no-return-await","severity":2,"message":"Redundant use of `await` on a return value.","line":149,"column":10,"nodeType":"Identifier","messageId":"redundantUseOfAwait","endLine":152,"endColumn":5,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3954,3960],"text":""},"desc":"Remove redundant `await`."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":150,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":150,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3998,4012],"text":"(action.timeout != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3998,4012],"text":"(action.timeout ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3998,4012],"text":"(Boolean(action.timeout))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":150,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":150,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[4013,4015],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":161,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":161,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4248,4264],"text":"action.duration == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[4249,4264],"text":"(action.duration ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4248,4264],"text":"!Boolean(action.duration)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":169,"column":32,"nodeType":"CallExpression","messageId":"returnsValue","endLine":169,"endColumn":68,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[4481,4517],"text":"{setTimeout(resolve, action.duration)}"},"desc":"Wrap the expression in `{}`."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":178,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":178,"endColumn":37},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":179,"column":8,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":179,"endColumn":23,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4736,4752],"text":"action.function == null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4737,4752],"text":"(action.function ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4736,4752],"text":"!Boolean(action.function)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"no-return-await","severity":2,"message":"Redundant use of `await` on a return value.","line":189,"column":10,"nodeType":"Identifier","messageId":"redundantUseOfAwait","endLine":192,"endColumn":5,"suggestions":[{"messageId":"removeAwait","fix":{"range":[5026,5032],"text":""},"desc":"Remove redundant `await`."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":190,"column":14,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":190,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[5082,5096],"text":"(action.timeout != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[5082,5096],"text":"(action.timeout ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[5082,5096],"text":"(Boolean(action.timeout))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":190,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":190,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[5097,5099],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Waiting action handlers for browser automation\n * @module puppeteer/actions/handlers/waiting\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { \n  WaitAction,\n  ActionResult, \n  ActionContext \n} from '../../interfaces/action-executor.interface.js';\nimport { sanitizeSelector, validateJavaScriptCode } from '../validation.js';\nimport { createLogger } from '../../../utils/logger.js';\nimport { createSafeWaitFunction } from './waiting-states.js';\n\nconst logger = createLogger('puppeteer:waiting');\n\n// Re-export state-based waiting handlers\nexport { handleWaitForLoadState, handleWaitForElementState } from './waiting-states.js';\n\n/**\n * Handle wait action\n * @param action - Wait action\n * @param page - Puppeteer page instance\n * @param context - Action execution context\n * @returns Action result\n * @nist si-10 \"Information input validation\"\n * @nist au-3 \"Content of audit records\"\n */\nexport async function handleWait(\n  action: WaitAction,\n  page: Page,\n  context: ActionContext\n): Promise<ActionResult> {\n  const startTime = Date.now();\n  \n  try {\n    logger.info('Executing wait action', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      waitType: action.waitType,\n      selector: action.selector,\n      duration: action.duration,\n    });\n\n    let result: unknown;\n\n    switch (action.waitType) {\n      case 'selector':\n        result = await handleWaitForSelector(action, page);\n        break;\n      case 'navigation':\n        result = await handleWaitForNavigation(action, page);\n        break;\n      case 'timeout':\n        result = await handleWaitForTimeout(action);\n        break;\n      case 'function':\n        result = await handleWaitForFunction(action, page);\n        break;\n      default:\n        throw new Error(`Unsupported wait type: ${String(action.waitType)}`);\n    }\n\n    const duration = Date.now() - startTime;\n\n    logger.info('Wait action completed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      waitType: action.waitType,\n      duration,\n    });\n\n    return {\n      success: true,\n      actionType: 'wait',\n      data: {\n        waitType: action.waitType,\n        result,\n        actualDuration: duration,\n      },\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        selector: action.selector,\n        requestedDuration: action.duration,\n        function: action.function,\n      },\n    };\n\n  } catch (error) {\n    const duration = Date.now() - startTime;\n    const errorMessage = error instanceof Error ? error.message : 'Unknown wait error';\n\n    logger.error('Wait action failed', {\n      sessionId: context.sessionId,\n      contextId: context.contextId,\n      pageId: action.pageId,\n      waitType: action.waitType,\n      error: errorMessage,\n      duration,\n    });\n\n    return {\n      success: false,\n      actionType: 'wait',\n      error: errorMessage,\n      duration,\n      timestamp: new Date(),\n      metadata: {\n        waitType: action.waitType,\n        selector: action.selector,\n        requestedDuration: action.duration,\n      },\n    };\n  }\n}\n\n/**\n * Handle wait for selector\n * @param action - Wait action\n * @param page - Puppeteer page instance\n * @returns Element handle or null\n */\nasync function handleWaitForSelector(action: WaitAction, page: Page) {\n  if (!action.selector) {\n    throw new Error('Selector is required for waitForSelector');\n  }\n\n  const sanitizedSelector = sanitizeSelector(action.selector);\n  \n  return await page.waitForSelector(sanitizedSelector, {\n    timeout: action.timeout || 30000,\n    visible: true,\n  });\n}\n\n/**\n * Handle wait for navigation\n * @param action - Wait action\n * @param page - Puppeteer page instance\n * @returns Navigation response\n */\nasync function handleWaitForNavigation(action: WaitAction, page: Page) {\n  return await page.waitForNavigation({\n    timeout: action.timeout || 30000,\n    waitUntil: 'load',\n  });\n}\n\n/**\n * Handle wait for timeout\n * @param action - Wait action\n * @returns Promise that resolves after timeout\n */\nasync function handleWaitForTimeout(action: WaitAction): Promise<void> {\n  if (!action.duration) {\n    throw new Error('Duration is required for waitForTimeout');\n  }\n\n  if (action.duration > 300000) { // 5 minutes max\n    throw new Error('Duration cannot exceed 5 minutes');\n  }\n\n  await new Promise(resolve => setTimeout(resolve, action.duration));\n}\n\n/**\n * Handle wait for function\n * @param action - Wait action\n * @param page - Puppeteer page instance\n * @returns Function result\n */\nasync function handleWaitForFunction(action: WaitAction, page: Page) {\n  if (!action.function) {\n    throw new Error('Function is required for waitForFunction');\n  }\n\n  // Validate JavaScript code for security\n  validateJavaScriptCode(action.function);\n\n  // Create a safe evaluation function\n  const safeFunction = createSafeWaitFunction(action.function);\n\n  return await page.waitForFunction(safeFunction, {\n    timeout: action.timeout || 30000,\n    polling: 'mutation', // Poll on DOM mutations\n  });\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/history-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/sanitization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/security-validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/validation-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/actions/validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/config.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":113,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":113,"endColumn":28,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3417,3438],"text":"config.PUPPETEER_ARGS != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3417,3438],"text":"config.PUPPETEER_ARGS ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3417,3438],"text":"Boolean(config.PUPPETEER_ARGS)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":139,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":139,"endColumn":39,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4048,4080],"text":"config.PUPPETEER_EXECUTABLE_PATH != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4048,4080],"text":"config.PUPPETEER_EXECUTABLE_PATH ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4048,4080],"text":"Boolean(config.PUPPETEER_EXECUTABLE_PATH)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":157,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":157,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[4447,4477],"text":"config.PUPPETEER_DOWNLOAD_PATH != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[4447,4477],"text":"config.PUPPETEER_DOWNLOAD_PATH ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[4447,4477],"text":"Boolean(config.PUPPETEER_DOWNLOAD_PATH)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":234,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":234,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Puppeteer configuration module\n * @module puppeteer/config\n * @nist ac-4 \"Information flow enforcement\"\n * @nist sc-5 \"Denial of service protection\"\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n */\n\nimport { z } from 'zod';\nimport type { LaunchOptions } from 'puppeteer';\nimport { config } from '../core/config.js';\nimport path from 'path';\nimport os from 'os';\n\n/**\n * Puppeteer configuration schema\n * @nist cm-7 \"Least functionality\"\n */\nexport const puppeteerConfigSchema = z.object({\n  executablePath: z.string().optional(),\n  headless: z.boolean().default(true),\n  args: z.array(z.string()).default([]),\n  poolMaxSize: z.number().int().positive().default(5),\n  idleTimeout: z.number().int().positive().default(300000), // 5 minutes\n  downloadPath: z.string().optional(),\n  cacheEnabled: z.boolean().default(true),\n  defaultViewport: z.object({\n    width: z.number().int().positive().default(1280),\n    height: z.number().int().positive().default(720),\n    deviceScaleFactor: z.number().positive().default(1),\n    isMobile: z.boolean().default(false),\n    hasTouch: z.boolean().default(false),\n  }).default({}),\n  timeout: z.number().int().positive().default(30000), // 30 seconds\n});\n\nexport type PuppeteerConfig = z.infer<typeof puppeteerConfigSchema>;\n\n/**\n * Security-focused browser arguments\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n * @nist ac-6 \"Least privilege\"\n */\nconst SECURITY_BROWSER_ARGS = [\n  '--no-sandbox', // Required in Docker/containerized environments\n  '--disable-setuid-sandbox',\n  '--disable-dev-shm-usage', // Overcome limited resource problems\n  '--disable-accelerated-2d-canvas',\n  '--disable-gpu',\n  '--no-first-run',\n  '--no-zygote',\n  '--disable-web-security', // Note: Only for trusted content\n  '--disable-features=IsolateOrigins,site-per-process',\n  '--disable-blink-features=AutomationControlled',\n];\n\n/**\n * Performance-focused browser arguments\n * @nist sc-5 \"Denial of service protection\"\n */\nconst PERFORMANCE_BROWSER_ARGS = [\n  '--memory-pressure-off',\n  '--max-old-space-size=4096',\n  '--disable-background-timer-throttling',\n  '--disable-renderer-backgrounding',\n  '--disable-backgrounding-occluded-windows',\n];\n\n/**\n * Privacy-focused browser arguments\n * @nist ia-7 \"Cryptographic module authentication\"\n */\nconst PRIVACY_BROWSER_ARGS = [\n  '--disable-features=TranslateUI',\n  '--disable-features=BlinkGenPropertyTrees',\n  '--disable-ipc-flooding-protection',\n  '--disable-default-apps',\n  '--disable-sync',\n  '--disable-background-networking',\n  '--disable-breakpad',\n  '--disable-client-side-phishing-detection',\n  '--disable-component-update',\n  '--disable-domain-reliability',\n  '--disable-features=AudioServiceOutOfProcess',\n  '--disable-hang-monitor',\n  '--disable-offer-store-unmasked-wallet-cards',\n  '--disable-popup-blocking',\n  '--disable-print-preview',\n  '--disable-prompt-on-repost',\n  '--disable-speech-api',\n  '--disable-sync',\n  '--hide-scrollbars',\n  '--metrics-recording-only',\n  '--mute-audio',\n  '--no-default-browser-check',\n  '--no-pings',\n  '--password-store=basic',\n  '--use-mock-keychain',\n];\n\n/**\n * Get default browser launch options\n * @nist cm-6 \"Configuration settings\"\n */\nexport function getDefaultLaunchOptions(): LaunchOptions {\n  const args = [\n    ...SECURITY_BROWSER_ARGS,\n    ...PERFORMANCE_BROWSER_ARGS,\n    ...PRIVACY_BROWSER_ARGS,\n  ];\n\n  // Parse additional args from environment\n  if (config.PUPPETEER_ARGS) {\n    const additionalArgs = config.PUPPETEER_ARGS.split(',').map(arg => arg.trim());\n    args.push(...additionalArgs);\n  }\n\n  return {\n    headless: config.PUPPETEER_HEADLESS,\n    executablePath: config.PUPPETEER_EXECUTABLE_PATH,\n    args,\n    defaultViewport: {\n      width: 1280,\n      height: 720,\n      deviceScaleFactor: 1,\n      isMobile: false,\n      hasTouch: false,\n    },\n    ignoreDefaultArgs: false,\n    timeout: 30000,\n  };\n}\n\n/**\n * Get browser executable path based on environment\n * @nist cm-7 \"Least functionality\"\n */\nexport function getBrowserExecutablePath(): string | undefined {\n  if (config.PUPPETEER_EXECUTABLE_PATH) {\n    return config.PUPPETEER_EXECUTABLE_PATH;\n  }\n\n  // Check if running in Docker\n  if (process.env.RUNNING_IN_DOCKER === 'true') {\n    return '/usr/bin/chromium-browser';\n  }\n\n  // Let Puppeteer find the browser\n  return undefined;\n}\n\n/**\n * Get cache directory path\n * @nist cm-6 \"Configuration settings\"\n */\nexport function getCacheDirectory(): string {\n  if (config.PUPPETEER_DOWNLOAD_PATH) {\n    return config.PUPPETEER_DOWNLOAD_PATH;\n  }\n\n  return path.join(os.homedir(), '.cache', 'puppeteer');\n}\n\n/**\n * Get environment-specific browser configuration\n * @nist cm-7 \"Least functionality\"\n * @nist sc-5 \"Denial of service protection\"\n */\nexport function getEnvironmentConfig(): Partial<LaunchOptions> {\n  const env = config.NODE_ENV;\n\n  switch (env) {\n    case 'production':\n      return {\n        headless: true,\n        args: [\n          ...SECURITY_BROWSER_ARGS,\n          ...PERFORMANCE_BROWSER_ARGS,\n          ...PRIVACY_BROWSER_ARGS,\n          '--disable-software-rasterizer',\n          '--disable-extensions',\n        ],\n        handleSIGINT: false,\n        handleSIGTERM: false,\n        handleSIGHUP: false,\n      };\n\n    case 'test':\n      return {\n        headless: true,\n        args: [\n          ...SECURITY_BROWSER_ARGS,\n          '--disable-extensions',\n          '--disable-default-apps',\n        ],\n        handleSIGINT: false,\n        handleSIGTERM: false,\n        handleSIGHUP: false,\n      };\n\n    case 'development':\n    default:\n      return {\n        headless: config.PUPPETEER_HEADLESS,\n        devtools: true,\n        args: SECURITY_BROWSER_ARGS,\n      };\n  }\n}\n\n/**\n * Validate browser pool configuration\n * @nist sc-5 \"Denial of service protection\"\n */\nexport function validatePoolConfig(poolSize: number, idleTimeout: number): void {\n  if (poolSize > 20) {\n    throw new Error('Browser pool size cannot exceed 20 to prevent resource exhaustion');\n  }\n\n  if (idleTimeout < 60000) { // 1 minute\n    throw new Error('Browser idle timeout must be at least 1 minute');\n  }\n\n  if (idleTimeout > 3600000) { // 1 hour\n    throw new Error('Browser idle timeout cannot exceed 1 hour');\n  }\n}\n\n/**\n * Get secure browser context options\n * @nist ac-4 \"Information flow enforcement\"\n * @nist sc-8 \"Transmission confidentiality and integrity\"\n */\nexport function getSecureContextOptions() {\n  return {\n    // Disable all permissions by default\n    permissions: [],\n    // Block all cookies\n    acceptInsecureCerts: false,\n    // Disable service workers\n    serviceWorkers: 'block',\n    // Clear cookies on context close\n    recordVideo: undefined,\n    // Disable geolocation\n    geolocation: undefined,\n    // Set secure user agent\n    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n    // Disable JavaScript if not needed\n    javaScriptEnabled: true, // Can be toggled based on use case\n    // Block images to save bandwidth\n    loadImages: false,\n    // Set strict cookie policy\n    cookiePolicy: 'strict',\n    // Disable webgl\n    webgl: false,\n    // Disable web audio\n    webaudio: false,\n  };\n}\n\n/**\n * Export parsed configuration\n */\nexport const puppeteerConfig: PuppeteerConfig = {\n  executablePath: config.PUPPETEER_EXECUTABLE_PATH,\n  headless: config.PUPPETEER_HEADLESS,\n  args: config.PUPPETEER_ARGS?.split(',').map(arg => arg.trim()) ?? [],\n  poolMaxSize: config.BROWSER_POOL_MAX_SIZE,\n  idleTimeout: config.BROWSER_IDLE_TIMEOUT,\n  downloadPath: config.PUPPETEER_DOWNLOAD_PATH,\n  cacheEnabled: config.PUPPETEER_CACHE_ENABLED,\n  defaultViewport: {\n    width: 1280,\n    height: 720,\n    deviceScaleFactor: 1,\n    isMobile: false,\n    hasTouch: false,\n  },\n  timeout: 30000,\n};\n\n// Validate configuration on module load\nvalidatePoolConfig(puppeteerConfig.poolMaxSize, puppeteerConfig.idleTimeout);","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/interfaces/action-executor.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/interfaces/browser-events.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/interfaces/browser-pool.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/interfaces/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/interfaces/page-manager.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-access-control.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1502,1505],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1502,1505],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page access control functions\n * @module puppeteer/pages/page-access-control\n * @nist ac-3 \"Access enforcement\"\n */\n\nimport type { Page } from 'puppeteer';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { logSecurityEvent, SecurityEventType } from '../../utils/logger.js';\nimport type { PageInfoStore } from './page-info-store.js';\n\n/**\n * Get page by ID with access control\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function getPageWithAccessControl(\n  pageId: string,\n  sessionId: string,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<Page> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo) {\n    throw new AppError('Page not found', 404);\n  }\n\n  if (pageInfo.sessionId !== sessionId) {\n    await logSecurityEvent(SecurityEventType.ACCESS_DENIED, {\n      userId: sessionId,\n      resource: `page:${pageId}`,\n      result: 'failure',\n      reason: 'Page does not belong to session',\n    });\n    throw new AppError('Unauthorized access to page', 403);\n  }\n\n  const page = pages.get(pageId);\n  if (!page || page.isClosed()) {\n    await pageStore.delete(pageId);\n    pages.delete(pageId);\n    throw new AppError('Page is closed', 410);\n  }\n\n  // Update activity\n  await pageStore.touchActivity(pageId);\n\n  return page;\n}\n\n/**\n * Get page info with access control\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function getPageInfoWithAccessControl(\n  pageId: string,\n  sessionId: string,\n  pageStore: PageInfoStore\n): Promise<any> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo) {\n    throw new AppError('Page not found', 404);\n  }\n\n  if (pageInfo.sessionId !== sessionId) {\n    await logSecurityEvent(SecurityEventType.ACCESS_DENIED, {\n      userId: sessionId,\n      resource: `page:${pageId}`,\n      result: 'failure',\n      reason: 'Page does not belong to session',\n    });\n    throw new AppError('Unauthorized access to page', 403);\n  }\n\n  return pageInfo;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-cleanup-methods.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-cleanup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-close-operations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-close-types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-configuration.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":29,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":29,"endColumn":24,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[749,766],"text":"options.userAgent != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[749,766],"text":"options.userAgent ?? \"\""},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[749,766],"text":"Boolean(options.userAgent)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page Configuration Utilities\n * @module puppeteer/pages/page-configuration\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\n\nimport type { Page, Viewport, Cookie } from 'puppeteer';\nimport { createLogger } from '../../utils/logger.js';\nimport type { PageOptions } from '../interfaces/page-manager.interface.js';\n\nconst logger = createLogger('page-configuration');\n\n/**\n * Configure page options\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport async function configurePageOptions(\n  page: Page,\n  options: PageOptions\n): Promise<void> {\n  // Set viewport\n  if (options.viewport) {\n    await configureViewport(page, options.viewport);\n  }\n\n  // Set user agent\n  if (options.userAgent) {\n    await page.setUserAgent(options.userAgent);\n  }\n\n  // Set extra HTTP headers\n  if (options.extraHeaders) {\n    await page.setExtraHTTPHeaders(options.extraHeaders);\n  }\n\n  // Set JavaScript enabled/disabled\n  if (options.javaScriptEnabled !== undefined) {\n    await page.setJavaScriptEnabled(options.javaScriptEnabled);\n  }\n\n  // Set offline mode\n  if (options.offline !== undefined) {\n    await page.setOfflineMode(options.offline);\n  }\n\n  // Set cookies\n  if (options.cookies && options.cookies.length > 0) {\n    await setCookies(page, options.cookies);\n  }\n\n  // Set cache enabled/disabled\n  if (options.cacheEnabled !== undefined) {\n    await page.setCacheEnabled(options.cacheEnabled);\n  }\n}\n\n/**\n * Configure viewport settings\n */\nasync function configureViewport(page: Page, viewport: Viewport): Promise<void> {\n  await page.setViewport({\n    width: Math.max(1, Math.min(viewport.width, 10000)),\n    height: Math.max(1, Math.min(viewport.height, 10000)),\n    deviceScaleFactor: viewport.deviceScaleFactor ?? 1,\n    isMobile: viewport.isMobile ?? false,\n    hasTouch: viewport.hasTouch ?? false,\n    isLandscape: viewport.isLandscape ?? false,\n  });\n}\n\n/**\n * Set cookies with validation\n */\nasync function setCookies(page: Page, cookies: Cookie[]): Promise<void> {\n  const validCookies = cookies.filter(cookie => {\n    if (!cookie.name || !cookie.value) {\n      logger.warn({ cookie }, 'Invalid cookie - missing name or value');\n      return false;\n    }\n    return true;\n  });\n\n  if (validCookies.length > 0) {\n    await page.setCookie(...validCookies);\n  }\n}\n\n","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-create-operations.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'createAndConfigurePage' has too many parameters (8). Maximum allowed is 4.","line":74,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":74,"endColumn":45}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page creation operations\n * @module puppeteer/pages/page-create-operations\n * @nist ac-2 \"Account management\"\n * @nist ac-3 \"Access enforcement\"\n */\n\nimport type { Page } from 'puppeteer';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { logSecurityEvent, SecurityEventType, createLogger } from '../../utils/logger.js';\nimport { contextStore } from '../../store/context-store.js';\nimport type { BrowserPool } from '../interfaces/browser-pool.interface.js';\nimport type {\n  PageInfo,\n  PageOptions,\n} from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\nimport { configurePageOptions } from './page-configuration.js';\nimport { configurePageEventHandlers } from './page-event-handler.js';\nimport type { EventEmitter } from 'events';\n\nconst logger = createLogger('page-create-operations');\n\n/**\n * Create page creation info\n */\nexport function createPageInfo(\n  pageId: string,\n  contextId: string,\n  sessionId: string,\n  browserId: string\n): PageInfo {\n  return {\n    id: pageId,\n    contextId,\n    sessionId,\n    browserId,\n    url: 'about:blank',\n    title: '',\n    state: 'active',\n    createdAt: new Date(),\n    lastActivityAt: new Date(),\n    navigationHistory: [],\n    errorCount: 0,\n  };\n}\n\n/**\n * Verify context access\n */\nexport async function verifyContextAccess(\n  contextId: string,\n  sessionId: string\n): Promise<void> {\n  const context = await contextStore.get(contextId);\n  if (!context) {\n    throw new AppError('Context not found', 404);\n  }\n\n  if (context.sessionId !== sessionId) {\n    await logSecurityEvent(SecurityEventType.ACCESS_DENIED, {\n      userId: sessionId,\n      resource: `context:${contextId}`,\n      result: 'failure',\n      reason: 'Context does not belong to session',\n    });\n    throw new AppError('Unauthorized access to context', 403);\n  }\n}\n\n/**\n * Create and configure page\n */\nexport async function createAndConfigurePage(\n  browserPool: BrowserPool,\n  browserId: string,\n  pageId: string,\n  pageInfo: PageInfo,\n  options: PageOptions | undefined,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore,\n  emitter: EventEmitter\n): Promise<PageInfo> {\n  // Get browser instance from pool\n  const browserInstance = browserPool.getBrowser(browserId);\n  if (!browserInstance) {\n    throw new AppError('Browser not found', 404);\n  }\n\n  // Create new page\n  const page = await browserInstance.browser.newPage();\n\n  // Configure page options\n  if (options) {\n    await configurePageOptions(page, options);\n  }\n\n  // Store page\n  pages.set(pageId, page);\n  await pageStore.create(pageInfo);\n\n  // Set up event listeners\n  configurePageEventHandlers(page, pageId, emitter);\n\n  logger.info({\n    pageId,\n    contextId: pageInfo.contextId,\n    sessionId: pageInfo.sessionId,\n    browserId,\n  }, 'Page created successfully');\n\n  return pageInfo;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-delegate-methods.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Method 'updatePageOptions' has too many parameters (5). Maximum allowed is 4.","line":41,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":41,"endColumn":22}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page Manager Delegate Method Implementations\n * @module puppeteer/pages/page-delegate-methods\n * @nist ac-3 \"Access enforcement\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type {\n  PageOptions,\n} from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\nimport {\n  getPageWithAccessControl,\n  getPageInfoWithAccessControl\n} from './page-access-control.js';\nimport {\n  navigatePage as navigatePageImpl,\n  updatePageOptions as updatePageOptionsImpl,\n} from './page-navigation.js';\nimport {\n  getPageMetrics as getPageMetricsImpl,\n  setCookies as setCookiesImpl,\n  getCookies as getCookiesImpl,\n  clearPageData as clearPageDataImpl,\n  takeScreenshot as takeScreenshotImpl,\n  isPageActive as isPageActiveImpl,\n} from './page-operations.js';\nimport {\n  listPagesForSession as listPagesForSessionImpl,\n  listPagesForContext as listPagesForContextImpl,\n} from './page-list-operations.js';\nimport { configurePageOptions } from './page-configuration.js';\n\n/**\n * Delegate methods object containing all delegated method implementations\n */\nexport const delegateMethods = {\n  getPage: getPageWithAccessControl,\n  getPageInfo: getPageInfoWithAccessControl,\n  navigatePage: navigatePageImpl,\n  updatePageOptions: (\n    pageId: string,\n    options: Partial<PageOptions>,\n    sessionId: string,\n    pages: Map<string, Page>,\n    pageStore: PageInfoStore\n  ) => updatePageOptionsImpl(pageId, options, sessionId, pages, pageStore, configurePageOptions),\n  takeScreenshot: takeScreenshotImpl,\n  listPagesForSession: listPagesForSessionImpl,\n  listPagesForContext: listPagesForContextImpl,\n  getPageMetrics: getPageMetricsImpl,\n  setCookies: setCookiesImpl,\n  getCookies: getCookiesImpl,\n  clearPageData: clearPageDataImpl,\n  isPageActive: isPageActiveImpl,\n};","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-event-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-info-store.ts","messages":[{"ruleId":"require-await","severity":2,"message":"Async method 'get' has no 'await' expression.","line":87,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":87,"endColumn":12},{"ruleId":"require-await","severity":2,"message":"Async method 'listByContext' has no 'await' expression.","line":161,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":161,"endColumn":22},{"ruleId":"require-await","severity":2,"message":"Async method 'listBySession' has no 'await' expression.","line":172,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":172,"endColumn":22},{"ruleId":"require-await","severity":2,"message":"Async method 'listByBrowser' has no 'await' expression.","line":183,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":183,"endColumn":22},{"ruleId":"require-await","severity":2,"message":"Async method 'touchActivity' has no 'await' expression.","line":194,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":194,"endColumn":22},{"ruleId":"require-await","severity":2,"message":"Async method 'updateState' has no 'await' expression.","line":205,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":205,"endColumn":20},{"ruleId":"require-await","severity":2,"message":"Async method 'updateUrl' has no 'await' expression.","line":217,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":217,"endColumn":18},{"ruleId":"require-await","severity":2,"message":"Async method 'updateTitle' has no 'await' expression.","line":229,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":229,"endColumn":20},{"ruleId":"require-await","severity":2,"message":"Async method 'addNavigationHistory' has no 'await' expression.","line":241,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":241,"endColumn":29},{"ruleId":"require-await","severity":2,"message":"Async method 'incrementErrorCount' has no 'await' expression.","line":258,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":258,"endColumn":28},{"ruleId":"require-await","severity":2,"message":"Async method 'listAll' has no 'await' expression.","line":270,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":270,"endColumn":16},{"ruleId":"require-await","severity":2,"message":"Async method 'clear' has no 'await' expression.","line":278,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":278,"endColumn":14}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_id' is assigned a value but never used.","line":103,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createdAt' is assigned a value but never used.","line":103,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'listByContext' has no 'await' expression.","line":161,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":161,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'listBySession' has no 'await' expression.","line":172,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":172,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'listByBrowser' has no 'await' expression.","line":183,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":183,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'touchActivity' has no 'await' expression.","line":194,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":194,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'updateState' has no 'await' expression.","line":205,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":205,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'updateUrl' has no 'await' expression.","line":217,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":217,"endColumn":18,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'updateTitle' has no 'await' expression.","line":229,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":229,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'addNavigationHistory' has no 'await' expression.","line":241,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":241,"endColumn":29,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'incrementErrorCount' has no 'await' expression.","line":258,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":258,"endColumn":28,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'listAll' has no 'await' expression.","line":270,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":270,"endColumn":16,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'clear' has no 'await' expression.","line":278,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":278,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page Information Store for Puppeteer Integration\n * @module puppeteer/pages/page-info-store\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n * @nist sc-2 \"Application partitioning\"\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { logSecurityEvent, SecurityEventType } from '../../utils/logger.js';\nimport type { PageInfo } from '../interfaces/page-manager.interface.js';\n\n/**\n * Page info store interface\n */\nexport interface PageInfoStore {\n  create(pageInfo: Omit<PageInfo, 'id' | 'createdAt' | 'lastActivityAt'>): Promise<PageInfo>;\n  get(pageId: string): Promise<PageInfo | undefined>;\n  update(pageId: string, updates: Partial<PageInfo>): Promise<PageInfo>;\n  delete(pageId: string): Promise<boolean>;\n  listByContext(contextId: string): Promise<PageInfo[]>;\n  listBySession(sessionId: string): Promise<PageInfo[]>;\n  listByBrowser(browserId: string): Promise<PageInfo[]>;\n  listAll(): Promise<PageInfo[]>;\n  touchActivity(pageId: string): Promise<void>;\n  updateState(pageId: string, state: PageInfo['state']): Promise<void>;\n  updateUrl(pageId: string, url: string): Promise<void>;\n  updateTitle(pageId: string, title: string): Promise<void>;\n  addNavigationHistory(pageId: string, url: string): Promise<void>;\n  incrementErrorCount(pageId: string): Promise<void>;\n  clear(): Promise<void>;\n  cleanup(predicate: (pageInfo: PageInfo) => boolean): Promise<number>;\n}\n\n// Note: These interfaces can be used in the future if needed for more complex mapping logic\n\n/**\n * In-memory page information store implementation\n * @nist ac-3 \"Access enforcement\"\n * @nist sc-2 \"Application partitioning\"\n */\nexport class InMemoryPageInfoStore implements PageInfoStore {\n  private pages: Map<string, PageInfo> = new Map();\n  private contextToPages: Map<string, Set<string>> = new Map();\n  private sessionToPages: Map<string, Set<string>> = new Map();\n  private browserToPages: Map<string, Set<string>> = new Map();\n\n  /**\n   * Create a new page info record\n   * @nist au-3 \"Content of audit records\"\n   */\n  async create(pageData: Omit<PageInfo, 'id' | 'createdAt' | 'lastActivityAt'>): Promise<PageInfo> {\n    const pageInfo: PageInfo = {\n      ...pageData,\n      id: uuidv4(),\n      createdAt: new Date(),\n      lastActivityAt: new Date(),\n    };\n\n    this.pages.set(pageInfo.id, pageInfo);\n\n    // Update mappings\n    this.addToMapping(this.contextToPages, pageInfo.contextId, pageInfo.id);\n    this.addToMapping(this.sessionToPages, pageInfo.sessionId, pageInfo.id);\n    this.addToMapping(this.browserToPages, pageInfo.browserId, pageInfo.id);\n\n    await logSecurityEvent(SecurityEventType.RESOURCE_CREATED, {\n      resource: `page:${pageInfo.id}`,\n      action: 'create',\n      result: 'success',\n      metadata: {\n        contextId: pageInfo.contextId,\n        sessionId: pageInfo.sessionId,\n        browserId: pageInfo.browserId,\n        url: pageInfo.url,\n      },\n    });\n\n    return pageInfo;\n  }\n\n  /**\n   * Get page info by ID\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async get(pageId: string): Promise<PageInfo | undefined> {\n    return Promise.resolve(this.pages.get(pageId));\n  }\n\n  /**\n   * Update page info\n   * @nist au-3 \"Content of audit records\"\n   */\n  async update(pageId: string, updates: Partial<PageInfo>): Promise<PageInfo> {\n    const pageInfo = this.pages.get(pageId);\n    if (!pageInfo) {\n      throw new AppError('Page not found', 404);\n    }\n\n    // Don't allow updating certain fields\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { id: _id, createdAt, ...allowedUpdates } = updates;\n\n    const updatedPageInfo = {\n      ...pageInfo,\n      ...allowedUpdates,\n      // Only update lastActivityAt if not explicitly provided in updates\n      lastActivityAt: allowedUpdates.lastActivityAt ?? new Date(),\n    };\n\n    this.pages.set(pageId, updatedPageInfo);\n\n    await logSecurityEvent(SecurityEventType.RESOURCE_UPDATED, {\n      resource: `page:${pageId}`,\n      action: 'update',\n      result: 'success',\n      metadata: {\n        updatedFields: Object.keys(allowedUpdates),\n        contextId: pageInfo.contextId,\n      },\n    });\n\n    return updatedPageInfo;\n  }\n\n  /**\n   * Delete page info\n   * @nist au-3 \"Content of audit records\"\n   */\n  async delete(pageId: string): Promise<boolean> {\n    const pageInfo = this.pages.get(pageId);\n    if (!pageInfo) {\n      return false;\n    }\n\n    this.pages.delete(pageId);\n\n    // Update mappings\n    this.removeFromMapping(this.contextToPages, pageInfo.contextId, pageId);\n    this.removeFromMapping(this.sessionToPages, pageInfo.sessionId, pageId);\n    this.removeFromMapping(this.browserToPages, pageInfo.browserId, pageId);\n\n    await logSecurityEvent(SecurityEventType.RESOURCE_DELETED, {\n      resource: `page:${pageId}`,\n      action: 'delete',\n      result: 'success',\n      metadata: {\n        contextId: pageInfo.contextId,\n        sessionId: pageInfo.sessionId,\n      },\n    });\n\n    return true;\n  }\n\n  /**\n   * List pages by context ID\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async listByContext(contextId: string): Promise<PageInfo[]> {\n    const pageIds = this.contextToPages.get(contextId) ?? new Set();\n    return Array.from(pageIds)\n      .map((id) => this.pages.get(id))\n      .filter((page): page is PageInfo => page !== undefined);\n  }\n\n  /**\n   * List pages by session ID\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async listBySession(sessionId: string): Promise<PageInfo[]> {\n    const pageIds = this.sessionToPages.get(sessionId) ?? new Set();\n    return Array.from(pageIds)\n      .map((id) => this.pages.get(id))\n      .filter((page): page is PageInfo => page !== undefined);\n  }\n\n  /**\n   * List pages by browser ID\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async listByBrowser(browserId: string): Promise<PageInfo[]> {\n    const pageIds = this.browserToPages.get(browserId) ?? new Set();\n    return Array.from(pageIds)\n      .map((id) => this.pages.get(id))\n      .filter((page): page is PageInfo => page !== undefined);\n  }\n\n  /**\n   * Update page activity timestamp\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async touchActivity(pageId: string): Promise<void> {\n    const pageInfo = this.pages.get(pageId);\n    if (pageInfo) {\n      pageInfo.lastActivityAt = new Date();\n    }\n  }\n\n  /**\n   * Update page state\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async updateState(pageId: string, state: PageInfo['state']): Promise<void> {\n    const pageInfo = this.pages.get(pageId);\n    if (pageInfo) {\n      pageInfo.state = state;\n      pageInfo.lastActivityAt = new Date();\n    }\n  }\n\n  /**\n   * Update page URL\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async updateUrl(pageId: string, url: string): Promise<void> {\n    const pageInfo = this.pages.get(pageId);\n    if (pageInfo) {\n      pageInfo.url = url;\n      pageInfo.lastActivityAt = new Date();\n    }\n  }\n\n  /**\n   * Update page title\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async updateTitle(pageId: string, title: string): Promise<void> {\n    const pageInfo = this.pages.get(pageId);\n    if (pageInfo) {\n      pageInfo.title = title;\n      pageInfo.lastActivityAt = new Date();\n    }\n  }\n\n  /**\n   * Add URL to navigation history\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async addNavigationHistory(pageId: string, url: string): Promise<void> {\n    const pageInfo = this.pages.get(pageId);\n    if (pageInfo) {\n      pageInfo.navigationHistory.push(url);\n      pageInfo.lastActivityAt = new Date();\n      \n      // Keep only last 50 entries to prevent memory bloat\n      if (pageInfo.navigationHistory.length > 50) {\n        pageInfo.navigationHistory = pageInfo.navigationHistory.slice(-50);\n      }\n    }\n  }\n\n  /**\n   * Increment error count\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async incrementErrorCount(pageId: string): Promise<void> {\n    const pageInfo = this.pages.get(pageId);\n    if (pageInfo) {\n      pageInfo.errorCount++;\n      pageInfo.lastActivityAt = new Date();\n    }\n  }\n\n  /**\n   * List all pages\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async listAll(): Promise<PageInfo[]> {\n    return Array.from(this.pages.values());\n  }\n\n  /**\n   * Clear all page info\n   */\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async clear(): Promise<void> {\n    this.pages.clear();\n    this.contextToPages.clear();\n    this.sessionToPages.clear();\n    this.browserToPages.clear();\n  }\n\n  /**\n   * Cleanup pages matching predicate\n   */\n  async cleanup(predicate: (pageInfo: PageInfo) => boolean): Promise<number> {\n    let cleaned = 0;\n    \n    for (const [pageId, pageInfo] of this.pages) {\n      if (predicate(pageInfo)) {\n        await this.delete(pageId);\n        cleaned++;\n      }\n    }\n    \n    return cleaned;\n  }\n\n  /**\n   * Add page ID to mapping\n   * @private\n   */\n  private addToMapping(mapping: Map<string, Set<string>>, key: string, pageId: string): void {\n    if (!mapping.has(key)) {\n      mapping.set(key, new Set());\n    }\n    const pageSet = mapping.get(key);\n    if (pageSet) {\n      pageSet.add(pageId);\n    }\n  }\n\n  /**\n   * Remove page ID from mapping\n   * @private\n   */\n  private removeFromMapping(mapping: Map<string, Set<string>>, key: string, pageId: string): void {\n    const pageSet = mapping.get(key);\n    if (pageSet) {\n      pageSet.delete(pageId);\n      if (pageSet.size === 0) {\n        mapping.delete(key);\n      }\n    }\n  }\n}\n\n/**\n * Singleton instance of page info store\n */\nexport const pageInfoStore = new InMemoryPageInfoStore();","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-list-operations.ts","messages":[{"ruleId":"require-await","severity":2,"message":"Async function 'listPagesForSession' has no 'await' expression.","line":16,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":16,"endColumn":42}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page list operations\n * @module puppeteer/pages/page-list-operations\n * @nist ac-3 \"Access enforcement\"\n */\n\nimport { AppError } from '../../core/errors/app-error.js';\nimport { contextStore } from '../../store/context-store.js';\nimport type { PageInfo } from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\n\n/**\n * List pages for session\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function listPagesForSession(\n  sessionId: string,\n  pageStore: PageInfoStore\n): Promise<PageInfo[]> {\n  return pageStore.listBySession(sessionId);\n}\n\n/**\n * List pages for context\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function listPagesForContext(\n  contextId: string,\n  sessionId: string,\n  pageStore: PageInfoStore\n): Promise<PageInfo[]> {\n  // Verify context belongs to session\n  const context = await contextStore.get(contextId);\n  if (!context) {\n    throw new AppError('Context not found', 404);\n  }\n\n  if (context.sessionId !== sessionId) {\n    throw new AppError('Unauthorized access to context', 403);\n  }\n\n  return pageStore.listByContext(contextId);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-manager-events.ts","messages":[{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":23,"column":32,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":31,"endColumn":4},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":34,"column":28,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":39,"endColumn":4}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page manager event handling setup\n * @module puppeteer/pages/page-manager-events\n */\n\nimport type { Page } from 'puppeteer';\nimport type { EventEmitter } from 'events';\nimport type { PageInfo } from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\n\n/**\n * Set up page store event handlers\n */\nexport function setupPageStoreHandlers(\n  page: Page,\n  pageInfo: PageInfo,\n  pageStore: PageInfoStore,\n  emitter: EventEmitter\n): void {\n  const pageId = pageInfo.id;\n\n  // Update store on navigation\n  emitter.on('page:navigated', async ({ pageId: navPageId, url }) => {\n    if (navPageId === pageId) {\n      const title = await page.title().catch(() => '');\n      await pageStore.updateUrl(pageId, url);\n      await pageStore.updateTitle(pageId, title);\n      await pageStore.addNavigationHistory(pageId, url);\n      await pageStore.touchActivity(pageId);\n    }\n  });\n\n  // Update error count\n  emitter.on('page:error', async ({ pageId: errorPageId }) => {\n    if (errorPageId === pageId) {\n      await pageStore.incrementErrorCount(pageId);\n      await pageStore.touchActivity(pageId);\n    }\n  });\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-manager-factory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-manager-init.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-manager-lifecycle.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-manager-methods.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'createPageImpl' has too many parameters (9). Maximum allowed is 4.","line":32,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":32,"endColumn":37}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page Manager Method Implementations\n * @module puppeteer/pages/page-manager-methods\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page } from 'puppeteer';\nimport type { EventEmitter } from 'events';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { createLogger } from '../../utils/logger.js';\nimport type { BrowserPool } from '../interfaces/browser-pool.interface.js';\nimport type {\n  PageInfo,\n  PageOptions,\n} from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\nimport {\n  createPageInfo,\n  verifyContextAccess,\n  createAndConfigurePage,\n} from './page-create-operations.js';\nimport { setupPageStoreHandlers } from './page-manager-events.js';\n\nconst logger = createLogger('page-manager-methods');\n\n/**\n * Create page implementation\n * @nist ac-2 \"Account management\"\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function createPageImpl(\n  contextId: string,\n  sessionId: string,\n  browserId: string,\n  options: PageOptions | undefined,\n  browserPool: BrowserPool,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore,\n  emitter: EventEmitter,\n  isShuttingDown: boolean\n): Promise<PageInfo> {\n  if (isShuttingDown) {\n    throw new AppError('Page manager is shutting down', 503);\n  }\n\n  logger.debug({ contextId, sessionId, browserId }, 'Creating new page');\n\n  // Verify context access\n  await verifyContextAccess(contextId, sessionId);\n\n  try {\n    const pageId = `page-${Date.now()}-${Math.random().toString(36).substring(7)}`;\n    const pageInfo = createPageInfo(pageId, contextId, sessionId, browserId);\n    \n    const result = await createAndConfigurePage(\n      browserPool,\n      browserId,\n      pageId,\n      pageInfo,\n      options,\n      pages,\n      pageStore,\n      emitter\n    );\n\n    // Get the actual page from the pages Map\n    const page = pages.get(pageId);\n    if (page) {\n      setupPageStoreHandlers(page, pageInfo, pageStore, emitter);\n    }\n    \n    // Emit creation event\n    emitter.emit('page:created', { pageInfo });\n\n    return result;\n\n  } catch (error) {\n    logger.error({\n      contextId,\n      sessionId,\n      browserId,\n      error,\n    }, 'Failed to create page');\n\n    throw error instanceof AppError \n      ? error \n      : new AppError('Failed to create page', 500, true, error instanceof Error ? { originalError: error.message } : undefined);\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-manager.ts","messages":[{"ruleId":"require-await","severity":2,"message":"Async method 'createPage' has no 'await' expression.","line":93,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":93,"endColumn":19},{"ruleId":"require-await","severity":2,"message":"Async method 'getPage' has no 'await' expression.","line":112,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":112,"endColumn":16},{"ruleId":"require-await","severity":2,"message":"Async method 'getPageInfo' has no 'await' expression.","line":116,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":116,"endColumn":20},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of type `Promise<any>` from function with return type `Promise<PageInfo>`.","line":117,"column":5,"nodeType":"ReturnStatement","messageId":"unsafeReturnAssignment","endLine":117,"endColumn":76},{"ruleId":"require-await","severity":2,"message":"Async method 'navigatePage' has no 'await' expression.","line":120,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":120,"endColumn":21},{"ruleId":"require-await","severity":2,"message":"Async method 'navigateTo' has no 'await' expression.","line":129,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":129,"endColumn":19},{"ruleId":"require-await","severity":2,"message":"Async method 'updatePageOptions' has no 'await' expression.","line":138,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":138,"endColumn":26},{"ruleId":"require-await","severity":2,"message":"Async method 'takeScreenshot' has no 'await' expression.","line":146,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":146,"endColumn":23},{"ruleId":"require-await","severity":2,"message":"Async method 'listPagesForSession' has no 'await' expression.","line":154,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":154,"endColumn":28},{"ruleId":"require-await","severity":2,"message":"Async method 'listPagesForContext' has no 'await' expression.","line":158,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":158,"endColumn":28},{"ruleId":"require-await","severity":2,"message":"Async method 'closePage' has no 'await' expression.","line":162,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":162,"endColumn":18},{"ruleId":"require-await","severity":2,"message":"Async method 'closePagesForContext' has no 'await' expression.","line":173,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":173,"endColumn":29},{"ruleId":"require-await","severity":2,"message":"Async method 'closePagesForSession' has no 'await' expression.","line":182,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":182,"endColumn":29},{"ruleId":"require-await","severity":2,"message":"Async method 'getPageMetrics' has no 'await' expression.","line":195,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":195,"endColumn":23},{"ruleId":"require-await","severity":2,"message":"Async method 'setCookies' has no 'await' expression.","line":199,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":199,"endColumn":19},{"ruleId":"require-await","severity":2,"message":"Async method 'getCookies' has no 'await' expression.","line":203,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":203,"endColumn":19},{"ruleId":"require-await","severity":2,"message":"Async method 'clearPageData' has no 'await' expression.","line":207,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":207,"endColumn":22},{"ruleId":"require-await","severity":2,"message":"Async method 'isPageActive' has no 'await' expression.","line":220,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":220,"endColumn":21},{"ruleId":"require-await","severity":2,"message":"Async method 'cleanupIdlePages' has no 'await' expression.","line":224,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":224,"endColumn":25}],"suppressedMessages":[],"errorCount":19,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page Manager Implementation for Puppeteer Integration\n * @module puppeteer/pages/page-manager\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n * @nist au-3 \"Content of audit records\"\n * @nist sc-2 \"Application partitioning\"\n */\n\nimport type { Page } from 'puppeteer';\nimport { EventEmitter } from 'events';\nimport type { BrowserPool } from '../interfaces/browser-pool.interface.js';\nimport type {\n  PageManager as IPageManager,\n  PageInfo,\n  PageOptions,\n  NavigationOptions,\n  ScreenshotOptions,\n} from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\nimport { configurePageOptions } from './page-configuration.js';\nimport { type PageEvents } from './page-event-handler.js';\nimport {\n  getPageMetrics,\n  setCookies,\n  getCookies,\n  clearPageData,\n  takeScreenshot,\n  isPageActive,\n} from './page-operations.js';\nimport {\n  navigatePage,\n  navigateToWithEvents,\n  updatePageOptions,\n} from './page-navigation.js';\nimport {\n  performCleanup,\n  shutdownPageManager,\n} from './page-manager-lifecycle.js';\nimport { \n  getPageWithAccessControl,\n  getPageInfoWithAccessControl\n} from './page-access-control.js';\nimport {\n  listPagesForSession,\n  listPagesForContext,\n} from './page-list-operations.js';\nimport {\n  closePageOperation,\n  closePagesForContextOperation,\n  closePagesForSessionOperation,\n} from './page-close-operations.js';\nimport { initializePageManager } from './page-manager-init.js';\nimport { createPageImpl } from './page-manager-methods.js';\nimport { cleanupIdlePagesWithLogging } from './page-cleanup-methods.js';\n\n// Type imports only for return types\nimport type { Cookie } from 'puppeteer';\n\n/**\n * Page manager implementation\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport class PageManager extends EventEmitter implements IPageManager {\n  private browserPool: BrowserPool;\n  private pageStore: PageInfoStore;\n  private pages: Map<string, Page> = new Map();\n  private cleanupInterval?: NodeJS.Timeout;\n  private isShuttingDown = false;\n\n  constructor(browserPool: BrowserPool, pageStore?: PageInfoStore) {\n    super();\n    const init = initializePageManager(\n      browserPool,\n      pageStore,\n      this,\n      () => this.performCleanup()\n    );\n    \n    this.browserPool = init.browserPool;\n    this.pageStore = init.pageStore;\n    this.pages = init.pages;\n    this.cleanupInterval = init.cleanupInterval;\n    this.isShuttingDown = init.isShuttingDown;\n  }\n\n  /**\n   * Create a new page for a context\n   * @nist ac-2 \"Account management\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  async createPage(\n    contextId: string,\n    sessionId: string,\n    browserId: string,\n    options?: PageOptions\n  ): Promise<PageInfo> {\n    return createPageImpl(\n      contextId,\n      sessionId,\n      browserId,\n      options,\n      this.browserPool,\n      this.pages,\n      this.pageStore,\n      this,\n      this.isShuttingDown\n    );\n  }\n\n  async getPage(pageId: string, sessionId: string): Promise<Page> {\n    return getPageWithAccessControl(pageId, sessionId, this.pages, this.pageStore);\n  }\n\n  async getPageInfo(pageId: string, sessionId: string): Promise<PageInfo> {\n    return getPageInfoWithAccessControl(pageId, sessionId, this.pageStore);\n  }\n\n  async navigatePage(\n    pageId: string,\n    sessionId: string,\n    url: string,\n    options?: NavigationOptions\n  ): Promise<void> {\n    return navigatePage(pageId, sessionId, url, options, this.pages, this.pageStore);\n  }\n\n  async navigateTo(\n    pageId: string,\n    url: string,\n    sessionId: string,\n    options?: NavigationOptions\n  ): Promise<void> {\n    return navigateToWithEvents(pageId, url, sessionId, options, this.pages, this.pageStore, this);\n  }\n\n  async updatePageOptions(\n    pageId: string,\n    options: Partial<PageOptions>,\n    sessionId: string\n  ): Promise<void> {\n    return updatePageOptions(pageId, options, sessionId, this.pages, this.pageStore, configurePageOptions);\n  }\n\n  async takeScreenshot(\n    pageId: string,\n    sessionId: string,\n    options?: ScreenshotOptions\n  ): Promise<Buffer> {\n    return takeScreenshot(pageId, sessionId, options, this.pages, this.pageStore);\n  }\n\n  async listPagesForSession(sessionId: string): Promise<PageInfo[]> {\n    return listPagesForSession(sessionId, this.pageStore);\n  }\n\n  async listPagesForContext(contextId: string, sessionId: string): Promise<PageInfo[]> {\n    return listPagesForContext(contextId, sessionId, this.pageStore);\n  }\n\n  async closePage(pageId: string, sessionId: string): Promise<void> {\n    return closePageOperation({\n      pageId,\n      sessionId,\n      pages: this.pages,\n      pageStore: this.pageStore,\n      getPageInfo: (pid, sid) => this.getPageInfo(pid, sid),\n      emitter: this\n    });\n  }\n\n  async closePagesForContext(contextId: string): Promise<void> {\n    return closePagesForContextOperation({\n      contextId,\n      pages: this.pages,\n      pageStore: this.pageStore,\n      emitter: this\n    });\n  }\n\n  async closePagesForSession(sessionId: string): Promise<void> {\n    return closePagesForSessionOperation({\n      sessionId,\n      pages: this.pages,\n      pageStore: this.pageStore,\n      emitter: this\n    });\n  }\n\n  private async performCleanup(): Promise<void> {\n    await performCleanup(this.pages, this.pageStore, this.isShuttingDown);\n  }\n\n  async getPageMetrics(pageId: string, sessionId: string): Promise<Record<string, unknown>> {\n    return getPageMetrics(pageId, sessionId, this.pages, this.pageStore);\n  }\n\n  async setCookies(pageId: string, cookies: Cookie[], sessionId: string): Promise<void> {\n    return setCookies(pageId, cookies, sessionId, this.pages, this.pageStore);\n  }\n\n  async getCookies(pageId: string, sessionId: string): Promise<Cookie[]> {\n    return getCookies(pageId, sessionId, this.pages, this.pageStore);\n  }\n\n  async clearPageData(\n    pageId: string,\n    sessionId: string,\n    options?: {\n      cookies?: boolean;\n      cache?: boolean;\n      localStorage?: boolean;\n      sessionStorage?: boolean;\n    }\n  ): Promise<void> {\n    return clearPageData(pageId, sessionId, options, this.pages, this.pageStore);\n  }\n\n  async isPageActive(pageId: string): Promise<boolean> {\n    return isPageActive(pageId, this.pageStore);\n  }\n\n  async cleanupIdlePages(idleTimeout: number): Promise<number> {\n    return cleanupIdlePagesWithLogging(idleTimeout, this.pageStore);\n  }\n\n\n  async shutdown(): Promise<void> {\n    this.isShuttingDown = true;\n    await shutdownPageManager(this.pages, this.pageStore, this.cleanupInterval);\n  }\n}\n\n// Re-export types\nexport type { PageEvents };\n\n// Re-export factory function\nexport { getPageManager } from './page-manager-factory.js';\n","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-navigation.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'navigatePage' has too many parameters (6). Maximum allowed is 4.","line":20,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":20,"endColumn":35},{"ruleId":"max-params","severity":2,"message":"Async function 'navigateTo' has too many parameters (6). Maximum allowed is 4.","line":59,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":59,"endColumn":33},{"ruleId":"max-params","severity":2,"message":"Async function 'navigateToWithEvents' has too many parameters (7). Maximum allowed is 4.","line":110,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":110,"endColumn":43},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3294,3297],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3294,3297],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-params","severity":2,"message":"Async function 'updatePageOptions' has too many parameters (6). Maximum allowed is 4.","line":129,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":129,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3839,3842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3839,3842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page navigation handlers\n * @module puppeteer/pages/page-navigation\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\n\nimport type { Page } from 'puppeteer';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { createLogger } from '../../utils/logger.js';\nimport type { NavigationOptions } from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\n\nconst logger = createLogger('page-navigation');\n\n/**\n * Navigate page\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function navigatePage(\n  pageId: string,\n  sessionId: string,\n  url: string,\n  options: NavigationOptions | undefined,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<void> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    throw new AppError('Page not found or access denied', 404);\n  }\n\n  const page = pages.get(pageId);\n  if (!page || page.isClosed()) {\n    await pageStore.delete(pageId);\n    pages.delete(pageId);\n    throw new AppError('Page is closed', 410);\n  }\n\n  logger.debug({ pageId, url }, 'Navigating page');\n\n  await page.goto(url, {\n    waitUntil: options?.waitUntil ?? 'networkidle2',\n    timeout: options?.timeout ?? 30000,\n  });\n\n  // Update activity\n  await pageStore.touchActivity(pageId);\n}\n\n/**\n * Navigate to URL\n * @param pageId - Page identifier\n * @param url - Target URL\n * @param sessionId - Session identifier for validation\n * @param options - Navigation options\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport async function navigateTo(\n  pageId: string,\n  url: string,\n  sessionId: string,\n  options: NavigationOptions | undefined,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<void> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    throw new AppError('Page not found or access denied', 404);\n  }\n\n  const page = pages.get(pageId);\n  if (!page) {\n    throw new AppError('Page instance not found', 404);\n  }\n\n  await pageStore.updateState(pageId, 'navigating');\n  \n  try {\n    await page.goto(url, {\n      timeout: options?.timeout ?? 30000,\n      waitUntil: options?.waitUntil ?? 'load',\n      referer: options?.referer,\n    });\n    \n    const title = await page.title();\n    await pageStore.updateUrl(pageId, url);\n    await pageStore.updateTitle(pageId, title);\n    await pageStore.addNavigationHistory(pageId, url);\n    await pageStore.updateState(pageId, 'active');\n    \n  } catch (error) {\n    await pageStore.updateState(pageId, 'active');\n    await pageStore.incrementErrorCount(pageId);\n    throw error;\n  }\n}\n\n/**\n * Navigate to URL with event emission\n * @param pageId - Page identifier\n * @param url - Target URL\n * @param sessionId - Session identifier for validation\n * @param options - Navigation options\n * @param pages - Pages map\n * @param pageStore - Page info store\n * @param emitter - Event emitter for page events\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport async function navigateToWithEvents(\n  pageId: string,\n  url: string,\n  sessionId: string,\n  options: NavigationOptions | undefined,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore,\n  emitter: { emit: (event: string, data: any) => void }\n): Promise<void> {\n  await navigateTo(pageId, url, sessionId, options, pages, pageStore);\n  emitter.emit('page:navigated', { pageId, url });\n}\n\n/**\n * Update page options\n * @param pageId - Page identifier\n * @param options - Page options to update\n * @param sessionId - Session identifier for validation\n */\nexport async function updatePageOptions(\n  pageId: string,\n  options: Partial<NavigationOptions>,\n  sessionId: string,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore,\n  configurePageOptions: (page: Page, options: any) => Promise<void>\n): Promise<void> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    throw new AppError('Page not found or access denied', 404);\n  }\n\n  const page = pages.get(pageId);\n  if (!page) {\n    throw new AppError('Page instance not found', 404);\n  }\n\n  await configurePageOptions(page, options);\n  await pageStore.touchActivity(pageId);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-operations-types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[558,561],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[558,561],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[573,576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[573,576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2294,2297],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2294,2297],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2672,2675],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2672,2675],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Types for page operations\n * @module puppeteer/pages/page-operations-types\n */\n\nimport type { Page, Browser, Viewport, WaitForOptions } from 'puppeteer';\nimport type { BrowserEvent } from '../interfaces/browser-events.interface.js';\nimport type { PageInfo } from '../interfaces/page-manager.interface.js';\nimport type { ActionContext } from '../interfaces/action-executor.interface.js';\n\n/**\n * Parameters for close page operation\n */\nexport interface ClosePageOperationParams {\n  page: Page;\n  pageInfo: PageInfo;\n  browser: Browser;\n  sessionStore: any;\n  logger: any;\n  pageEventHandler?: (event: BrowserEvent['type'], data: unknown) => void;\n}\n\n/**\n * Parameters for create and configure page\n */\nexport interface CreateAndConfigurePageParams {\n  browser: Browser;\n  contextId: string;\n  sessionId: string;\n  pageUrl?: string;\n  viewport?: Viewport;\n  waitUntil?: WaitForOptions['waitUntil'];\n  userAgent?: string;\n  headers?: Record<string, string>;\n}\n\n/**\n * Parameters for update page options\n */\nexport interface UpdatePageOptionsParams {\n  page: Page;\n  viewport?: Viewport;\n  userAgent?: string;\n  headers?: Record<string, string>;\n  cookies?: Array<{ name: string; value: string; domain?: string }>;\n}\n\n/**\n * Parameters for navigate page\n */\nexport interface NavigatePageParams {\n  page: Page;\n  url: string;\n  waitUntil?: WaitForOptions['waitUntil'];\n  timeout?: number;\n  referer?: string;\n  pageEventHandler?: (event: BrowserEvent['type'], data: unknown) => void;\n}\n\n/**\n * Parameters for navigate to\n */\nexport interface NavigateToParams {\n  page: Page;\n  pageInfo: PageInfo;\n  url: string;\n  waitUntil?: WaitForOptions['waitUntil'];\n  timeout?: number;\n  pageEventHandler?: (event: BrowserEvent['type'], data: unknown) => void;\n}\n\n/**\n * Parameters for navigate to with events\n */\nexport interface NavigateToWithEventsParams {\n  page: Page;\n  pageInfo: PageInfo;\n  url: string;\n  context: ActionContext;\n  waitUntil?: WaitForOptions['waitUntil'];\n  timeout?: number;\n  pageEventHandler?: (event: BrowserEvent['type'], data: unknown) => void;\n}\n\n/**\n * Parameters for set cookies\n */\nexport interface SetCookiesParams {\n  page: Page;\n  cookies: Array<{ name: string; value: string; domain?: string; path?: string }>;\n  context: ActionContext;\n  pageId: string;\n  logger: any;\n}\n\n/**\n * Parameters for clear page data\n */\nexport interface ClearPageDataParams {\n  page: Page;\n  clearCookies: boolean;\n  clearStorage: boolean;\n  clearCache: boolean;\n  context: ActionContext;\n}\n\n/**\n * Parameters for take screenshot\n */\nexport interface TakeScreenshotParams {\n  page: Page;\n  fullPage: boolean;\n  quality?: number;\n  context: ActionContext;\n  logger: any;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pages/page-operations.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'setCookies' has too many parameters (5). Maximum allowed is 4.","line":44,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":44,"endColumn":33},{"ruleId":"max-params","severity":2,"message":"Async function 'clearPageData' has too many parameters (5). Maximum allowed is 4.","line":91,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":91,"endColumn":36},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":113,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":113,"endColumn":23,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2795,2811],"text":"(options?.cookies) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2795,2811],"text":"(options?.cookies) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":117,"column":7,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":117,"endColumn":28,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2880,2901],"text":"((options?.localStorage) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2880,2901],"text":"((options?.localStorage) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/prefer-nullish-coalescing","severity":2,"message":"Prefer using nullish coalescing operator (`??`) instead of a logical or (`||`), as it is a safer operator.","line":117,"column":29,"nodeType":"Punctuator","messageId":"preferNullishOverOr","endLine":117,"endColumn":31,"suggestions":[{"messageId":"suggestNullish","fix":{"range":[2902,2904],"text":"??"},"desc":"Fix to nullish coalescing operator (`??`)."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":117,"column":32,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":117,"endColumn":55,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2905,2928],"text":"((options?.sessionStorage) ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2905,2928],"text":"((options?.sessionStorage) === true)"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":119,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":119,"endColumn":29,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[2978,2996],"text":"(opts?.localStorage) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[2978,2996],"text":"(opts?.localStorage) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":120,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":120,"endColumn":63,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[3008,3062],"text":"// @ts-expect-error - window is available in browser context"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":123,"column":11,"nodeType":"ChainExpression","messageId":"conditionErrorNullableBoolean","endLine":123,"endColumn":31,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[3118,3138],"text":"(opts?.sessionStorage) ?? false"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[3118,3138],"text":"(opts?.sessionStorage) === true"},"desc":"Change condition to check if true (`value === true`)"}]},{"ruleId":"@typescript-eslint/ban-ts-comment","severity":2,"message":"Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.","line":124,"column":9,"nodeType":"Line","messageId":"tsIgnoreInsteadOfExpectError","endLine":124,"endColumn":63,"suggestions":[{"messageId":"replaceTsIgnoreWithTsExpectError","fix":{"range":[3150,3204],"text":"// @ts-expect-error - window is available in browser context"},"desc":"Replace \"@ts-ignore\" with \"@ts-expect-error\"."}]},{"ruleId":"max-params","severity":2,"message":"Async function 'takeScreenshot' has too many parameters (5). Maximum allowed is 4.","line":137,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":137,"endColumn":37},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":195,"column":42,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":195,"endColumn":44}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Page operation handlers\n * @module puppeteer/pages/page-operations\n * @nist ac-3 \"Access enforcement\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Page, Cookie } from 'puppeteer';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { logSecurityEvent, SecurityEventType } from '../../utils/logger.js';\nimport type { \n  PageInfo,\n  ScreenshotOptions \n} from '../interfaces/page-manager.interface.js';\nimport type { PageInfoStore } from './page-info-store.js';\n\n/**\n * Get page metrics\n * @nist au-6 \"Audit review, analysis, and reporting\"\n */\nexport async function getPageMetrics(\n  pageId: string,\n  sessionId: string,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<Record<string, unknown>> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    throw new AppError('Page not found or access denied', 404);\n  }\n\n  const page = pages.get(pageId);\n  if (!page) {\n    throw new AppError('Page instance not found', 404);\n  }\n\n  const metrics = await page.metrics();\n  return metrics as Record<string, unknown>;\n}\n\n/**\n * Set page cookies\n */\nexport async function setCookies(\n  pageId: string,\n  cookies: Cookie[],\n  sessionId: string,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<void> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    throw new AppError('Page not found or access denied', 404);\n  }\n\n  const page = pages.get(pageId);\n  if (!page) {\n    throw new AppError('Page instance not found', 404);\n  }\n\n  await page.setCookie(...cookies);\n  await pageStore.touchActivity(pageId);\n}\n\n/**\n * Get page cookies\n */\nexport async function getCookies(\n  pageId: string,\n  sessionId: string,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<Cookie[]> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    throw new AppError('Page not found or access denied', 404);\n  }\n\n  const page = pages.get(pageId);\n  if (!page) {\n    throw new AppError('Page instance not found', 404);\n  }\n\n  const cookies = await page.cookies();\n  return cookies;\n}\n\n/**\n * Clear page data\n */\nexport async function clearPageData(\n  pageId: string,\n  sessionId: string,\n  options: {\n    cookies?: boolean;\n    cache?: boolean;\n    localStorage?: boolean;\n    sessionStorage?: boolean;\n  } | undefined,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<void> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    throw new AppError('Page not found or access denied', 404);\n  }\n\n  const page = pages.get(pageId);\n  if (!page) {\n    throw new AppError('Page instance not found', 404);\n  }\n\n  if (options?.cookies) {\n    await page.deleteCookie(...await page.cookies());\n  }\n\n  if (options?.localStorage || options?.sessionStorage) {\n    await page.evaluate((opts) => {\n      if (opts?.localStorage) {\n        // @ts-ignore - window is available in browser context\n        window.localStorage.clear();\n      }\n      if (opts?.sessionStorage) {\n        // @ts-ignore - window is available in browser context\n        window.sessionStorage.clear();\n      }\n    }, options);\n  }\n\n  await pageStore.touchActivity(pageId);\n}\n\n/**\n * Take screenshot\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function takeScreenshot(\n  pageId: string,\n  sessionId: string,\n  options: ScreenshotOptions | undefined,\n  pages: Map<string, Page>,\n  pageStore: PageInfoStore\n): Promise<Buffer> {\n  const pageInfo = await pageStore.get(pageId);\n  if (!pageInfo || pageInfo.sessionId !== sessionId) {\n    await logSecurityEvent(SecurityEventType.ACCESS_DENIED, {\n      userId: sessionId,\n      resource: `page:${pageId}`,\n      result: 'failure',\n      reason: 'Page does not belong to session',\n    });\n    throw new AppError('Unauthorized access to page', 403);\n  }\n\n  const page = pages.get(pageId);\n  if (!page || page.isClosed()) {\n    await pageStore.delete(pageId);\n    pages.delete(pageId);\n    throw new AppError('Page is closed', 410);\n  }\n\n  const screenshot = await page.screenshot({\n    type: options?.type ?? 'png',\n    fullPage: options?.fullPage ?? false,\n    quality: options?.quality,\n    clip: options?.clip,\n    encoding: 'binary',\n  });\n\n  // Update activity\n  await pageStore.touchActivity(pageId);\n\n  return Buffer.isBuffer(screenshot) ? screenshot : Buffer.from(screenshot);\n}\n\n/**\n * Check if page is active\n */\nexport async function isPageActive(\n  pageId: string,\n  pageStore: PageInfoStore\n): Promise<boolean> {\n  const pageInfo = await pageStore.get(pageId);\n  return pageInfo?.state === 'active';\n}\n\n/**\n * Clean up idle pages\n */\nexport async function cleanupIdlePages(\n  idleTimeout: number,\n  pageStore: PageInfoStore\n): Promise<number> {\n  const now = Date.now();\n  const predicate = (pageInfo: PageInfo) => {\n    const idleTime = now - pageInfo.lastActivityAt.getTime();\n    return idleTime > idleTimeout;\n  };\n\n  const cleanedCount = await pageStore.cleanup(predicate);\n  \n  return cleanedCount;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-health-checker.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable boolean value in conditional. Please handle the nullish case explicitly.","line":294,"column":30,"nodeType":"MemberExpression","messageId":"conditionErrorNullableBoolean","endLine":294,"endColumn":60,"suggestions":[{"messageId":"conditionFixDefaultFalse","fix":{"range":[7542,7572],"text":"(this.config.enableAutoRecovery ?? false)"},"desc":"Explicitly treat nullish value the same as false (`value ?? false`)"},{"messageId":"conditionFixCompareTrue","fix":{"range":[7542,7572],"text":"(this.config.enableAutoRecovery === true)"},"desc":"Change condition to check if true (`value === true`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Health Checker for Puppeteer Pool\n * @module puppeteer/pool/browser-health-checker\n * @nist si-4 \"Information system monitoring\"\n * @nist au-6 \"Audit review, analysis, and reporting\"\n */\n\nimport { Browser, LaunchOptions } from 'puppeteer';\nimport * as puppeteer from 'puppeteer';\nimport type { BrowserInstance } from '../interfaces/browser-pool.interface.js';\nimport { createLogger } from '../../utils/logger.js';\n\nconst logger = createLogger('browser-health-checker');\n\n/**\n * Health check configuration options\n */\nexport interface HealthCheckOptions {\n  /** Maximum memory usage in MB before considering unhealthy */\n  maxMemoryMB: number;\n  \n  /** Maximum number of pages before considering unhealthy */\n  maxPageCount: number;\n  \n  /** Timeout for responsiveness check in ms */\n  responseTimeout: number;\n  \n  /** Health check interval in ms */\n  checkInterval: number;\n  \n  /** Enable automatic recovery of unhealthy browsers */\n  enableAutoRecovery?: boolean;\n}\n\n/**\n * Health check result\n */\nexport interface HealthCheckResult {\n  /** Overall health status */\n  isHealthy: boolean;\n  \n  /** Connection status */\n  connectionHealthy: boolean;\n  \n  /** Memory usage status */\n  memoryHealthy: boolean;\n  \n  /** Page count status */\n  pageCountHealthy: boolean;\n  \n  /** Responsiveness status */\n  responsive: boolean;\n  \n  /** Reason for unhealthy status */\n  reason?: string;\n  \n  /** Health metrics */\n  metrics: {\n    memoryUsageMB: number;\n    pageCount: number;\n    useCount: number;\n    uptime: number;\n    lastChecked: Date;\n  };\n}\n\n/**\n * Recovery result\n */\nexport interface RecoveryResult {\n  /** Whether recovery was performed */\n  recovered: boolean;\n  \n  /** New browser instance if recovered */\n  newBrowser?: Browser;\n  \n  /** Health check result */\n  health: HealthCheckResult;\n  \n  /** Error if recovery failed */\n  error?: Error;\n}\n\n/**\n * Browser health checker implementation\n * @nist si-4 \"Information system monitoring\"\n */\nexport class BrowserHealthChecker {\n  private config: HealthCheckOptions;\n\n  constructor(options: HealthCheckOptions) {\n    this.config = this.validateConfig(options);\n  }\n\n  /**\n   * Check health of a browser instance\n   * @nist si-4 \"Information system monitoring\"\n   */\n  async checkHealth(instance: BrowserInstance): Promise<HealthCheckResult> {\n    const startTime = Date.now();\n    const result: HealthCheckResult = {\n      isHealthy: true,\n      connectionHealthy: true,\n      memoryHealthy: true,\n      pageCountHealthy: true,\n      responsive: true,\n      metrics: {\n        memoryUsageMB: 0,\n        pageCount: 0,\n        useCount: instance.useCount,\n        uptime: Date.now() - instance.createdAt.getTime(),\n        lastChecked: new Date(),\n      },\n    };\n\n    try {\n      // Check connection\n      if (!instance.browser.isConnected()) {\n        result.connectionHealthy = false;\n        result.isHealthy = false;\n        result.reason = 'Browser disconnected';\n        return result;\n      }\n\n      // Check process\n      const process = instance.browser.process();\n      if (!process) {\n        result.connectionHealthy = false;\n        result.isHealthy = false;\n        result.reason = 'Browser process not found';\n        return result;\n      }\n\n      // Check responsiveness\n      const responsive = await this.checkResponsiveness(instance.browser);\n      if (!responsive) {\n        result.responsive = false;\n        result.isHealthy = false;\n        result.reason = 'Browser unresponsive';\n      }\n\n      // Check memory usage\n      const memoryUsage = await this.checkMemoryUsage(instance.browser);\n      result.metrics.memoryUsageMB = memoryUsage;\n      \n      if (memoryUsage > this.config.maxMemoryMB) {\n        result.memoryHealthy = false;\n        result.isHealthy = false;\n        result.reason = `Excessive memory usage: ${memoryUsage.toFixed(2)}MB`;\n      }\n\n      // Check page count\n      const pages = await instance.browser.pages();\n      result.metrics.pageCount = pages.length;\n      \n      if (pages.length > this.config.maxPageCount) {\n        result.pageCountHealthy = false;\n        result.isHealthy = false;\n        result.reason = `Too many pages: ${pages.length}`;\n      }\n\n      const duration = Date.now() - startTime;\n      logger.debug({\n        browserId: instance.id,\n        result,\n        duration,\n      }, 'Health check completed');\n\n      return result;\n    } catch (error) {\n      logger.error({\n        browserId: instance.id,\n        error,\n      }, 'Health check failed');\n\n      result.isHealthy = false;\n      result.reason = error instanceof Error ? error.message : 'Unknown error';\n      return result;\n    }\n  }\n\n  /**\n   * Check responsiveness of browser\n   */\n  private async checkResponsiveness(browser: Browser): Promise<boolean> {\n    try {\n      const pages = await browser.pages();\n      if (pages.length === 0) {\n        return true; // No pages to check\n      }\n\n      const page = pages[0];\n      const timeoutPromise = new Promise<boolean>((resolve) => {\n        setTimeout(() => resolve(false), this.config.responseTimeout);\n      });\n\n      const evalPromise = page?.evaluate(() => 1 + 1).then(() => true) ?? Promise.resolve(false);\n      \n      return await Promise.race([evalPromise, timeoutPromise]);\n    } catch (error) {\n      logger.debug({ error }, 'Responsiveness check failed');\n      return false;\n    }\n  }\n\n  /**\n   * Check memory usage of browser\n   */\n  private async checkMemoryUsage(browser: Browser): Promise<number> {\n    try {\n      const pages = await browser.pages();\n      if (pages.length === 0) {\n        return 0;\n      }\n\n      const page = pages[0];\n      if (!page) {\n        return 0;\n      }\n      const metrics = await page.metrics();\n      const memoryMB = (metrics.JSHeapUsedSize ?? 0) / (1024 * 1024);\n      \n      return memoryMB;\n    } catch (error) {\n      logger.debug({ error }, 'Memory check failed');\n      return 0;\n    }\n  }\n\n  /**\n   * Restart an unhealthy browser\n   * @nist ac-12 \"Session termination\"\n   * @nist au-6 \"Audit review, analysis, and reporting\"\n   */\n  async restartBrowser(\n    instance: BrowserInstance,\n    launchOptions: LaunchOptions\n  ): Promise<Browser> {\n    logger.info({\n      browserId: instance.id,\n      pid: instance.pid,\n    }, 'Restarting unhealthy browser');\n\n    try {\n      // Close the old browser\n      await instance.browser.close();\n    } catch (error) {\n      logger.error({\n        browserId: instance.id,\n        error,\n      }, 'Failed to close unhealthy browser');\n    }\n\n    // Launch new browser\n    const newBrowser = await puppeteer.launch(launchOptions);\n    \n    logger.info({\n      browserId: instance.id,\n      newPid: newBrowser.process()?.pid,\n    }, 'Browser restarted successfully');\n\n    return newBrowser;\n  }\n\n  /**\n   * Check multiple browser instances\n   */\n  async checkMultiple(\n    instances: BrowserInstance[]\n  ): Promise<Map<string, HealthCheckResult>> {\n    const results = new Map<string, HealthCheckResult>();\n    \n    await Promise.all(\n      instances.map(async (instance) => {\n        const result = await this.checkHealth(instance);\n        results.set(instance.id, result);\n      })\n    );\n\n    return results;\n  }\n\n  /**\n   * Check and recover if needed\n   * @nist si-4 \"Information system monitoring\"\n   * @nist si-7 \"Software, firmware, and information integrity\"\n   */\n  async checkAndRecover(\n    instance: BrowserInstance,\n    launchOptions: LaunchOptions\n  ): Promise<RecoveryResult> {\n    const health = await this.checkHealth(instance);\n    \n    if (!health.isHealthy && this.config.enableAutoRecovery) {\n      try {\n        const newBrowser = await this.restartBrowser(instance, launchOptions);\n        \n        return {\n          recovered: true,\n          newBrowser,\n          health,\n        };\n      } catch (error) {\n        logger.error({\n          browserId: instance.id,\n          error,\n        }, 'Failed to recover unhealthy browser');\n        \n        return {\n          recovered: false,\n          health,\n          error: error as Error,\n        };\n      }\n    }\n\n    return {\n      recovered: false,\n      health,\n    };\n  }\n\n  /**\n   * Update configuration\n   * @nist cm-7 \"Least functionality\"\n   */\n  updateConfig(updates: Partial<HealthCheckOptions>): void {\n    const newConfig = { ...this.config, ...updates };\n    this.config = this.validateConfig(newConfig);\n    \n    logger.info({\n      ...updates,\n    }, 'Health checker configuration updated');\n  }\n\n  /**\n   * Validate configuration\n   */\n  private validateConfig(config: HealthCheckOptions): HealthCheckOptions {\n    if (config.maxMemoryMB <= 0) {\n      throw new Error('Invalid configuration: maxMemoryMB must be positive');\n    }\n    \n    if (config.maxPageCount <= 0) {\n      throw new Error('Invalid configuration: maxPageCount must be positive');\n    }\n    \n    if (config.responseTimeout <= 0) {\n      throw new Error('Invalid configuration: responseTimeout must be positive');\n    }\n    \n    if (config.checkInterval <= 0) {\n      throw new Error('Invalid configuration: checkInterval must be positive');\n    }\n\n    return config;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-health.ts","messages":[{"ruleId":"@typescript-eslint/prefer-optional-chain","severity":2,"message":"Prefer using an optional chain expression instead, as it's more concise and easier to read.","line":56,"column":9,"nodeType":null,"messageId":"preferOptionalChain","endLine":56,"endColumn":31,"fix":{"range":[1320,1342],"text":"process?.pid"}},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":56,"column":20,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":56,"endColumn":31,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[1331,1342],"text":"(process.pid != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[1331,1342],"text":"(process.pid ?? 0)"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[1331,1342],"text":"(Boolean(process.pid))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"max-params","severity":2,"message":"Method 'startMonitoring' has too many parameters (5). Maximum allowed is 4.","line":110,"column":3,"nodeType":"FunctionExpression","messageId":"exceed","endLine":110,"endColumn":18},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":120,"column":34,"nodeType":"ArrowFunctionExpression","messageId":"voidReturnArgument","endLine":137,"endColumn":6}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Browser Health Monitoring\n * @module puppeteer/pool/browser-health\n * @nist ac-12 \"Session termination\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Browser } from 'puppeteer';\nimport { createLogger } from '../../utils/logger.js';\nimport type { BrowserInstance } from '../interfaces/browser-pool.interface.js';\n\nconst logger = createLogger('browser-health');\n\n/**\n * Health check result\n */\nexport interface HealthCheckResult {\n  healthy: boolean;\n  responsive: boolean;\n  memoryUsage?: number;\n  cpuUsage?: number;\n  openPages?: number;\n  error?: string;\n}\n\n/**\n * Check browser health\n * @nist au-3 \"Content of audit records\"\n */\nexport async function checkBrowserHealth(\n  browser: Browser,\n  instance: BrowserInstance\n): Promise<HealthCheckResult> {\n  try {\n    // Check if browser is connected\n    if (!browser.isConnected()) {\n      return {\n        healthy: false,\n        responsive: false,\n        error: 'Browser disconnected',\n      };\n    }\n\n    // Get browser version (tests responsiveness)\n    await browser.version();\n\n    // Get metrics\n    const pages = await browser.pages();\n    const openPages = pages.length;\n\n    // Get process metrics if available\n    const process = browser.process();\n    let memoryUsage: number | undefined;\n    let cpuUsage: number | undefined;\n\n    if (process && process.pid) {\n      try {\n        // This is platform-specific and may not work on all systems\n        const { execSync } = await import('child_process');\n        const stats = execSync(`ps -p ${process.pid} -o %mem,%cpu | tail -1`).toString();\n        const [mem, cpu] = stats.trim().split(/\\s+/).map(parseFloat);\n        memoryUsage = mem;\n        cpuUsage = cpu;\n      } catch {\n        // Ignore errors in getting process stats\n      }\n    }\n\n    // Check page count\n    const maxPagesPerBrowser = 20;\n    if (openPages > maxPagesPerBrowser) {\n      logger.warn({\n        browserId: instance.id,\n        openPages,\n        maxPages: maxPagesPerBrowser,\n      }, 'Browser has too many open pages');\n    }\n\n    return {\n      healthy: true,\n      responsive: true,\n      openPages,\n      memoryUsage,\n      cpuUsage,\n    };\n\n  } catch (error) {\n    logger.error({\n      browserId: instance.id,\n      error: error instanceof Error ? error.message : 'Unknown error',\n    }, 'Browser health check failed');\n\n    return {\n      healthy: false,\n      responsive: false,\n      error: error instanceof Error ? error.message : 'Health check failed',\n    };\n  }\n}\n\n/**\n * Monitor browser health periodically\n */\nexport class BrowserHealthMonitor {\n  private intervals = new Map<string, NodeJS.Timeout>();\n\n  /**\n   * Start monitoring a browser\n   */\n  startMonitoring(\n    browserId: string,\n    browser: Browser,\n    instance: BrowserInstance,\n    onUnhealthy: () => void,\n    intervalMs: number = 30000\n  ): void {\n    // Clear any existing interval\n    this.stopMonitoring(browserId);\n\n    const interval = setInterval(async () => {\n      const health = await checkBrowserHealth(browser, instance);\n      \n      if (!health.healthy) {\n        logger.warn({\n          browserId,\n          health,\n        }, 'Browser unhealthy, triggering recovery');\n        \n        onUnhealthy();\n        this.stopMonitoring(browserId);\n      } else {\n        logger.debug({\n          browserId,\n          health,\n        }, 'Browser health check passed');\n      }\n    }, intervalMs);\n\n    this.intervals.set(browserId, interval);\n  }\n\n  /**\n   * Stop monitoring a browser\n   */\n  stopMonitoring(browserId: string): void {\n    const interval = this.intervals.get(browserId);\n    if (interval) {\n      clearInterval(interval);\n      this.intervals.delete(browserId);\n    }\n  }\n\n  /**\n   * Stop all monitoring\n   */\n  stopAll(): void {\n    for (const interval of this.intervals.values()) {\n      clearInterval(interval);\n    }\n    this.intervals.clear();\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-acquisition-handlers.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'acquireBrowser' has too many parameters (7). Maximum allowed is 4.","line":20,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":20,"endColumn":37},{"ruleId":"require-await","severity":2,"message":"Async function 'acquireBrowser' has no 'await' expression.","line":20,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":20,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1797,1800],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1797,1800],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser pool acquisition handlers\n * @module puppeteer/pool/browser-pool-acquisition-handlers\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\n\nimport { AppError } from '../../core/errors/app-error.js';\nimport { createLogger } from '../../utils/logger.js';\nimport type { BrowserInstance } from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\n\nconst logger = createLogger('browser-pool-acquisition-handlers');\n\n/**\n * Acquire a browser for a session\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport async function acquireBrowser(\n  sessionId: string,\n  isShuttingDown: boolean,\n  findIdleBrowser: () => InternalBrowserInstance | null,\n  activateBrowser: (instance: InternalBrowserInstance, sessionId: string) => InternalBrowserInstance,\n  createAndAcquireBrowser: (sessionId: string) => Promise<BrowserInstance>,\n  canCreateNewBrowser: () => boolean,\n  queueAcquisition: (sessionId: string) => Promise<BrowserInstance>\n): Promise<BrowserInstance> {\n  if (isShuttingDown) {\n    throw new AppError('Browser pool is shutting down', 503);\n  }\n\n  logger.debug({ sessionId }, 'Browser acquisition requested');\n\n  // Try to find an idle browser\n  const idleBrowser = findIdleBrowser();\n  if (idleBrowser) {\n    return activateBrowser(idleBrowser, sessionId);\n  }\n\n  // Check if we can create a new browser\n  if (canCreateNewBrowser()) {\n    return createAndAcquireBrowser(sessionId);\n  }\n\n  // Queue the request\n  return queueAcquisition(sessionId);\n}\n\n/**\n * Release a browser back to the pool\n * @nist ac-12 \"Session termination\"\n */\nexport function releaseBrowser(\n  browserId: string,\n  browsers: Map<string, InternalBrowserInstance>,\n  queue: any,\n  onReleased: (browserId: string) => void\n): void {\n  const instance = browsers.get(browserId);\n  if (!instance) {\n    logger.warn({ browserId }, 'Attempted to release unknown browser');\n    return;\n  }\n\n  logger.debug({ browserId, sessionId: instance.sessionId }, 'Releasing browser');\n\n  // Update state\n  instance.state = 'idle';\n  instance.sessionId = null;\n  instance.lastUsedAt = new Date();\n\n  // Process queue\n  queue.processNext(instance);\n\n  // Emit event\n  onReleased(browserId);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-acquisition.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'createAndAcquireBrowser' has too many parameters (5). Maximum allowed is 4.","line":18,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":18,"endColumn":46}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser pool acquisition logic\n * @module puppeteer/pool/browser-pool-acquisition\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\n\nimport type { Browser } from 'puppeteer';\nimport type { BrowserInstance, BrowserPoolOptions } from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\nimport { launchBrowser } from './browser-utils.js';\nimport { BrowserHealthMonitor } from './browser-health.js';\nimport { BrowserQueue } from './browser-queue.js';\n\n/**\n * Create and acquire a new browser\n */\nexport async function createAndAcquireBrowser(\n  sessionId: string,\n  options: BrowserPoolOptions,\n  browsers: Map<string, InternalBrowserInstance>,\n  healthMonitor: BrowserHealthMonitor,\n  onHealthCheckFailed: (browserId: string) => void\n): Promise<BrowserInstance> {\n  const { instance } = await launchNewBrowser(\n    options,\n    browsers,\n    healthMonitor,\n    onHealthCheckFailed\n  );\n  \n  // Activate for session\n  instance.state = 'active';\n  instance.sessionId = sessionId;\n  instance.lastUsedAt = new Date();\n\n  return instance;\n}\n\n/**\n * Queue a browser acquisition request\n */\nexport function queueAcquisition(\n  sessionId: string,\n  queue: BrowserQueue,\n  acquisitionTimeout: number\n): Promise<BrowserInstance> {\n  return new Promise((resolve, reject) => {\n    queue.enqueue({\n      sessionId,\n      priority: 0, // Default priority\n      timeout: acquisitionTimeout,\n      resolve,\n      reject,\n    });\n  });\n}\n\n/**\n * Launch a new browser\n */\nexport async function launchNewBrowser(\n  options: BrowserPoolOptions,\n  browsers: Map<string, InternalBrowserInstance>,\n  healthMonitor: BrowserHealthMonitor,\n  onHealthCheckFailed: (browserId: string) => void\n): Promise<{ browser: Browser; instance: InternalBrowserInstance }> {\n  const result = await launchBrowser(options);\n  \n  // Create internal instance with additional state\n  const internalInstance: InternalBrowserInstance = {\n    ...result.instance,\n    state: 'idle',\n    sessionId: null,\n    errorCount: 0,\n  };\n  \n  // Store instance\n  browsers.set(internalInstance.id, internalInstance);\n\n  // Start health monitoring\n  healthMonitor.startMonitoring(\n    internalInstance.id,\n    result.browser,\n    internalInstance,\n    () => onHealthCheckFailed(internalInstance.id),\n    options.healthCheckInterval\n  );\n\n  return { browser: result.browser, instance: internalInstance };\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-event-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-facade.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'acquireBrowserFacade' has too many parameters (7). Maximum allowed is 4.","line":15,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":15,"endColumn":43},{"ruleId":"require-await","severity":2,"message":"Async function 'acquireBrowserFacade' has no 'await' expression.","line":15,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":15,"endColumn":43}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Pool Facade Methods\n * @module puppeteer/pool/browser-pool-facade\n */\n\nimport type { BrowserInstance } from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\nimport { acquireBrowser } from './browser-pool-acquisition-handlers.js';\n\n/**\n * Acquire browser facade method\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport async function acquireBrowserFacade(\n  sessionId: string,\n  isShuttingDown: boolean,\n  findIdleBrowser: () => InternalBrowserInstance | null,\n  activateBrowser: (instance: InternalBrowserInstance, sessionId: string) => InternalBrowserInstance,\n  createAndAcquireBrowser: (sessionId: string) => Promise<BrowserInstance>,\n  canCreateNewBrowser: () => boolean,\n  queueAcquisition: (sessionId: string) => Promise<BrowserInstance>\n): Promise<BrowserInstance> {\n  return acquireBrowser(\n    sessionId,\n    isShuttingDown,\n    findIdleBrowser,\n    activateBrowser,\n    createAndAcquireBrowser,\n    canCreateNewBrowser,\n    queueAcquisition\n  );\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-init.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[484,487],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[484,487],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser pool initialization\n * @module puppeteer/pool/browser-pool-init\n * @nist ac-3 \"Access enforcement\"\n */\n\nimport { createLogger } from '../../utils/logger.js';\nimport type { BrowserPool } from '../interfaces/browser-pool.interface.js';\n\nconst logger = createLogger('browser-pool-init');\n\n/**\n * Initialize the pool\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function initializePool(\n  _pool: BrowserPool,\n  maxBrowsers: number,\n  launchNewBrowser: () => Promise<any>\n): Promise<void> {\n  logger.info({\n    maxBrowsers,\n  }, 'Initializing browser pool');\n\n  // Launch one browser initially\n  try {\n    await launchNewBrowser();\n  } catch (error) {\n    logger.error({\n      error: error instanceof Error ? error.message : 'Unknown error',\n    }, 'Failed to launch initial browser');\n  }\n\n  logger.info({\n    activeBrowsers: 1,\n  }, 'Browser pool initialized');\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-lifecycle.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2543,2546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2543,2546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-params","severity":2,"message":"Async function 'createAndAcquireNewBrowser' has too many parameters (6). Maximum allowed is 4.","line":88,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":88,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3323,3326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3323,3326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":101,"column":5,"nodeType":"Identifier","messageId":"voidReturnArgument","endLine":101,"endColumn":27},{"ruleId":"max-params","severity":2,"message":"Async function 'launchBrowser' has too many parameters (5). Maximum allowed is 4.","line":122,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":122,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4153,4156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4153,4156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-misused-promises","severity":2,"message":"Promise returned in function argument where a void return was expected.","line":133,"column":5,"nodeType":"Identifier","messageId":"voidReturnArgument","endLine":133,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4644,4647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4644,4647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Pool Lifecycle Methods\n * @module puppeteer/pool/browser-pool-lifecycle\n */\n\nimport type { Browser } from 'puppeteer';\nimport { EventEmitter } from 'events';\nimport type { BrowserInstance, BrowserPoolOptions } from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\nimport { BrowserHealthMonitor } from './browser-health.js';\nimport { BrowserQueue } from './browser-queue.js';\nimport { BrowserPoolMaintenance } from './browser-pool-maintenance.js';\nimport {\n  createAndAcquireBrowser,\n  queueAcquisition,\n  launchNewBrowser,\n} from './browser-pool-acquisition.js';\nimport { setupQueueHandlers } from './browser-pool-event-setup.js';\nimport { initializePool } from './browser-pool-init.js';\nimport { shutdownPool } from './browser-pool-shutdown.js';\nimport { DEFAULT_OPTIONS } from './browser-pool-config.js';\nimport { findIdleBrowser } from './browser-pool-operations.js';\nimport { activateBrowserForSession } from './browser-pool-private-methods.js';\n\n/**\n * Initialize browser pool components\n * @nist ac-3 \"Access enforcement\"\n */\nexport function initializeBrowserPool(\n  eventEmitter: EventEmitter,\n  options: Partial<BrowserPoolOptions>,\n  findIdleBrowser: () => InternalBrowserInstance | null,\n  performMaintenance: () => Promise<void>\n): {\n  options: BrowserPoolOptions;\n  browsers: Map<string, InternalBrowserInstance>;\n  healthMonitor: BrowserHealthMonitor;\n  queue: BrowserQueue;\n  maintenance: BrowserPoolMaintenance;\n} {\n  const fullOptions = { ...DEFAULT_OPTIONS, ...options } as BrowserPoolOptions;\n  const browsers = new Map<string, InternalBrowserInstance>();\n  const healthMonitor = new BrowserHealthMonitor();\n  const queue = new BrowserQueue();\n  const maintenance = new BrowserPoolMaintenance();\n\n  // Start maintenance cycle\n  maintenance.startMaintenance(performMaintenance, 60000);\n\n  // Set up queue event handling\n  setupQueueHandlers(eventEmitter, queue, findIdleBrowser);\n\n  return { options: fullOptions, browsers, healthMonitor, queue, maintenance };\n}\n\n/**\n * Initialize the pool with browsers\n * @nist ac-3 \"Access enforcement\"\n */\nexport async function initializePoolWithBrowsers(\n  eventEmitter: EventEmitter,\n  maxBrowsers: number,\n  launchBrowser: () => Promise<{ browser: Browser; instance: InternalBrowserInstance }>\n): Promise<void> {\n  // Note: First parameter type mismatch - initializePool expects BrowserPool but we have EventEmitter\n  // Cast to any to maintain compatibility\n  await initializePool(eventEmitter as any, maxBrowsers, launchBrowser);\n}\n\n/**\n * Shutdown browser pool\n * @nist ac-12 \"Session termination\"\n */\nexport async function shutdownBrowserPool(\n  browsers: Map<string, InternalBrowserInstance>,\n  healthMonitor: BrowserHealthMonitor,\n  queue: BrowserQueue,\n  maintenance: BrowserPoolMaintenance\n): Promise<void> {\n  maintenance.setShuttingDown(true);\n  maintenance.stopMaintenance();\n  await shutdownPool(browsers, healthMonitor, queue);\n}\n\n/**\n * Create and acquire a new browser\n */\nexport async function createAndAcquireNewBrowser(\n  sessionId: string,\n  options: BrowserPoolOptions,\n  browsers: Map<string, InternalBrowserInstance>,\n  healthMonitor: BrowserHealthMonitor,\n  handleUnhealthyBrowser: (browserId: string) => Promise<void>,\n  emitEvent: (event: string, data: any) => void\n): Promise<BrowserInstance> {\n  const instance = await createAndAcquireBrowser(\n    sessionId,\n    options,\n    browsers,\n    healthMonitor,\n    handleUnhealthyBrowser\n  );\n  \n  emitEvent('browser:acquired', { browserId: instance.id, sessionId });\n  return instance;\n}\n\n/**\n * Queue a browser acquisition request\n */\nexport function queueBrowserAcquisition(\n  sessionId: string,\n  queue: BrowserQueue,\n  acquisitionTimeout: number\n): Promise<BrowserInstance> {\n  return queueAcquisition(sessionId, queue, acquisitionTimeout);\n}\n\n/**\n * Launch a new browser\n */\nexport async function launchBrowser(\n  options: BrowserPoolOptions,\n  browsers: Map<string, InternalBrowserInstance>,\n  healthMonitor: BrowserHealthMonitor,\n  handleUnhealthyBrowser: (browserId: string) => Promise<void>,\n  emitEvent: (event: string, data: any) => void\n): Promise<{ browser: Browser; instance: InternalBrowserInstance }> {\n  const result = await launchNewBrowser(\n    options,\n    browsers,\n    healthMonitor,\n    handleUnhealthyBrowser\n  );\n  \n  emitEvent('browser:created', { browserId: result.instance.id });\n  return result;\n}\n\n\n/**\n * Create BrowserPool helper methods\n */\nexport function createBrowserPoolHelpers(\n  browsers: Map<string, InternalBrowserInstance>,\n  options: BrowserPoolOptions,\n  emit: (event: string, data: any) => void\n): {\n  findIdleBrowser: () => InternalBrowserInstance | null;\n  activateBrowser: (instance: InternalBrowserInstance, sessionId: string) => InternalBrowserInstance;\n  canCreateNewBrowser: () => boolean;\n} {\n  return {\n    findIdleBrowser: () => findIdleBrowser(browsers),\n    activateBrowser: (instance: InternalBrowserInstance, sessionId: string) => {\n      return activateBrowserForSession(\n        instance,\n        sessionId,\n        (browserId, sid) => emit('browser:acquired', { browserId, sessionId: sid })\n      );\n    },\n    canCreateNewBrowser: () => browsers.size < options.maxBrowsers,\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-maintenance.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async method 'handleUnhealthyBrowser' has too many parameters (5). Maximum allowed is 4.","line":167,"column":3,"nodeType":"FunctionExpression","messageId":"exceed","endLine":167,"endColumn":31},{"ruleId":"require-await","severity":2,"message":"Async method 'healthCheck' has no 'await' expression.","line":264,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":264,"endColumn":20},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'healthCheck' has no 'await' expression.","line":264,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":264,"endColumn":20}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser pool maintenance functions\n * @module puppeteer/pool/browser-pool-maintenance\n * @nist ac-12 \"Session termination\"\n * @nist si-4 \"Information system monitoring\"\n */\n\nimport type { Browser } from 'puppeteer';\nimport { createLogger } from '../../utils/logger.js';\nimport type { \n  BrowserInstance,\n  BrowserPoolOptions \n} from '../interfaces/browser-pool.interface.js';\nimport { \n  isIdleTooLong, \n  needsRestart,\n  closeBrowser,\n  restartBrowser \n} from './browser-utils.js';\nimport { BrowserHealthMonitor } from './browser-health.js';\n\nconst logger = createLogger('browser-pool-maintenance');\n\n/**\n * Maintenance operations interface\n */\nexport interface MaintenanceOperations {\n  browsers: Map<string, InternalBrowserInstance>;\n  options: BrowserPoolOptions;\n  removeBrowser: (browserId: string) => Promise<void>;\n  handleUnhealthyBrowser: (browserId: string) => Promise<void>;\n  launchNewBrowser: () => Promise<{ browser: Browser; instance: InternalBrowserInstance }>;\n}\n\n/**\n * Internal browser instance with additional state tracking\n */\nexport interface InternalBrowserInstance extends BrowserInstance {\n  state: 'idle' | 'active';\n  sessionId: string | null;\n  errorCount: number;\n}\n\n/**\n * Browser pool maintenance manager\n */\nexport class BrowserPoolMaintenance {\n  private maintenanceInterval?: NodeJS.Timeout;\n  private isShuttingDown = false;\n\n  /**\n   * Start maintenance cycle\n   */\n  startMaintenance(\n    performMaintenance: () => Promise<void>,\n    intervalMs = 60000\n  ): void {\n    this.maintenanceInterval = setInterval(\n      () => void performMaintenance(),\n      intervalMs\n    );\n  }\n\n  /**\n   * Stop maintenance tasks\n   */\n  stopMaintenance(): void {\n    if (this.maintenanceInterval) {\n      clearInterval(this.maintenanceInterval);\n      this.maintenanceInterval = undefined;\n    }\n  }\n\n  /**\n   * Perform pool maintenance\n   */\n  async performMaintenance(operations: MaintenanceOperations): Promise<void> {\n    if (this.isShuttingDown) {\n      return;\n    }\n\n    logger.debug('Performing pool maintenance');\n\n    await this.removeIdleBrowsers(operations);\n    await this.restartUnhealthyBrowsers(operations);\n    await this.ensureMinimumBrowsers(operations);\n  }\n\n  /**\n   * Remove idle browsers if above minimum\n   */\n  private async removeIdleBrowsers(operations: MaintenanceOperations): Promise<void> {\n    const { browsers, options, removeBrowser } = operations;\n    \n    if (browsers.size <= 1) {\n      return;\n    }\n\n    for (const instance of browsers.values()) {\n      if (isIdleTooLong(instance, options.idleTimeout)) {\n        await removeBrowser(instance.id);\n        \n        if (browsers.size <= 1) {\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Restart browsers that need it\n   */\n  private async restartUnhealthyBrowsers(operations: MaintenanceOperations): Promise<void> {\n    const { browsers, handleUnhealthyBrowser } = operations;\n    \n    for (const instance of browsers.values()) {\n      if (needsRestart(instance)) {\n        await handleUnhealthyBrowser(instance.id);\n      }\n    }\n  }\n\n  /**\n   * Ensure minimum browsers\n   */\n  private async ensureMinimumBrowsers(operations: MaintenanceOperations): Promise<void> {\n    const { browsers, launchNewBrowser } = operations;\n    \n    while (browsers.size < 1 && !this.isShuttingDown) {\n      try {\n        await launchNewBrowser();\n      } catch (error) {\n        logger.error({ error }, 'Failed to launch browser during maintenance');\n        break;\n      }\n    }\n  }\n\n  /**\n   * Remove a browser from the pool\n   */\n  async removeBrowser(\n    browserId: string,\n    browsers: Map<string, InternalBrowserInstance>,\n    healthMonitor: BrowserHealthMonitor\n  ): Promise<void> {\n    const instance = browsers.get(browserId);\n    if (!instance) {\n      return;\n    }\n\n    logger.info({ browserId }, 'Removing browser from pool');\n\n    // Stop health monitoring\n    healthMonitor.stopMonitoring(browserId);\n\n    // Close browser\n    await closeBrowser(instance.browser);\n\n    // Remove from pool\n    browsers.delete(browserId);\n  }\n\n  /**\n   * Handle unhealthy browser\n   */\n  async handleUnhealthyBrowser(\n    browserId: string,\n    browsers: Map<string, InternalBrowserInstance>,\n    healthMonitor: BrowserHealthMonitor,\n    options: BrowserPoolOptions,\n    onHealthCheckFailed: (browserId: string) => void\n  ): Promise<void> {\n    const instance = browsers.get(browserId);\n    if (!instance) {\n      return;\n    }\n\n    logger.warn({ browserId }, 'Handling unhealthy browser');\n\n    try {\n      // Restart the browser\n      const newBrowser = await restartBrowser(\n        instance,\n        options\n      );\n\n      // Update instance with new browser\n      instance.browser = newBrowser;\n      instance.errorCount = 0;\n      \n      // Keep instance in map (already there)\n      // browsers.set(browserId, instance); - not needed, already in map\n\n      // Restart health monitoring\n      healthMonitor.startMonitoring(\n        browserId,\n        newBrowser,\n        instance,\n        () => onHealthCheckFailed(browserId),\n        options.healthCheckInterval\n      );\n\n    } catch (error) {\n      logger.error({ browserId, error }, 'Failed to restart unhealthy browser');\n      \n      // Remove from pool\n      await this.removeBrowser(browserId, browsers, healthMonitor);\n    }\n  }\n\n  /**\n   * Recycle a browser instance\n   */\n  async recycleBrowser(\n    browserId: string,\n    browsers: Map<string, InternalBrowserInstance>,\n    options: BrowserPoolOptions\n  ): Promise<void> {\n    const instance = browsers.get(browserId);\n    if (!instance) {\n      return;\n    }\n\n    logger.info({ browserId }, 'Recycling browser');\n\n    try {\n      const newBrowser = await restartBrowser(instance, options);\n      \n      // Update instance with new browser\n      instance.browser = newBrowser;\n      instance.errorCount = 0;\n      // Instance already in map, no need to set again\n    } catch (error) {\n      logger.error({ browserId, error }, 'Failed to recycle browser');\n      throw error;\n    }\n  }\n\n  /**\n   * Clean up idle browsers\n   */\n  async cleanupIdle(\n    browsers: Map<string, InternalBrowserInstance>,\n    options: BrowserPoolOptions,\n    removeBrowser: (browserId: string) => Promise<void>\n  ): Promise<number> {\n    let cleaned = 0;\n\n    for (const [browserId, instance] of browsers) {\n      if (isIdleTooLong(instance, options.idleTimeout) && browsers.size > 1) {\n        await removeBrowser(browserId);\n        cleaned++;\n      }\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Perform health check on all browsers\n   * @nist si-4 \"Information system monitoring\"\n   */\n  async healthCheck(browsers: Map<string, InternalBrowserInstance>): Promise<Map<string, boolean>> {\n    const results = new Map<string, boolean>();\n\n    for (const [browserId, instance] of browsers) {\n      try {\n        const isHealthy = instance.browser.isConnected();\n        results.set(browserId, isHealthy);\n      } catch {\n        results.set(browserId, false);\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Set shutdown state\n   */\n  setShuttingDown(value: boolean): void {\n    this.isShuttingDown = value;\n  }\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-metrics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-operations.ts","messages":[{"ruleId":"require-await","severity":2,"message":"Async function 'closePage' has no 'await' expression.","line":77,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":77,"endColumn":32},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async function 'closePage' has no 'await' expression.","line":77,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":77,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'state' is assigned a value but never used.","line":103,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'sessionId' is assigned a value but never used.","line":103,"column":20,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'errorCount' is assigned a value but never used.","line":103,"column":31,"nodeType":"Identifier","messageId":"unusedVar","endLine":103,"endColumn":41}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser pool operations\n * @module puppeteer/pool/browser-pool-operations\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\n\nimport type { Page } from 'puppeteer';\nimport { AppError } from '../../core/errors/app-error.js';\nimport { createLogger } from '../../utils/logger.js';\nimport type { BrowserInstance } from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\n\nconst logger = createLogger('browser-pool-operations');\n\n/**\n * Find an idle browser\n */\nexport function findIdleBrowser(\n  browsers: Map<string, InternalBrowserInstance>\n): InternalBrowserInstance | null {\n  for (const instance of browsers.values()) {\n    if (instance.state === 'idle' && instance.browser.isConnected()) {\n      return instance;\n    }\n  }\n  return null;\n}\n\n/**\n * Activate a browser for a session\n */\nexport function activateBrowser(\n  instance: InternalBrowserInstance,\n  sessionId: string\n): InternalBrowserInstance {\n  instance.state = 'active';\n  instance.sessionId = sessionId;\n  instance.lastUsedAt = new Date();\n\n  logger.debug({\n    browserId: instance.id,\n    sessionId,\n  }, 'Browser activated for session');\n\n  return instance;\n}\n\n/**\n * Create a new page in a browser\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport async function createPage(\n  browserId: string,\n  sessionId: string,\n  browsers: Map<string, InternalBrowserInstance>\n): Promise<Page> {\n  const instance = browsers.get(browserId);\n  if (!instance) {\n    throw new AppError('Browser not found', 404);\n  }\n\n  if (instance.sessionId !== sessionId) {\n    throw new AppError('Browser not assigned to session', 403);\n  }\n\n  const page = await instance.browser.newPage();\n  instance.pageCount++;\n  instance.lastUsedAt = new Date();\n\n  return page;\n}\n\n/**\n * Close a page in a browser\n */\nexport async function closePage(\n  browserId: string,\n  sessionId: string,\n  browsers: Map<string, InternalBrowserInstance>\n): Promise<void> {\n  const instance = browsers.get(browserId);\n  if (!instance) {\n    return;\n  }\n\n  if (instance.sessionId !== sessionId) {\n    throw new AppError('Browser not assigned to session', 403);\n  }\n\n  // Decrement page count\n  instance.pageCount = Math.max(0, instance.pageCount - 1);\n  instance.lastUsedAt = new Date();\n}\n\n/**\n * List all browser instances\n */\nexport function listBrowsers(\n  browsers: Map<string, InternalBrowserInstance>\n): BrowserInstance[] {\n  return Array.from(browsers.values()).map(internal => {\n    const { state, sessionId, errorCount, ...browserInstance } = internal;\n    return browserInstance;\n  });\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-private-methods.ts","messages":[{"ruleId":"max-params","severity":2,"message":"Async function 'handleUnhealthyBrowserWithEvent' has too many parameters (5). Maximum allowed is 4.","line":52,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":52,"endColumn":54},{"ruleId":"max-params","severity":2,"message":"Async function 'handleUnhealthyBrowserDelegate' has too many parameters (7). Maximum allowed is 4.","line":80,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":80,"endColumn":53},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2296,2299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2296,2299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"max-params","severity":2,"message":"Async function 'performPoolMaintenance' has too many parameters (6). Maximum allowed is 4.","line":109,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":109,"endColumn":45},{"ruleId":"max-params","severity":2,"message":"Async function 'removeBrowserFromPool' has too many parameters (5). Maximum allowed is 4.","line":131,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":131,"endColumn":44},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3691,3694],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3691,3694],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser pool private methods\n * @module puppeteer/pool/browser-pool-private-methods\n */\n\nimport type { Browser } from 'puppeteer';\nimport { createLogger } from '../../utils/logger.js';\nimport type { BrowserPoolOptions } from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\nimport { BrowserPoolMaintenance } from './browser-pool-maintenance.js';\nimport { BrowserHealthMonitor } from './browser-health.js';\n\nconst logger = createLogger('browser-pool-private-methods');\n\n/**\n * Activate a browser for a session\n */\nexport function activateBrowserForSession(\n  instance: InternalBrowserInstance,\n  sessionId: string,\n  onActivated: (browserId: string, sessionId: string) => void\n): InternalBrowserInstance {\n  instance.state = 'active';\n  instance.sessionId = sessionId;\n  instance.lastUsedAt = new Date();\n\n  logger.debug({\n    browserId: instance.id,\n    sessionId,\n  }, 'Browser activated for session');\n\n  onActivated(instance.id, sessionId);\n\n  return instance;\n}\n\n/**\n * Handle removal of browser\n */\nexport async function handleRemoveBrowser(\n  browserId: string,\n  removeBrowser: (browserId: string) => Promise<void>,\n  onRemoved: (browserId: string) => void\n): Promise<void> {\n  await removeBrowser(browserId);\n  onRemoved(browserId);\n}\n\n/**\n * Handle unhealthy browser with event\n */\nexport async function handleUnhealthyBrowserWithEvent(\n  browserId: string,\n  browsers: Map<string, InternalBrowserInstance>,\n  handleUnhealthy: (browserId: string) => Promise<void>,\n  onRestarted: (browserId: string) => void,\n  onRemoved: (browserId: string) => void\n): Promise<void> {\n  await handleUnhealthy(browserId);\n\n  if (browsers.has(browserId)) {\n    onRestarted(browserId);\n  } else {\n    onRemoved(browserId);\n  }\n}\n\n/**\n * Perform pool maintenance with wrapper\n */\nexport async function performMaintenanceWrapper(\n  performMaintenance: () => Promise<void>\n): Promise<void> {\n  await performMaintenance();\n}\n\n/**\n * Handle unhealthy browser\n */\nexport async function handleUnhealthyBrowserDelegate(\n  browserId: string,\n  browsers: Map<string, InternalBrowserInstance>,\n  maintenance: BrowserPoolMaintenance,\n  healthMonitor: BrowserHealthMonitor,\n  options: BrowserPoolOptions,\n  emitEvent: (event: string, data: any) => void,\n  handleUnhealthyBrowser: (browserId: string) => Promise<void>\n): Promise<void> {\n  await handleUnhealthyBrowserWithEvent(\n    browserId,\n    browsers,\n    async (id) => {\n      await maintenance.handleUnhealthyBrowser(\n        id,\n        browsers,\n        healthMonitor,\n        options,\n        (bid) => void handleUnhealthyBrowser(bid)\n      );\n    },\n    (id) => emitEvent('browser:restarted', { browserId: id }),\n    (id) => emitEvent('browser:removed', { browserId: id })\n  );\n}\n\n/**\n * Perform pool maintenance\n */\nexport async function performPoolMaintenance(\n  browsers: Map<string, InternalBrowserInstance>,\n  options: BrowserPoolOptions,\n  maintenance: BrowserPoolMaintenance,\n  removeBrowser: (browserId: string) => Promise<void>,\n  handleUnhealthyBrowser: (browserId: string) => Promise<void>,\n  launchNewBrowser: () => Promise<{ browser: Browser; instance: InternalBrowserInstance }>\n): Promise<void> {\n  await performMaintenanceWrapper(\n    () => maintenance.performMaintenance({\n      browsers,\n      options,\n      removeBrowser,\n      handleUnhealthyBrowser,\n      launchNewBrowser\n    })\n  );\n}\n\n/**\n * Remove browser from pool\n */\nexport async function removeBrowserFromPool(\n  browserId: string,\n  browsers: Map<string, InternalBrowserInstance>,\n  healthMonitor: BrowserHealthMonitor,\n  maintenance: BrowserPoolMaintenance,\n  emitEvent: (event: string, data: any) => void\n): Promise<void> {\n  await handleRemoveBrowser(\n    browserId,\n    (id) => maintenance.removeBrowser(id, browsers, healthMonitor),\n    (id) => emitEvent('browser:removed', { browserId: id })\n  );\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-public-methods.ts","messages":[{"ruleId":"require-await","severity":2,"message":"Async function 'createPage' has no 'await' expression.","line":29,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":29,"endColumn":33},{"ruleId":"require-await","severity":2,"message":"Async function 'closePage' has no 'await' expression.","line":40,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":40,"endColumn":32},{"ruleId":"require-await","severity":2,"message":"Async function 'healthCheck' has no 'await' expression.","line":52,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":52,"endColumn":34},{"ruleId":"max-params","severity":2,"message":"Async function 'recycleBrowser' has too many parameters (5). Maximum allowed is 4.","line":62,"column":8,"nodeType":"FunctionDeclaration","messageId":"exceed","endLine":62,"endColumn":37},{"ruleId":"require-await","severity":2,"message":"Async function 'cleanupIdle' has no 'await' expression.","line":93,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingAwait","endLine":93,"endColumn":34},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable number value in conditional. Please handle the nullish/zero/NaN cases explicitly.","line":119,"column":7,"nodeType":"MemberExpression","messageId":"conditionErrorNullableNumber","endLine":119,"endColumn":37,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3082,3112],"text":"newOptions.healthCheckInterval != null"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultZero","fix":{"range":[3082,3112],"text":"newOptions.healthCheckInterval ?? 0"},"desc":"Explicitly treat nullish value the same as 0 (`value ?? 0`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3082,3112],"text":"Boolean(newOptions.healthCheckInterval)"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Pool Public Methods\n * @module puppeteer/pool/browser-pool-public-methods\n */\n\nimport type { Page } from 'puppeteer';\nimport { createLogger } from '../../utils/logger.js';\nimport type { \n  BrowserInstance,\n  BrowserPoolOptions,\n  PoolMetrics,\n} from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\nimport { BrowserPoolMaintenance } from './browser-pool-maintenance.js';\nimport { \n  createPage as createBrowserPage,\n  closePage as closeBrowserPage,\n  listBrowsers,\n} from './browser-pool-operations.js';\nimport { getPoolMetrics } from './browser-pool-metrics.js';\nimport { configurePoolOptions } from './browser-pool-config.js';\n\nconst logger = createLogger('browser-pool-public-methods');\n\n/**\n * Create a new page in a browser\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport async function createPage(\n  browserId: string, \n  sessionId: string,\n  browsers: Map<string, InternalBrowserInstance>\n): Promise<Page> {\n  return createBrowserPage(browserId, sessionId, browsers);\n}\n\n/**\n * Close a page in a browser\n */\nexport async function closePage(\n  browserId: string, \n  sessionId: string,\n  browsers: Map<string, InternalBrowserInstance>\n): Promise<void> {\n  return closeBrowserPage(browserId, sessionId, browsers);\n}\n\n/**\n * Perform health check on all browsers\n * @nist si-4 \"Information system monitoring\"\n */\nexport async function healthCheck(\n  maintenance: BrowserPoolMaintenance,\n  browsers: Map<string, InternalBrowserInstance>\n): Promise<Map<string, boolean>> {\n  return maintenance.healthCheck(browsers);\n}\n\n/**\n * Recycle a browser instance\n */\nexport async function recycleBrowser(\n  browserId: string,\n  browsers: Map<string, InternalBrowserInstance>,\n  options: BrowserPoolOptions,\n  maintenance: BrowserPoolMaintenance,\n  removeBrowser: (browserId: string) => Promise<void>\n): Promise<void> {\n  try {\n    await maintenance.recycleBrowser(\n      browserId,\n      browsers,\n      options\n    );\n  } catch (error) {\n    logger.error({ browserId, error }, 'Failed to recycle browser');\n    await removeBrowser(browserId);\n  }\n}\n\n/**\n * List all browser instances\n */\nexport function listBrowsersPublic(\n  browsers: Map<string, InternalBrowserInstance>\n): BrowserInstance[] {\n  return listBrowsers(browsers);\n}\n\n/**\n * Clean up idle browsers\n */\nexport async function cleanupIdle(\n  maintenance: BrowserPoolMaintenance,\n  browsers: Map<string, InternalBrowserInstance>,\n  options: BrowserPoolOptions,\n  removeBrowser: (browserId: string) => Promise<void>\n): Promise<number> {\n  return maintenance.cleanupIdle(\n    browsers,\n    options,\n    removeBrowser\n  );\n}\n\n/**\n * Configure pool options\n * @nist cm-7 \"Least functionality\"\n */\nexport function configure(\n  currentOptions: BrowserPoolOptions,\n  newOptions: Partial<BrowserPoolOptions>,\n  maintenance: BrowserPoolMaintenance,\n  performMaintenance: () => Promise<void>\n): BrowserPoolOptions {\n  const updatedOptions = configurePoolOptions(currentOptions, newOptions);\n  \n  // Restart maintenance if interval changed\n  if (newOptions.healthCheckInterval) {\n    maintenance.stopMaintenance();\n    maintenance.startMaintenance(\n      performMaintenance,\n      60000\n    );\n  }\n  \n  return updatedOptions;\n}\n\n/**\n * Get browser instance by ID\n * @nist ac-3 \"Access enforcement\"\n */\nexport function getBrowser(\n  browserId: string,\n  browsers: Map<string, InternalBrowserInstance>\n): BrowserInstance | undefined {\n  return browsers.get(browserId);\n}\n\n/**\n * Get pool metrics\n * @nist au-3 \"Content of audit records\"\n */\nexport function getMetrics(\n  browsers: Map<string, InternalBrowserInstance>,\n  maxBrowsers: number\n): PoolMetrics {\n  return getPoolMetrics(browsers, maxBrowsers);\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool-shutdown.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-pool.ts","messages":[{"ruleId":"require-await","severity":2,"message":"Async method 'acquireBrowser' has no 'await' expression.","line":94,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":94,"endColumn":23},{"ruleId":"require-await","severity":2,"message":"Async method 'releaseBrowser' has no 'await' expression.","line":111,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":111,"endColumn":23},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'releaseBrowser' has no 'await' expression.","line":111,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":111,"endColumn":23},{"ruleId":"require-await","severity":2,"message":"Async method 'createAndAcquireBrowser' has no 'await' expression.","line":150,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":150,"endColumn":40},{"ruleId":"require-await","severity":2,"message":"Async method 'launchNewBrowser' has no 'await' expression.","line":177,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":177,"endColumn":33},{"ruleId":"require-await","severity":2,"message":"Async method 'createPage' has no 'await' expression.","line":237,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":237,"endColumn":19},{"ruleId":"require-await","severity":2,"message":"Async method 'closePage' has no 'await' expression.","line":244,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":244,"endColumn":18},{"ruleId":"require-await","severity":2,"message":"Async method 'healthCheck' has no 'await' expression.","line":252,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":252,"endColumn":20},{"ruleId":"require-await","severity":2,"message":"Async method 'recycleBrowser' has no 'await' expression.","line":259,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":259,"endColumn":23},{"ruleId":"require-await","severity":2,"message":"Async method 'cleanupIdle' has no 'await' expression.","line":279,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":279,"endColumn":20}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Pool Implementation\n * @module puppeteer/pool/browser-pool\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n * @nist ac-12 \"Session termination\"\n * @nist au-3 \"Content of audit records\"\n */\n\nimport type { Browser, Page } from 'puppeteer';\nimport { EventEmitter } from 'events';\nimport type { \n  BrowserPool as IBrowserPool,\n  BrowserInstance,\n  BrowserPoolOptions,\n  PoolMetrics,\n} from '../interfaces/browser-pool.interface.js';\nimport { BrowserHealthMonitor } from './browser-health.js';\nimport { BrowserQueue } from './browser-queue.js';\nimport { \n  BrowserPoolMaintenance,\n  type InternalBrowserInstance \n} from './browser-pool-maintenance.js';\nimport { releaseBrowser } from './browser-pool-acquisition-handlers.js';\nimport {\n  handleUnhealthyBrowserDelegate,\n  performPoolMaintenance,\n  removeBrowserFromPool,\n} from './browser-pool-private-methods.js';\nimport { acquireBrowserFacade } from './browser-pool-facade.js';\nimport {\n  createPage,\n  closePage,\n  healthCheck,\n  recycleBrowser,\n  listBrowsersPublic,\n  cleanupIdle,\n  configure,\n  getBrowser,\n  getMetrics,\n} from './browser-pool-public-methods.js';\nimport {\n  initializeBrowserPool,\n  initializePoolWithBrowsers,\n  shutdownBrowserPool,\n  createAndAcquireNewBrowser,\n  queueBrowserAcquisition,\n  launchBrowser,\n  createBrowserPoolHelpers,\n} from './browser-pool-lifecycle.js';\n\n/**\n * Browser pool implementation\n * @nist ac-3 \"Access enforcement\"\n * @nist ac-4 \"Information flow enforcement\"\n */\nexport class BrowserPool extends EventEmitter implements IBrowserPool {\n  private options: BrowserPoolOptions;\n  private browsers: Map<string, InternalBrowserInstance>;\n  private healthMonitor: BrowserHealthMonitor;\n  private queue: BrowserQueue;\n  private maintenance: BrowserPoolMaintenance;\n  private isShuttingDown = false;\n\n  constructor(options: Partial<BrowserPoolOptions> = {}) {\n    super();\n    const components = initializeBrowserPool(\n      this,\n      options,\n      () => createBrowserPoolHelpers(this.browsers, this.options, (event, data) => this.emit(event, data)).findIdleBrowser(),\n      () => this.performMaintenance()\n    );\n    \n    this.options = components.options;\n    this.browsers = components.browsers;\n    this.healthMonitor = components.healthMonitor;\n    this.queue = components.queue;\n    this.maintenance = components.maintenance;\n  }\n\n  /**\n   * Initialize the pool\n   * @nist ac-3 \"Access enforcement\"\n   */\n  async initialize(): Promise<void> {\n    await initializePoolWithBrowsers(this, this.options.maxBrowsers, () => this.launchNewBrowser());\n  }\n\n  /**\n   * Acquire a browser for a session\n   * @nist ac-3 \"Access enforcement\"\n   * @nist ac-4 \"Information flow enforcement\"\n   */\n  async acquireBrowser(sessionId: string): Promise<BrowserInstance> {\n    const helpers = createBrowserPoolHelpers(this.browsers, this.options, (event, data) => this.emit(event, data));\n    return acquireBrowserFacade(\n      sessionId,\n      this.isShuttingDown,\n      helpers.findIdleBrowser,\n      helpers.activateBrowser,\n      (sid) => this.createAndAcquireBrowser(sid),\n      helpers.canCreateNewBrowser,\n      (sid) => this.queueAcquisition(sid)\n    );\n  }\n\n  /**\n   * Release a browser back to the pool\n   * @nist ac-12 \"Session termination\"\n   */\n  async releaseBrowser(browserId: string): Promise<void> {\n    releaseBrowser(\n      browserId,\n      this.browsers,\n      this.queue,\n      (id) => this.emit('browser:released', { browserId: id })\n    );\n  }\n\n  /**\n   * Get browser instance by ID\n   * @nist ac-3 \"Access enforcement\"\n   */\n  getBrowser(browserId: string): BrowserInstance | undefined {\n    return getBrowser(browserId, this.browsers);\n  }\n\n  /**\n   * Get pool metrics\n   * @nist au-3 \"Content of audit records\"\n   */\n  getMetrics(): PoolMetrics {\n    return getMetrics(this.browsers, this.options.maxBrowsers);\n  }\n\n  /**\n   * Shutdown the pool\n   * @nist ac-12 \"Session termination\"\n   */\n  async shutdown(): Promise<void> {\n    this.isShuttingDown = true;\n    await shutdownBrowserPool(this.browsers, this.healthMonitor, this.queue, this.maintenance);\n  }\n\n\n  /**\n   * Create and acquire a new browser\n   * @private\n   */\n  private async createAndAcquireBrowser(sessionId: string): Promise<BrowserInstance> {\n    return createAndAcquireNewBrowser(\n      sessionId,\n      this.options,\n      this.browsers,\n      this.healthMonitor,\n      (browserId) => this.handleUnhealthyBrowser(browserId),\n      (event, data) => this.emit(event, data)\n    );\n  }\n\n  /**\n   * Queue a browser acquisition request\n   * @private\n   */\n  private queueAcquisition(sessionId: string): Promise<BrowserInstance> {\n    return queueBrowserAcquisition(\n      sessionId,\n      this.queue,\n      this.options.acquisitionTimeout ?? 30000\n    );\n  }\n\n  /**\n   * Launch a new browser\n   * @private\n   */\n  private async launchNewBrowser(): Promise<{ browser: Browser; instance: InternalBrowserInstance }> {\n    return launchBrowser(\n      this.options,\n      this.browsers,\n      this.healthMonitor,\n      (browserId) => this.handleUnhealthyBrowser(browserId),\n      (event, data) => this.emit(event, data)\n    );\n  }\n\n  /**\n   * Handle unhealthy browser\n   * @private\n   */\n  private async handleUnhealthyBrowser(browserId: string): Promise<void> {\n    await handleUnhealthyBrowserDelegate(\n      browserId,\n      this.browsers,\n      this.maintenance,\n      this.healthMonitor,\n      this.options,\n      (event, data) => this.emit(event, data),\n      (id) => this.handleUnhealthyBrowser(id)\n    );\n  }\n\n\n  /**\n   * Perform pool maintenance\n   * @private\n   */\n  private async performMaintenance(): Promise<void> {\n    await performPoolMaintenance(\n      this.browsers,\n      this.options,\n      this.maintenance,\n      (browserId) => this.removeBrowser(browserId),\n      (browserId) => this.handleUnhealthyBrowser(browserId),\n      () => this.launchNewBrowser()\n    );\n  }\n\n  /**\n   * Remove a browser from the pool\n   * @private\n   */\n  private async removeBrowser(browserId: string): Promise<void> {\n    await removeBrowserFromPool(\n      browserId,\n      this.browsers,\n      this.healthMonitor,\n      this.maintenance,\n      (event, data) => this.emit(event, data)\n    );\n  }\n\n  /**\n   * Create a new page in a browser\n   * @nist ac-4 \"Information flow enforcement\"\n   */\n  async createPage(browserId: string, sessionId: string): Promise<Page> {\n    return createPage(browserId, sessionId, this.browsers);\n  }\n\n  /**\n   * Close a page in a browser\n   */\n  async closePage(browserId: string, sessionId: string): Promise<void> {\n    return closePage(browserId, sessionId, this.browsers);\n  }\n\n  /**\n   * Perform health check on all browsers\n   * @nist si-4 \"Information system monitoring\"\n   */\n  async healthCheck(): Promise<Map<string, boolean>> {\n    return healthCheck(this.maintenance, this.browsers);\n  }\n\n  /**\n   * Recycle a browser instance\n   */\n  async recycleBrowser(browserId: string): Promise<void> {\n    return recycleBrowser(\n      browserId,\n      this.browsers,\n      this.options,\n      this.maintenance,\n      (id) => this.removeBrowser(id)\n    );\n  }\n\n  /**\n   * List all browser instances\n   */\n  listBrowsers(): BrowserInstance[] {\n    return listBrowsersPublic(this.browsers);\n  }\n\n  /**\n   * Clean up idle browsers\n   */\n  async cleanupIdle(): Promise<number> {\n    return cleanupIdle(\n      this.maintenance,\n      this.browsers,\n      this.options,\n      (browserId) => this.removeBrowser(browserId)\n    );\n  }\n\n  /**\n   * Configure pool options\n   * @nist cm-7 \"Least functionality\"\n   */\n  configure(options: Partial<BrowserPoolOptions>): void {\n    this.options = configure(\n      this.options,\n      options,\n      this.maintenance,\n      () => this.performMaintenance()\n    );\n  }\n\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-queue.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/puppeteer/pool/browser-utils.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":51,"column":37,"nodeType":"MemberExpression","messageId":"conditionErrorObject","endLine":51,"endColumn":56}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser utility functions\n * @module puppeteer/pool/browser-utils\n */\n\nimport { Browser, LaunchOptions } from 'puppeteer';\nimport * as puppeteer from 'puppeteer';\nimport type { BrowserInstance, BrowserPoolOptions } from '../interfaces/browser-pool.interface.js';\nimport type { InternalBrowserInstance } from './browser-pool-maintenance.js';\nimport { createLogger } from '../../utils/logger.js';\n\nconst logger = createLogger('browser-utils');\n\n/**\n * Launch a new browser instance\n */\nexport async function launchBrowser(options: BrowserPoolOptions): Promise<{ browser: Browser; instance: BrowserInstance }> {\n  const launchOptions: LaunchOptions = {\n    ...options.launchOptions,\n    handleSIGINT: false,\n    handleSIGTERM: false,\n    handleSIGHUP: false,\n  };\n\n  const browser = await puppeteer.launch(launchOptions);\n  \n  // Verify browser is working\n  const version = await browser.version();\n  \n  const instance: BrowserInstance = {\n    id: `browser-${Date.now()}-${Math.random().toString(36).substring(7)}`,\n    browser,\n    createdAt: new Date(),\n    lastUsedAt: new Date(),\n    useCount: 0,\n    pageCount: 0,\n  };\n  \n  logger.debug({ browserId: instance.id, version }, 'Browser launched successfully');\n  \n  return { browser, instance };\n}\n\n/**\n * Check if browser has been idle too long\n */\nexport function isIdleTooLong(\n  instance: InternalBrowserInstance,\n  maxIdleTimeMs: number\n): boolean {\n  if (instance.state !== 'idle' || !instance.lastUsedAt) {\n    return false;\n  }\n  \n  return Date.now() - instance.lastUsedAt.getTime() > maxIdleTimeMs;\n}\n\n/**\n * Check if browser needs restart\n */\nexport function needsRestart(instance: InternalBrowserInstance): boolean {\n  return instance.errorCount > 3 || instance.useCount > 100;\n}\n\n/**\n * Close browser\n */\nexport async function closeBrowser(browser: Browser): Promise<void> {\n  try {\n    await browser.close();\n  } catch (error) {\n    // Browser might already be closed\n    logger.debug({ error }, 'Error closing browser - might already be closed');\n  }\n}\n\n/**\n * Restart browser\n */\nexport async function restartBrowser(\n  _instance: InternalBrowserInstance,\n  options: BrowserPoolOptions\n): Promise<Browser> {\n  const { browser } = await launchBrowser(options);\n  return browser;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/api-keys.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/context-action-handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":118,"column":13,"nodeType":"MemberExpression","messageId":"conditionErrorNullableString","endLine":118,"endColumn":25,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[3888,3900],"text":"(result.error != null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[3888,3900],"text":"(result.error ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[3888,3900],"text":"(Boolean(result.error))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Context action execution handlers\n * @module routes/context-action-handlers\n * @nist ac-3 \"Access enforcement\"\n * @nist au-2 \"Audit events\"\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '../core/errors/app-error.js';\nimport { logDataAccess, createLogger } from '../utils/logger.js';\nimport { ContextStorage } from './context-storage.js';\nimport { getPageManager } from '../puppeteer/pages/page-manager.js';\nimport { BrowserActionExecutor, validateAction } from '../puppeteer/actions/index.js';\nimport type { BrowserPool } from '../puppeteer/interfaces/browser-pool.interface.js';\nimport type { \n  BrowserAction, \n  ActionContext \n} from '../puppeteer/interfaces/action-executor.interface.js';\n\nconst logger = createLogger('routes:context-action-handlers');\n\n/**\n * Context action execution handlers\n * @nist ac-3 \"Access enforcement\"\n */\nexport class ContextActionHandlers {\n  private storage: ContextStorage;\n  private browserPool?: BrowserPool;\n  private actionExecutor: BrowserActionExecutor;\n\n  constructor(browserPool?: BrowserPool) {\n    this.storage = new ContextStorage();\n    this.browserPool = browserPool;\n    \n    // Create action executor with page manager if browser pool is available\n    const pageManager = browserPool ? getPageManager(browserPool) : undefined;\n    this.actionExecutor = new BrowserActionExecutor(pageManager);\n  }\n\n  /**\n   * Execute action in a context\n   * POST /v1/contexts/:contextId/execute\n   * @nist au-2 \"Audit events\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  executeAction = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      if (!this.browserPool) {\n        throw new AppError('Browser pool not available', 503);\n      }\n\n      const { contextId } = req.params;\n      if (contextId === null || contextId === '') {\n        throw new AppError('Context ID is required', 400);\n      }\n\n      // Verify context exists and user has access\n      await this.storage.getContext(contextId as string, req.user.userId, req.user.roles);\n\n      // Parse and validate browser action\n      const browserAction = req.body as BrowserAction;\n      \n      // Validate action structure\n      const validationResult = validateAction(browserAction);\n      if (!validationResult.valid) {\n        throw new AppError(\n          `Invalid action: ${validationResult.errors.map(e => e.message).join(', ')}`,\n          400\n        );\n      }\n\n      // Create action context\n      const actionContext: ActionContext = {\n        sessionId: req.user.sessionId || req.user.userId,\n        contextId: contextId as string,\n        userId: req.user.userId,\n        metadata: {\n          userAgent: req.get('user-agent'),\n          ip: req.ip,\n          timestamp: new Date().toISOString(),\n        },\n      };\n\n      // Update context last used timestamp\n      this.storage.touchContext(contextId as string, req.user.userId, req.user.roles);\n\n      // Log action execution\n      await logDataAccess('WRITE', `context/${contextId}`, {\n        userId: req.user.userId,\n        action: 'execute_browser_action',\n        actionType: browserAction.type,\n        pageId: browserAction.pageId,\n      });\n\n      logger.info('Executing browser action', {\n        sessionId: actionContext.sessionId,\n        contextId: actionContext.contextId,\n        userId: req.user.userId,\n        actionType: browserAction.type,\n        pageId: browserAction.pageId,\n      });\n\n      // Execute action using action executor\n      const result = await this.actionExecutor.execute(browserAction, actionContext);\n\n      // Return result\n      res.json({\n        success: result.success,\n        data: {\n          ...result,\n          contextId,\n          executedAt: result.timestamp.toISOString(),\n        },\n        ...(result.error && { error: result.error }),\n      });\n\n    } catch (error) {\n      logger.error('Action execution failed', {\n        contextId: req.params.contextId,\n        userId: req.user?.userId,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      });\n      next(error);\n    }\n  })();\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/context-handlers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":154,"column":15,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":154,"endColumn":20},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":236,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":236,"endColumn":19},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":240,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":240,"endColumn":16},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":244,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":244,"endColumn":15},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":1,"message":"Missing return type on function.","line":248,"column":3,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":248,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Context route handlers\n * @module routes/context-handlers\n * @nist ac-3 \"Access enforcement\"\n * @nist au-2 \"Audit events\"\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '../core/errors/app-error.js';\nimport { ContextStorage } from './context-storage.js';\nimport { contextConfigSchema } from './context-validators.js';\nimport { getPageManager } from '../puppeteer/pages/page-manager.js';\nimport type { BrowserPool } from '../puppeteer/interfaces/browser-pool.interface.js';\nimport { ContextPageHandlers } from './context-page-handlers.js';\nimport { ContextActionHandlers } from './context-action-handlers.js';\n\n/**\n * Context route handlers\n * @nist ac-3 \"Access enforcement\"\n */\nexport class ContextHandlers {\n  private storage: ContextStorage;\n  private browserPool?: BrowserPool;\n  private pageHandlers: ContextPageHandlers;\n  private actionHandlers: ContextActionHandlers;\n\n  constructor(browserPool?: BrowserPool) {\n    this.storage = new ContextStorage();\n    this.browserPool = browserPool;\n    this.pageHandlers = new ContextPageHandlers(browserPool);\n    this.actionHandlers = new ContextActionHandlers(browserPool);\n  }\n\n  /**\n   * Create a new browser context\n   * POST /v1/contexts\n   * @nist au-2 \"Audit events\"\n   */\n  createContext = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      // Validate request body\n      const config = contextConfigSchema.parse(req.body);\n\n      // Create context\n      const context = await this.storage.createContext(req.user.userId, config);\n\n      // If browser pool is available and createPage is requested, create initial page\n      let pageInfo;\n      if (this.browserPool && req.body.createPage !== false) {\n        try {\n          const pageManager = getPageManager(this.browserPool);\n          \n          // Acquire browser for this session\n          const browser = await this.browserPool.acquireBrowser(req.user.sessionId || req.user.userId);\n          \n          // Create initial page with context configuration\n          const pageOptions = {\n            viewport: config.viewport,\n            userAgent: config.userAgent,\n            extraHeaders: config.extraHTTPHeaders,\n            javaScriptEnabled: config.javaScriptEnabled,\n            bypassCSP: config.bypassCSP,\n            ignoreHTTPSErrors: config.ignoreHTTPSErrors,\n          };\n\n          pageInfo = await pageManager.createPage(\n            context.id,\n            req.user.sessionId || req.user.userId,\n            browser.id,\n            pageOptions\n          );\n        } catch (pageError) {\n          // Log but don't fail context creation if page creation fails\n          console.warn('Failed to create initial page for context:', pageError);\n        }\n      }\n\n      res.status(201).json({\n        success: true,\n        data: {\n          ...context,\n          ...(pageInfo && { page: pageInfo }),\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  })();\n\n  /**\n   * Get all contexts for current user\n   * GET /v1/contexts\n   * @nist au-2 \"Audit events\"\n   */\n  listContexts = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      const userContextList = await this.storage.getUserContexts(req.user.userId);\n\n      res.json({\n        success: true,\n        data: userContextList,\n      });\n    } catch (error) {\n      next(error);\n    }\n  })();\n\n  /**\n   * Get a specific context\n   * GET /v1/contexts/:contextId\n   * @nist au-2 \"Audit events\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  getContext = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      const { contextId } = req.params;\n      if (contextId === null || contextId === '') {\n        throw new AppError('Context ID is required', 400);\n      }\n      const context = await this.storage.getContext(contextId as string, req.user.userId, req.user.roles);\n\n      // Get associated pages if browser pool is available\n      let pages: unknown[] = [];\n      if (this.browserPool) {\n        try {\n          const pageManager = getPageManager(this.browserPool);\n          pages = await pageManager.listPagesForContext(\n            contextId as string,\n            req.user.sessionId || req.user.userId\n          );\n        } catch (pageError) {\n          // Log but don't fail context retrieval if page listing fails\n          console.warn('Failed to list pages for context:', pageError);\n          pages = [];\n        }\n      }\n\n      res.json({\n        success: true,\n        data: {\n          ...context,\n          ...(pages && { pages }),\n        },\n      });\n    } catch (error) {\n      next(error);\n    }\n  })();\n\n  /**\n   * Update a context configuration\n   * PATCH /v1/contexts/:contextId\n   * @nist au-2 \"Audit events\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  updateContext = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      const { contextId } = req.params;\n      if (contextId === null || contextId === '') {\n        throw new AppError('Context ID is required', 400);\n      }\n\n      // Validate partial update\n      const updates = contextConfigSchema.partial().parse(req.body);\n\n      // Update context\n      const context = await this.storage.updateContext(contextId as string, updates, req.user.userId, req.user.roles);\n\n      res.json({\n        success: true,\n        data: context,\n      });\n    } catch (error) {\n      next(error);\n    }\n  })();\n\n  /**\n   * Delete a context\n   * DELETE /v1/contexts/:contextId\n   * @nist au-2 \"Audit events\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  deleteContext = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      const { contextId } = req.params;\n      if (contextId === null || contextId === '') {\n        throw new AppError('Context ID is required', 400);\n      }\n\n      // Clean up associated pages if browser pool is available\n      if (this.browserPool) {\n        try {\n          const pageManager = getPageManager(this.browserPool);\n          await pageManager.closePagesForContext(\n            contextId as string\n          );\n        } catch (pageError) {\n          // Log but don't fail context deletion if page cleanup fails\n          console.warn('Failed to clean up pages for context:', pageError);\n        }\n      }\n\n      await this.storage.deleteContext(contextId as string, req.user.userId, req.user.roles);\n\n      res.json({\n        success: true,\n        message: 'Context deleted successfully',\n      });\n    } catch (error) {\n      next(error);\n    }\n  })();\n\n  // Delegate methods to handlers\n  executeAction = (req: Request, res: Response, next: NextFunction) => {\n    this.actionHandlers.executeAction(req, res, next);\n  };\n\n  getMetrics = (req: Request, res: Response, next: NextFunction) => {\n    this.pageHandlers.getMetrics(req, res, next);\n  };\n  \n  listPages = (req: Request, res: Response, next: NextFunction) => {\n    this.pageHandlers.listPages(req, res, next);\n  };\n  \n  createPage = (req: Request, res: Response, next: NextFunction) => {\n    this.pageHandlers.createPage(req, res, next);\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/context-page-handlers.ts","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":86,"column":74,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":86,"endColumn":83,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2581,2582],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":86,"column":92,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":86,"endColumn":101,"suggestions":[{"messageId":"suggestOptionalChain","fix":{"range":[2599,2600],"text":"?"},"desc":"Consider using the optional chain operator `?.` instead. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator."}]},{"ruleId":"@typescript-eslint/no-non-null-assertion","severity":2,"message":"Forbidden non-null assertion.","line":89,"column":42,"nodeType":"TSNonNullExpression","messageId":"noNonNull","endLine":89,"endColumn":51}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Context page-related route handlers\n * @module routes/context-page-handlers\n * @nist ac-3 \"Access enforcement\"\n * @nist au-2 \"Audit events\"\n */\n\nimport { Request, Response, NextFunction } from 'express';\nimport { AppError } from '../core/errors/app-error.js';\nimport { getPageManager } from '../puppeteer/pages/page-manager.js';\nimport { ContextStorage } from './context-storage.js';\nimport type { BrowserPool } from '../puppeteer/interfaces/browser-pool.interface.js';\nimport { validatePageRequest, buildPageOptions, getUserSessionId } from './context-page-helpers.js';\n\n/**\n * Context page handlers\n * @nist ac-3 \"Access enforcement\"\n */\nexport class ContextPageHandlers {\n  private storage: ContextStorage;\n  private browserPool?: BrowserPool;\n\n  constructor(browserPool?: BrowserPool) {\n    this.storage = new ContextStorage();\n    this.browserPool = browserPool;\n  }\n\n  /**\n   * List pages for a context\n   * GET /v1/contexts/:contextId/pages\n   * @nist au-2 \"Audit events\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  listPages = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      if (!this.browserPool) {\n        throw new AppError('Browser pool not available', 503);\n      }\n\n      const { contextId } = req.params;\n      if (contextId === null || contextId === '') {\n        throw new AppError('Context ID is required', 400);\n      }\n\n      // Verify context exists and user has access\n      await this.storage.getContext(contextId as string, req.user.userId, req.user.roles);\n\n      // Get pages for context\n      const pageManager = getPageManager(this.browserPool);\n      const pages = await pageManager.listPagesForContext(\n        contextId as string,\n        req.user.sessionId || req.user.userId\n      );\n\n      res.json({\n        success: true,\n        data: pages,\n      });\n    } catch (error) {\n      next(error);\n    }\n  })();\n\n  /**\n   * Create a new page in a context\n   * POST /v1/contexts/:contextId/pages\n   * @nist au-2 \"Audit events\"\n   * @nist ac-3 \"Access enforcement\"\n   */\n  createPage = (req: Request, res: Response, next: NextFunction): void => void (async () => {\n    try {\n      // Validate request\n      validatePageRequest(req);\n\n      if (!this.browserPool) {\n        throw new AppError('Browser pool not available', 503);\n      }\n\n      const { contextId } = req.params;\n\n      // Verify context exists and user has access\n      const context = await this.storage.getContext(contextId as string, req.user!.userId, req.user!.roles);\n\n      // Acquire browser for this session\n      const sessionId = getUserSessionId(req.user!);\n      const browser = await this.browserPool.acquireBrowser(sessionId);\n\n      // Create page with context configuration and optional overrides\n      const pageOptions = buildPageOptions(req.body, context.config);\n\n      const pageManager = getPageManager(this.browserPool);\n      const pageInfo = await pageManager.createPage(\n        contextId as string,\n        sessionId,\n        browser.id,\n        pageOptions\n      );\n\n      res.status(201).json({\n        success: true,\n        data: pageInfo,\n      });\n    } catch (error) {\n      next(error);\n    }\n  })();\n\n  /**\n   * Get context metrics\n   * GET /v1/contexts/:contextId/metrics\n   * @nist au-2 \"Audit events\"\n   */\n  getMetrics = (req: Request, res: Response, next: NextFunction): void => {\n    try {\n      if (!req.user) {\n        throw new AppError('Not authenticated', 401);\n      }\n\n      // Check if context exists and user has access\n      // Note: We're not using async/await here since this is synchronous\n      // In a real implementation, you'd want to verify access first\n      \n      // TODO: Integrate with actual metrics collection\n      const metrics = {\n        memory: {\n          used: Math.floor(Math.random() * 100) + 50, // MB\n          limit: 512, // MB\n        },\n        cpu: {\n          usage: Math.floor(Math.random() * 50) + 10, // %\n        },\n        network: {\n          requests: Math.floor(Math.random() * 1000),\n          bytesReceived: Math.floor(Math.random() * 10000000),\n          bytesSent: Math.floor(Math.random() * 1000000),\n        },\n        duration: Date.now() - new Date().getTime(), // ms - placeholder calculation\n      };\n\n      res.json({\n        success: true,\n        data: metrics,\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/context-page-helpers.ts","messages":[{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected nullable string value in conditional. Please handle the nullish/empty cases explicitly.","line":18,"column":8,"nodeType":"Identifier","messageId":"conditionErrorNullableString","endLine":18,"endColumn":17,"suggestions":[{"messageId":"conditionFixCompareNullish","fix":{"range":[411,421],"text":"(contextId == null)"},"desc":"Change condition to check for null/undefined (`value != null`)"},{"messageId":"conditionFixDefaultEmptyString","fix":{"range":[412,421],"text":"(contextId ?? \"\")"},"desc":"Explicitly treat nullish value the same as an empty string (`value ?? \"\"`)"},{"messageId":"conditionFixCastBoolean","fix":{"range":[411,421],"text":"(!Boolean(contextId))"},"desc":"Explicitly cast value to a boolean (`Boolean(value)`)"}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[611,614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[611,614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[633,636],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[633,636],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Helper functions for context page handlers\n * @module routes/context-page-helpers\n */\n\nimport type { Request } from 'express';\nimport { AppError } from '../core/errors/app-error.js';\n\n/**\n * Validate request for page creation\n */\nexport function validatePageRequest(req: Request): void {\n  if (!req.user) {\n    throw new AppError('Not authenticated', 401);\n  }\n\n  const { contextId } = req.params;\n  if (!contextId || contextId === '') {\n    throw new AppError('Context ID is required', 400);\n  }\n}\n\n/**\n * Build page options from request and context\n */\nexport function buildPageOptions(\n  requestBody: any,\n  contextConfig: any\n): {\n  viewport?: { width: number; height: number };\n  userAgent?: string;\n  extraHeaders?: Record<string, string>;\n  javaScriptEnabled?: boolean;\n  bypassCSP?: boolean;\n  ignoreHTTPSErrors?: boolean;\n} {\n  return {\n    viewport: requestBody.viewport ?? contextConfig.viewport,\n    userAgent: requestBody.userAgent ?? contextConfig.userAgent,\n    extraHeaders: requestBody.extraHeaders ?? contextConfig.extraHTTPHeaders,\n    javaScriptEnabled: requestBody.javaScriptEnabled ?? contextConfig.javaScriptEnabled,\n    bypassCSP: requestBody.bypassCSP ?? contextConfig.bypassCSP,\n    ignoreHTTPSErrors: requestBody.ignoreHTTPSErrors ?? contextConfig.ignoreHTTPSErrors,\n  };\n}\n\n/**\n * Get user session ID\n */\nexport function getUserSessionId(user: { sessionId?: string; userId: string }): string {\n  return user.sessionId ?? user.userId;\n}","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/context-storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/context-validators.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/contexts.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/health.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/routes/sessions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/server.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":198,"column":11,"nodeType":"CallExpression","endLine":198,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":200,"column":10,"nodeType":"CallExpression","endLine":200,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found readFileSync from package \"fs\" with non literal argument at index 0","line":207,"column":14,"nodeType":"CallExpression","endLine":207,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/store/api-key-store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/store/context-store.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_id' is assigned a value but never used.","line":99,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":99,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'createdAt' is assigned a value but never used.","line":99,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":99,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/store/in-memory-session-store.ts","messages":[],"suppressedMessages":[{"ruleId":"require-await","severity":2,"message":"Async method 'touch' has no 'await' expression.","line":183,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":183,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'touch' has no 'await' expression.","line":183,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":183,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"require-await","severity":2,"message":"Async method 'clear' has no 'await' expression.","line":206,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":206,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async method 'clear' has no 'await' expression.","line":206,"column":3,"nodeType":"FunctionExpression","messageId":"missingAwait","endLine":206,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/store/session-store.interface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/types/api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/types/express.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/types/grpc.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/types/index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/types/session.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/types/user.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/types/websocket.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/utils/logger.ts","messages":[],"suppressedMessages":[{"ruleId":"security/detect-non-literal-fs-filename","severity":1,"message":"Found mkdir from package \"fs/promises\" with non literal argument at index 0","line":149,"column":9,"nodeType":"CallExpression","endLine":149,"endColumn":48,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/auth-handler-apikey.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/auth-handler-messages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/auth-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/connection-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/context-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/message-handler-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/message-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/message-router.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/request-processor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/session-handler.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/src/ws/subscription-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/integration/contexts.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/integration/cross-protocol.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/integration/health.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/integration/mcp/full-flow.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'StdioClientTransport' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mcpClient' is defined but never used.","line":15,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":15,"endColumn":24},{"ruleId":"require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":17,"column":22,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":17,"endColumn":24},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":17,"column":22,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":17,"endColumn":24}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Integration tests for MCP full workflow\n * @module tests/integration/mcp/full-flow\n */\n\nimport { describe, it, expect, beforeAll, afterAll } from '@jest/globals';\nimport { MCPServer } from '../../../src/mcp/server.js';\nimport { sessionStore } from '../../../src/store/session-store.js';\nimport { contextStore } from '../../../src/store/context-store.js';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\n\ndescribe('MCP Full Integration Flow', () => {\n  let mcpServer: MCPServer;\n  let mcpClient: Client;\n  \n  beforeAll(async () => {\n    // Set up MCP server\n    process.env.MCP_TRANSPORT = 'stdio';\n    mcpServer = new MCPServer();\n    \n    // Note: In real integration tests, we would start the server and connect a client\n    // For now, we'll test the components directly\n  });\n  \n  afterAll(async () => {\n    try {\n      await mcpServer.stop();\n    } catch (error) {\n      // Server might not be started\n    }\n  });\n\n  describe('Complete Session Workflow', () => {\n    it('should handle session creation through MCP', async () => {\n      // 1. Create session via MCP tool\n      const sessionResult = await (mcpServer as any).createSessionTool({\n        username: 'testuser',\n        password: 'testpass',\n        duration: 3600,\n      });\n      \n      expect(sessionResult).toHaveProperty('content');\n      const sessionData = JSON.parse(sessionResult.content[0].text);\n      expect(sessionData).toHaveProperty('id');\n      expect(sessionData).toHaveProperty('userId', 'testuser');\n      \n      const sessionId = sessionData.id;\n      \n      // 2. Create browser context using the session\n      const contextResult = await (mcpServer as any).createBrowserContextTool({\n        sessionId,\n        options: {\n          headless: true,\n          viewport: { width: 1920, height: 1080 },\n        },\n      });\n      \n      expect(contextResult).toHaveProperty('content');\n      const contextData = JSON.parse(contextResult.content[0].text);\n      expect(contextData).toHaveProperty('contextId');\n      \n      // 3. Verify context was created in store\n      const context = await contextStore.get(contextData.contextId);\n      expect(context).toBeDefined();\n      expect(context?.sessionId).toBe(sessionId);\n      expect(context?.type).toBe('puppeteer');\n    });\n\n    it('should list sessions for a user', async () => {\n      // Create a test session first\n      const session = await sessionStore.create({\n        userId: 'testuser2',\n        username: 'testuser2',\n        roles: ['user'],\n        metadata: {},\n      });\n      \n      // List sessions via MCP\n      const listResult = await (mcpServer as any).listSessionsTool({\n        userId: 'testuser2',\n      });\n      \n      expect(listResult).toHaveProperty('content');\n      const sessions = JSON.parse(listResult.content[0].text);\n      expect(Array.isArray(sessions)).toBe(true);\n      expect(sessions.some((s: any) => s.id === session.id)).toBe(true);\n    });\n  });\n\n  describe('API Discovery', () => {\n    it('should provide complete API catalog', async () => {\n      const catalogResult = await (mcpServer as any).getApiCatalog();\n      \n      expect(catalogResult).toHaveProperty('contents');\n      const catalog = JSON.parse(catalogResult.contents[0].text);\n      \n      // Verify REST endpoints\n      expect(catalog.rest).toBeDefined();\n      expect(catalog.rest.endpoints).toContainEqual(\n        expect.objectContaining({\n          path: '/sessions',\n          methods: expect.arrayContaining(['GET', 'POST', 'DELETE']),\n        })\n      );\n      \n      // Verify gRPC services\n      expect(catalog.grpc).toBeDefined();\n      expect(catalog.grpc.services).toContainEqual(\n        expect.objectContaining({\n          name: 'SessionService',\n          methods: expect.arrayContaining(['CreateSession', 'GetSession']),\n        })\n      );\n      \n      // Verify WebSocket topics\n      expect(catalog.websocket).toBeDefined();\n      expect(catalog.websocket.topics).toContainEqual(\n        expect.objectContaining({\n          name: 'session-updates',\n        })\n      );\n    });\n\n    it('should provide system health status', async () => {\n      const healthResult = await (mcpServer as any).getSystemHealth();\n      \n      expect(healthResult).toHaveProperty('contents');\n      const health = JSON.parse(healthResult.contents[0].text);\n      \n      expect(health).toHaveProperty('status', 'healthy');\n      expect(health).toHaveProperty('uptime');\n      expect(health.services).toEqual({\n        rest: 'operational',\n        grpc: 'operational',\n        websocket: 'operational',\n        mcp: 'operational',\n      });\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle invalid session ID gracefully', async () => {\n      const result = await (mcpServer as any).createBrowserContextTool({\n        sessionId: 'invalid-session-id',\n        options: { headless: true },\n      });\n      \n      // The current implementation doesn't validate the session\n      // This test documents the current behavior\n      expect(result).toHaveProperty('content');\n      const data = JSON.parse(result.content[0].text);\n      expect(data).toHaveProperty('contextId');\n    });\n\n    it('should handle missing required parameters', async () => {\n      // Test with missing sessionId\n      await expect(\n        (mcpServer as any).createBrowserContextTool({\n          options: { headless: true },\n        })\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('Multi-Protocol Integration', () => {\n    it('should support API execution placeholder', async () => {\n      // Test the execute-api tool placeholder\n      const result = await (mcpServer as any).executeApiTool({\n        protocol: 'rest',\n        operation: {\n          method: 'GET',\n          endpoint: '/api/v1/health',\n        },\n      });\n      \n      expect(result).toHaveProperty('content');\n      const data = JSON.parse(result.content[0].text);\n      expect(data).toHaveProperty('status', 'pending');\n      expect(data).toHaveProperty('message', 'API execution not yet implemented');\n      expect(data).toHaveProperty('protocol', 'rest');\n    });\n  });\n\n  describe('Tool Schema Validation', () => {\n    it('should define proper input schemas for tools', () => {\n      // This test would verify that the tool schemas match the expected format\n      // Currently, we can't easily access the registered tool schemas\n      // This is a placeholder for when we implement schema validation\n      expect(mcpServer).toBeDefined();\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/integration/mcp/mcp-integration.test.ts","messages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":119,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":119,"endColumn":48},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":138,"column":59,"nodeType":"MemberExpression","messageId":"unsafeReturn","endLine":138,"endColumn":68},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":206,"column":70,"nodeType":"MemberExpression","messageId":"unsafeReturn","endLine":206,"endColumn":82}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Server Integration Test\n * @module tests/integration/mcp/mcp-integration\n * @description Integration test to verify MCP server instantiation and tool/resource registration\n */\n\nimport { jest } from '@jest/globals';\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport {\n  ListToolsRequestSchema,\n  ListResourcesRequestSchema,\n  CallToolRequestSchema,\n  ReadResourceRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport { MCPServer, createMCPServer } from '../../../src/mcp/server.js';\nimport { logger } from '../../../src/utils/logger.js';\n\n// Mock dependencies to avoid external connections\njest.mock('../../../src/utils/logger.js', () => ({\n  logger: {\n    info: jest.fn(),\n    error: jest.fn(),\n    warn: jest.fn(),\n    child: jest.fn(() => ({\n      info: jest.fn(),\n      error: jest.fn(),\n      warn: jest.fn(),\n      child: jest.fn(),\n    })),\n  },\n}));\n\njest.mock('../../../src/mcp/auth/user-service.js', () => ({\n  userService: {\n    authenticateUser: jest.fn().mockResolvedValue({\n      id: 'test-user-id',\n      username: 'testuser',\n      roles: ['user'],\n      metadata: {},\n    }),\n  },\n}));\n\njest.mock('../../../src/auth/jwt.js', () => ({\n  generateTokenPair: jest.fn().mockReturnValue({\n    accessToken: 'mock-access-token',\n    refreshToken: 'mock-refresh-token',\n    expiresIn: 3600,\n  }),\n}));\n\n// Mock WebSocket dependencies to prevent issues with logger\njest.mock('../../../src/ws/connection-manager.js', () => ({\n  WSConnectionManager: jest.fn().mockImplementation(() => ({\n    connections: new Map(),\n    addConnection: jest.fn(),\n    removeConnection: jest.fn(),\n    getConnection: jest.fn(),\n  })),\n}));\n\njest.mock('../../../src/ws/subscription-manager.js', () => ({\n  WSSubscriptionManager: jest.fn().mockImplementation(() => ({\n    subscriptions: new Map(),\n    subscribe: jest.fn(),\n    unsubscribe: jest.fn(),\n    publish: jest.fn(),\n  })),\n}));\n\n// Mock the WebSocketAdapter to prevent logger issues\njest.mock('../../../src/mcp/adapters/ws-adapter.js', () => ({\n  WebSocketAdapter: jest.fn().mockImplementation(() => ({\n    executeRequest: jest.fn(),\n    setupEventListeners: jest.fn(),\n  })),\n}));\n\ndescribe('MCP Server Integration Tests', () => {\n  let mcpServer: MCPServer;\n  let mockHandlers: Map<string, jest.Mock>;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockHandlers = new Map();\n    \n    // Mock the Server class from MCP SDK\n    jest.spyOn(Server.prototype, 'setRequestHandler').mockImplementation((schema: any, handler: any) => {\n      // Map schema to handler name\n      let schemaName = 'unknown';\n      if (schema === ListToolsRequestSchema) {\n        schemaName = 'listTools';\n      } else if (schema === CallToolRequestSchema) {\n        schemaName = 'callTool';\n      } else if (schema === ListResourcesRequestSchema) {\n        schemaName = 'listResources';\n      } else if (schema === ReadResourceRequestSchema) {\n        schemaName = 'readResource';\n      }\n      mockHandlers.set(schemaName, handler);\n      return undefined;\n    });\n    \n    // Create MCP server without protocol adapters\n    mcpServer = createMCPServer();\n  });\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  describe('Server Instantiation', () => {\n    it('should create MCP server instance successfully', () => {\n      expect(mcpServer).toBeInstanceOf(MCPServer);\n    });\n\n    it('should register all request handlers', () => {\n      // The server registers handlers in setupHandlers() and may call additional ones during initialization\n      expect(Server.prototype.setRequestHandler).toHaveBeenCalled();\n      expect(Server.prototype.setRequestHandler.mock.calls.length).toBeGreaterThanOrEqual(4);\n      \n      // Verify each handler is registered\n      expect(mockHandlers.has('listTools')).toBeTruthy();\n      expect(mockHandlers.has('callTool')).toBeTruthy();\n      expect(mockHandlers.has('listResources')).toBeTruthy();\n      expect(mockHandlers.has('readResource')).toBeTruthy();\n    });\n  });\n\n  describe('Tool Registration', () => {\n    it('should register all 6 tools', async () => {\n      const listToolsHandler = mockHandlers.get('listTools');\n      expect(listToolsHandler).toBeDefined();\n\n      const response = await listToolsHandler({});\n      expect(response.tools).toHaveLength(6);\n\n      const toolNames = response.tools.map((tool: any) => tool.name);\n      expect(toolNames).toEqual([\n        'execute-api',\n        'create-session',\n        'list-sessions',\n        'delete-session',\n        'create-browser-context',\n        'execute-in-context',\n      ]);\n    });\n\n    it('should have proper input schemas for each tool', async () => {\n      const listToolsHandler = mockHandlers.get('listTools');\n      const response = await listToolsHandler({});\n\n      // Verify execute-api tool\n      const executeApiTool = response.tools.find((t: any) => t.name === 'execute-api');\n      expect(executeApiTool).toBeDefined();\n      expect(executeApiTool.inputSchema.type).toBe('object');\n      expect(executeApiTool.inputSchema.properties).toHaveProperty('protocol');\n      expect(executeApiTool.inputSchema.properties).toHaveProperty('operation');\n      expect(executeApiTool.inputSchema.properties).toHaveProperty('auth');\n      expect(executeApiTool.inputSchema.required).toEqual(['protocol', 'operation']);\n\n      // Verify create-session tool\n      const createSessionTool = response.tools.find((t: any) => t.name === 'create-session');\n      expect(createSessionTool).toBeDefined();\n      expect(createSessionTool.inputSchema.properties).toHaveProperty('username');\n      expect(createSessionTool.inputSchema.properties).toHaveProperty('password');\n      expect(createSessionTool.inputSchema.properties).toHaveProperty('duration');\n      expect(createSessionTool.inputSchema.required).toEqual(['username', 'password']);\n\n      // Verify list-sessions tool\n      const listSessionsTool = response.tools.find((t: any) => t.name === 'list-sessions');\n      expect(listSessionsTool).toBeDefined();\n      expect(listSessionsTool.inputSchema.properties).toHaveProperty('userId');\n\n      // Verify delete-session tool\n      const deleteSessionTool = response.tools.find((t: any) => t.name === 'delete-session');\n      expect(deleteSessionTool).toBeDefined();\n      expect(deleteSessionTool.inputSchema.properties).toHaveProperty('sessionId');\n      expect(deleteSessionTool.inputSchema.required).toEqual(['sessionId']);\n\n      // Verify create-browser-context tool\n      const createBrowserContextTool = response.tools.find((t: any) => t.name === 'create-browser-context');\n      expect(createBrowserContextTool).toBeDefined();\n      expect(createBrowserContextTool.inputSchema.properties).toHaveProperty('sessionId');\n      expect(createBrowserContextTool.inputSchema.properties).toHaveProperty('options');\n      expect(createBrowserContextTool.inputSchema.required).toEqual(['sessionId']);\n\n      // Verify execute-in-context tool\n      const executeInContextTool = response.tools.find((t: any) => t.name === 'execute-in-context');\n      expect(executeInContextTool).toBeDefined();\n      expect(executeInContextTool.inputSchema.properties).toHaveProperty('contextId');\n      expect(executeInContextTool.inputSchema.properties).toHaveProperty('command');\n      expect(executeInContextTool.inputSchema.properties).toHaveProperty('parameters');\n      expect(executeInContextTool.inputSchema.required).toEqual(['contextId', 'command']);\n    });\n  });\n\n  describe('Resource Registration', () => {\n    it('should register both resources', async () => {\n      const listResourcesHandler = mockHandlers.get('listResources');\n      expect(listResourcesHandler).toBeDefined();\n\n      const response = await listResourcesHandler({});\n      expect(response.resources).toHaveLength(2);\n\n      const resourceUris = response.resources.map((resource: any) => resource.uri);\n      expect(resourceUris).toEqual(['api://catalog', 'api://health']);\n    });\n\n    it('should have proper metadata for each resource', async () => {\n      const listResourcesHandler = mockHandlers.get('listResources');\n      const response = await listResourcesHandler({});\n\n      // Verify API catalog resource\n      const catalogResource = response.resources.find((r: any) => r.uri === 'api://catalog');\n      expect(catalogResource).toBeDefined();\n      expect(catalogResource.name).toBe('API Catalog');\n      expect(catalogResource.description).toBe('Complete catalog of available APIs');\n      expect(catalogResource.mimeType).toBe('application/json');\n\n      // Verify health resource\n      const healthResource = response.resources.find((r: any) => r.uri === 'api://health');\n      expect(healthResource).toBeDefined();\n      expect(healthResource.name).toBe('System Health');\n      expect(healthResource.description).toBe('Current system health and status');\n      expect(healthResource.mimeType).toBe('application/json');\n    });\n  });\n\n  describe('Tool Execution', () => {\n    it('should handle tool execution requests', async () => {\n      const callToolHandler = mockHandlers.get('callTool');\n      expect(callToolHandler).toBeDefined();\n\n      // Test execute-api tool without adapters - should throw an error\n      await expect(callToolHandler({\n        params: {\n          name: 'execute-api',\n          arguments: {\n            protocol: 'rest',\n            operation: {\n              method: 'GET',\n              endpoint: '/health',\n            },\n          },\n        },\n      })).rejects.toThrow('REST adapter not initialized');\n    });\n\n    it('should log tool execution attempts', async () => {\n      const callToolHandler = mockHandlers.get('callTool');\n      \n      await callToolHandler({\n        params: {\n          name: 'list-sessions',\n          arguments: { userId: 'test-user' },\n        },\n      });\n\n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP tool execution',\n          tool: 'list-sessions',\n        })\n      );\n    });\n  });\n\n  describe('Resource Reading', () => {\n    it('should handle resource read requests', async () => {\n      const readResourceHandler = mockHandlers.get('readResource');\n      expect(readResourceHandler).toBeDefined();\n\n      // Test reading health resource\n      const healthResponse = await readResourceHandler({\n        params: { uri: 'api://health' },\n      });\n\n      expect(healthResponse.contents).toHaveLength(1);\n      expect(healthResponse.contents[0].uri).toBe('api://health');\n      expect(healthResponse.contents[0].mimeType).toBe('application/json');\n      \n      const healthData = JSON.parse(healthResponse.contents[0].text);\n      expect(healthData).toHaveProperty('status', 'healthy');\n      expect(healthData).toHaveProperty('services');\n      expect(healthData.services).toEqual({\n        rest: 'operational',\n        grpc: 'operational',\n        websocket: 'operational',\n        mcp: 'operational',\n      });\n\n      // Test reading catalog resource\n      const catalogResponse = await readResourceHandler({\n        params: { uri: 'api://catalog' },\n      });\n\n      expect(catalogResponse.contents).toHaveLength(1);\n      expect(catalogResponse.contents[0].uri).toBe('api://catalog');\n      expect(catalogResponse.contents[0].mimeType).toBe('application/json');\n      \n      const catalogData = JSON.parse(catalogResponse.contents[0].text);\n      expect(catalogData).toHaveProperty('rest');\n      expect(catalogData).toHaveProperty('grpc');\n      expect(catalogData).toHaveProperty('websocket');\n    });\n\n    it('should log resource access', async () => {\n      const readResourceHandler = mockHandlers.get('readResource');\n      \n      await readResourceHandler({\n        params: { uri: 'api://health' },\n      });\n\n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP resource access',\n          resource: 'api://health',\n        })\n      );\n    });\n  });\n\n  describe('Server with Protocol Adapters', () => {\n    it('should create MCP server with protocol adapters', () => {\n      const mockApp = {} as any;\n      const mockGrpcServer = {} as any;\n      const mockWsServer = {} as any;\n\n      const serverWithAdapters = createMCPServer({\n        app: mockApp,\n        grpcServer: mockGrpcServer,\n        wsServer: mockWsServer,\n      });\n\n      expect(serverWithAdapters).toBeInstanceOf(MCPServer);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle unknown tool requests', async () => {\n      const callToolHandler = mockHandlers.get('callTool');\n      \n      await expect(callToolHandler({\n        params: {\n          name: 'unknown-tool',\n          arguments: {},\n        },\n      })).rejects.toThrow('Unknown tool: unknown-tool');\n    });\n\n    it('should handle unknown resource requests', async () => {\n      const readResourceHandler = mockHandlers.get('readResource');\n      \n      await expect(readResourceHandler({\n        params: { uri: 'api://unknown' },\n      })).rejects.toThrow('Unknown resource: api://unknown');\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/integration/sessions.integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/setup-e2e.ts","messages":[],"suppressedMessages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":12,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":12,"endColumn":50,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":26,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":26,"endColumn":14,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[712,765],"text":""},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/setup-integration.ts","messages":[],"suppressedMessages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":8,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":8,"endColumn":28,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":10,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":10,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/setup.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-namespace","severity":2,"message":"ES2015 module syntax is preferred over namespaces.","line":25,"column":3,"nodeType":"TSModuleDeclaration","messageId":"moduleSyntaxIsPreferred","endLine":30,"endColumn":4,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":67,"column":17,"nodeType":"MemberExpression","endLine":67,"endColumn":33,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"security/detect-object-injection","severity":2,"message":"Generic Object Injection Sink","line":71,"column":17,"nodeType":"MemberExpression","endLine":71,"endColumn":28,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":102,"column":8,"nodeType":"MemberExpression","messageId":"unexpected","endLine":102,"endColumn":19,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":103,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":103,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":110,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":110,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":112,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":112,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":121,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":121,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":123,"column":3,"nodeType":"MemberExpression","messageId":"unexpected","endLine":123,"endColumn":15,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/auth/jwt.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/auth/middleware.test.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":119,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":119,"endColumn":34,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":121,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":121,"endColumn":36,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/grpc/interceptors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/grpc/session.service.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/mcp/auth.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'generateTokenPair' is defined but never used.","line":8,"column":25,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":42},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":645,"column":16,"nodeType":"MemberExpression","endLine":645,"endColumn":42},{"ruleId":"security/detect-object-injection","severity":2,"message":"Function Call Object Injection Sink","line":653,"column":16,"nodeType":"MemberExpression","endLine":653,"endColumn":42}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Authentication Bridge Tests\n * @module tests/unit/mcp/auth\n */\n\nimport { describe, it, expect, beforeEach, jest, afterEach } from '@jest/globals';\nimport { MCPAuthBridge, MCP_TOOL_PERMISSIONS, type AuthContext, type MCPAuthCredentials } from '../../../src/mcp/auth/mcp-auth.js';\nimport { generateToken, generateTokenPair } from '../../../src/auth/jwt.js';\nimport { apiKeyStore } from '../../../src/store/api-key-store.js';\nimport { InMemorySessionStore } from '../../../src/store/in-memory-session-store.js';\nimport { Permission } from '../../../src/auth/permissions.js';\nimport { AppError } from '../../../src/core/errors/app-error.js';\nimport * as logger from '../../../src/utils/logger.js';\nimport { pino } from 'pino';\n\n// Mock logger\njest.mock('../../../src/utils/logger.js', () => ({\n  logSecurityEvent: jest.fn().mockResolvedValue(undefined),\n  SecurityEventType: {\n    LOGIN_SUCCESS: 'LOGIN_SUCCESS',\n    LOGIN_FAILURE: 'LOGIN_FAILURE',\n    ACCESS_DENIED: 'ACCESS_DENIED',\n  },\n  logDataAccess: jest.fn().mockResolvedValue(undefined),\n}));\n\n// Mock config for JWT\njest.mock('../../../src/core/config.js', () => ({\n  config: {\n    JWT_SECRET: 'test-secret-key-for-testing-only-32-chars-long!!',\n    JWT_ALGORITHM: 'HS256',\n    JWT_EXPIRY: '15m',\n    JWT_REFRESH_EXPIRY: '7d',\n    NODE_ENV: 'test',\n  },\n}));\n\ndescribe('MCPAuthBridge', () => {\n  let authBridge: MCPAuthBridge;\n  let sessionStore: InMemorySessionStore;\n  let mockLogger: pino.Logger;\n  let originalEnv: NodeJS.ProcessEnv;\n\n  beforeAll(() => {\n    // Save original environment\n    originalEnv = { ...process.env };\n    // Set test environment variables\n    process.env.JWT_SECRET = 'test-secret-key-for-testing-only-32-chars-long!!';\n    process.env.JWT_ALGORITHM = 'HS256';\n    process.env.JWT_EXPIRY = '15m';\n    process.env.JWT_REFRESH_EXPIRY = '7d';\n    process.env.NODE_ENV = 'test';\n  });\n\n  afterAll(() => {\n    // Restore original environment\n    process.env = originalEnv;\n  });\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockLogger = pino({ level: 'silent' });\n    sessionStore = new InMemorySessionStore(mockLogger);\n    authBridge = new MCPAuthBridge(sessionStore, mockLogger);\n  });\n\n  afterEach(async () => {\n    await sessionStore.clear();\n    await apiKeyStore.clear();\n  });\n\n  describe('authenticate', () => {\n    it('should reject when no auth credentials provided', async () => {\n      await expect(authBridge.authenticate()).rejects.toThrow(\n        new AppError('Authentication required', 401)\n      );\n      \n      expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n        logger.SecurityEventType.LOGIN_FAILURE,\n        expect.objectContaining({\n          reason: 'No authentication credentials provided',\n          result: 'failure',\n        })\n      );\n    });\n\n    it('should reject invalid authentication type', async () => {\n      const auth = {\n        type: 'invalid' as any,\n        credentials: 'test',\n      };\n\n      await expect(authBridge.authenticate(auth)).rejects.toThrow(\n        new AppError('Invalid authentication type', 400)\n      );\n    });\n\n    describe('JWT authentication', () => {\n      it('should authenticate valid JWT token', async () => {\n        const userId = '123e4567-e89b-12d3-a456-426614174000';\n        const username = 'testuser';\n        const roles = ['user', 'poweruser'];\n        const sessionId = '987e6543-e21b-12d3-a456-426614174001';\n\n        const token = generateToken({\n          sub: userId,\n          username,\n          roles,\n          sessionId,\n          type: 'access',\n        });\n\n        const auth: MCPAuthCredentials = {\n          type: 'jwt',\n          credentials: token,\n        };\n\n        // Add try-catch to see actual error\n        try {\n          const result = await authBridge.authenticate(auth);\n\n          expect(result).toEqual({\n            userId,\n            username,\n            roles,\n            permissions: expect.arrayContaining([\n              Permission.SESSION_CREATE,\n              Permission.CONTEXT_EXECUTE,\n            ]),\n            sessionId,\n            authMethod: 'jwt',\n          });\n\n          expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n            logger.SecurityEventType.LOGIN_SUCCESS,\n            expect.objectContaining({\n              userId,\n              result: 'success',\n              metadata: expect.objectContaining({\n                method: 'jwt',\n                context: 'mcp',\n              }),\n            })\n          );\n        } catch (error) {\n          console.error('JWT authentication error:', error);\n          throw error;\n        }\n      });\n\n      it('should handle Bearer token format', async () => {\n        const token = generateToken({\n          sub: '123e4567-e89b-12d3-a456-426614174000',\n          username: 'testuser',\n          roles: ['user'],\n          sessionId: '987e6543-e21b-12d3-a456-426614174001',\n          type: 'access',\n        });\n\n        const auth: MCPAuthCredentials = {\n          type: 'jwt',\n          credentials: `Bearer ${token}`,\n        };\n\n        const result = await authBridge.authenticate(auth);\n        expect(result.userId).toBe('123e4567-e89b-12d3-a456-426614174000');\n      });\n\n      it('should reject invalid JWT token', async () => {\n        const auth: MCPAuthCredentials = {\n          type: 'jwt',\n          credentials: 'invalid-token',\n        };\n\n        await expect(authBridge.authenticate(auth)).rejects.toThrow(\n          new AppError('Invalid or expired JWT token', 401)\n        );\n\n        expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n          logger.SecurityEventType.LOGIN_FAILURE,\n          expect.objectContaining({\n            result: 'failure',\n            metadata: expect.objectContaining({\n              method: 'jwt',\n            }),\n          })\n        );\n      });\n\n      it('should reject expired JWT token', async () => {\n        const token = generateToken(\n          {\n            sub: '123e4567-e89b-12d3-a456-426614174000',\n            username: 'testuser',\n            roles: ['user'],\n            sessionId: '987e6543-e21b-12d3-a456-426614174001',\n            type: 'access',\n          },\n          -1 // Negative expiry to create expired token\n        );\n\n        const auth: MCPAuthCredentials = {\n          type: 'jwt',\n          credentials: token,\n        };\n\n        await expect(authBridge.authenticate(auth)).rejects.toThrow(\n          new AppError('Invalid or expired JWT token', 401)\n        );\n      });\n    });\n\n    describe('API key authentication', () => {\n      it('should authenticate valid API key', async () => {\n        const userId = '123e4567-e89b-12d3-a456-426614174000';\n        const { plainTextKey } = await apiKeyStore.create({\n          userId,\n          name: 'Test API Key',\n          roles: ['service'],\n          scopes: ['context:*', 'custom:permission'],\n        });\n\n        const auth: MCPAuthCredentials = {\n          type: 'apikey',\n          credentials: plainTextKey,\n        };\n\n        const result = await authBridge.authenticate(auth);\n\n        expect(result).toEqual({\n          userId,\n          roles: ['service'],\n          permissions: expect.arrayContaining([\n            Permission.CONTEXT_CREATE,\n            Permission.CONTEXT_EXECUTE,\n            'context:*',\n            'custom:permission',\n          ]),\n          apiKeyId: expect.any(String),\n          authMethod: 'apikey',\n        });\n\n        expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n          logger.SecurityEventType.LOGIN_SUCCESS,\n          expect.objectContaining({\n            userId,\n            result: 'success',\n            metadata: expect.objectContaining({\n              method: 'apikey',\n              context: 'mcp',\n            }),\n          })\n        );\n      });\n\n      it('should reject invalid API key', async () => {\n        const auth: MCPAuthCredentials = {\n          type: 'apikey',\n          credentials: 'mcp_invalid_key_123',\n        };\n\n        await expect(authBridge.authenticate(auth)).rejects.toThrow(\n          new AppError('Invalid API key', 401)\n        );\n\n        expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n          logger.SecurityEventType.LOGIN_FAILURE,\n          expect.objectContaining({\n            reason: 'Invalid API key',\n            result: 'failure',\n          })\n        );\n      });\n\n      it('should reject revoked API key', async () => {\n        const { apiKey, plainTextKey } = await apiKeyStore.create({\n          userId: '123e4567-e89b-12d3-a456-426614174000',\n          name: 'Test API Key',\n        });\n\n        await apiKeyStore.revoke(apiKey.id);\n\n        const auth: MCPAuthCredentials = {\n          type: 'apikey',\n          credentials: plainTextKey,\n        };\n\n        await expect(authBridge.authenticate(auth)).rejects.toThrow(\n          new AppError('Invalid API key', 401)\n        );\n      });\n    });\n\n    describe('Session authentication', () => {\n      it('should authenticate valid session', async () => {\n        const userId = '123e4567-e89b-12d3-a456-426614174000';\n        const username = 'testuser';\n        const roles = ['user', 'admin'];\n\n        const sessionId = await sessionStore.create({\n          userId,\n          username,\n          roles,\n          createdAt: new Date().toISOString(),\n          expiresAt: new Date(Date.now() + 3600000).toISOString(),\n        });\n\n        const auth: MCPAuthCredentials = {\n          type: 'session',\n          credentials: sessionId,\n        };\n\n        const result = await authBridge.authenticate(auth);\n\n        expect(result).toEqual({\n          userId,\n          username,\n          roles,\n          permissions: expect.arrayContaining([Permission.ADMIN_ALL]),\n          sessionId,\n          authMethod: 'session',\n        });\n\n        expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n          logger.SecurityEventType.LOGIN_SUCCESS,\n          expect.objectContaining({\n            userId,\n            result: 'success',\n            metadata: expect.objectContaining({\n              method: 'session',\n              context: 'mcp',\n            }),\n          })\n        );\n      });\n\n      it('should reject invalid session', async () => {\n        const auth: MCPAuthCredentials = {\n          type: 'session',\n          credentials: 'invalid-session-id',\n        };\n\n        await expect(authBridge.authenticate(auth)).rejects.toThrow(\n          new AppError('Invalid or expired session', 401)\n        );\n\n        expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n          logger.SecurityEventType.LOGIN_FAILURE,\n          expect.objectContaining({\n            reason: 'Invalid or expired session',\n            result: 'failure',\n          })\n        );\n      });\n\n      it('should reject expired session', async () => {\n        const sessionId = await sessionStore.create({\n          userId: '123e4567-e89b-12d3-a456-426614174000',\n          username: 'testuser',\n          roles: ['user'],\n          createdAt: new Date().toISOString(),\n          expiresAt: new Date(Date.now() - 1000).toISOString(), // Already expired\n        });\n\n        const auth: MCPAuthCredentials = {\n          type: 'session',\n          credentials: sessionId,\n        };\n\n        await expect(authBridge.authenticate(auth)).rejects.toThrow(\n          new AppError('Invalid or expired session', 401)\n        );\n      });\n\n      it('should touch session on successful authentication', async () => {\n        const sessionId = await sessionStore.create({\n          userId: '123e4567-e89b-12d3-a456-426614174000',\n          username: 'testuser',\n          roles: ['user'],\n          createdAt: new Date().toISOString(),\n          expiresAt: new Date(Date.now() + 3600000).toISOString(),\n        });\n\n        const touchSpy = jest.spyOn(sessionStore, 'touch');\n\n        const auth: MCPAuthCredentials = {\n          type: 'session',\n          credentials: sessionId,\n        };\n\n        await authBridge.authenticate(auth);\n\n        expect(touchSpy).toHaveBeenCalledWith(sessionId);\n      });\n    });\n  });\n\n  describe('hasToolPermission', () => {\n    it('should return true when user has required permission', () => {\n      const authContext: AuthContext = {\n        userId: '123e4567-e89b-12d3-a456-426614174000',\n        roles: ['user'],\n        permissions: [Permission.CONTEXT_EXECUTE],\n        authMethod: 'jwt',\n      };\n\n      expect(authBridge.hasToolPermission(authContext, 'navigate')).toBe(true);\n      expect(authBridge.hasToolPermission(authContext, 'click')).toBe(true);\n    });\n\n    it('should return false when user lacks required permission', () => {\n      const authContext: AuthContext = {\n        userId: '123e4567-e89b-12d3-a456-426614174000',\n        roles: ['readonly'],\n        permissions: [Permission.CONTEXT_READ],\n        authMethod: 'jwt',\n      };\n\n      expect(authBridge.hasToolPermission(authContext, 'navigate')).toBe(false);\n      expect(authBridge.hasToolPermission(authContext, 'type')).toBe(false);\n    });\n\n    it('should return false for unknown tools', () => {\n      const authContext: AuthContext = {\n        userId: '123e4567-e89b-12d3-a456-426614174000',\n        roles: ['admin'],\n        permissions: [Permission.ADMIN_ALL],\n        authMethod: 'jwt',\n      };\n\n      expect(authBridge.hasToolPermission(authContext, 'unknownTool')).toBe(false);\n    });\n  });\n\n  describe('requireToolPermission', () => {\n    it('should pass when user has permission', async () => {\n      const authContext: AuthContext = {\n        userId: '123e4567-e89b-12d3-a456-426614174000',\n        roles: ['user'],\n        permissions: [Permission.CONTEXT_EXECUTE],\n        authMethod: 'jwt',\n      };\n\n      await expect(\n        authBridge.requireToolPermission(authContext, 'navigate')\n      ).resolves.toBeUndefined();\n    });\n\n    it('should throw when user lacks permission', async () => {\n      const authContext: AuthContext = {\n        userId: '123e4567-e89b-12d3-a456-426614174000',\n        roles: ['readonly'],\n        permissions: [Permission.CONTEXT_READ],\n        authMethod: 'jwt',\n      };\n\n      await expect(\n        authBridge.requireToolPermission(authContext, 'navigate')\n      ).rejects.toThrow(\n        new AppError(\n          `Permission denied: ${Permission.CONTEXT_EXECUTE} required for tool navigate`,\n          403\n        )\n      );\n\n      expect(logger.logSecurityEvent).toHaveBeenCalledWith(\n        logger.SecurityEventType.ACCESS_DENIED,\n        expect.objectContaining({\n          userId: '123e4567-e89b-12d3-a456-426614174000',\n          resource: 'mcp:tool:navigate',\n          action: Permission.CONTEXT_EXECUTE,\n          result: 'failure',\n        })\n      );\n    });\n\n    it('should throw for unknown tools', async () => {\n      const authContext: AuthContext = {\n        userId: '123e4567-e89b-12d3-a456-426614174000',\n        roles: ['admin'],\n        permissions: [Permission.ADMIN_ALL],\n        authMethod: 'jwt',\n      };\n\n      await expect(\n        authBridge.requireToolPermission(authContext, 'unknownTool')\n      ).rejects.toThrow(\n        new AppError(\n          'Permission denied: unknown required for tool unknownTool',\n          403\n        )\n      );\n    });\n  });\n\n  describe('extractCredentials', () => {\n    it('should extract JWT from Authorization header', () => {\n      const result = authBridge.extractCredentials({\n        headers: {\n          authorization: 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9',\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'jwt',\n        credentials: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9',\n      });\n    });\n\n    it('should extract API key from x-api-key header', () => {\n      const result = authBridge.extractCredentials({\n        headers: {\n          'x-api-key': 'mcp_test_key_123',\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'apikey',\n        credentials: 'mcp_test_key_123',\n      });\n    });\n\n    it('should extract API key from apikey header', () => {\n      const result = authBridge.extractCredentials({\n        headers: {\n          apikey: 'mcp_test_key_456',\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'apikey',\n        credentials: 'mcp_test_key_456',\n      });\n    });\n\n    it('should extract JWT from query parameter', () => {\n      const result = authBridge.extractCredentials({\n        query: {\n          token: 'jwt_token_from_query',\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'jwt',\n        credentials: 'jwt_token_from_query',\n      });\n    });\n\n    it('should extract API key from query parameter', () => {\n      const result = authBridge.extractCredentials({\n        query: {\n          apikey: 'mcp_query_key_789',\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'apikey',\n        credentials: 'mcp_query_key_789',\n      });\n    });\n\n    it('should extract session ID from query parameter', () => {\n      const result = authBridge.extractCredentials({\n        query: {\n          sessionId: 'session-uuid-123',\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'session',\n        credentials: 'session-uuid-123',\n      });\n    });\n\n    it('should extract auth from WebSocket metadata', () => {\n      const result = authBridge.extractCredentials({\n        metadata: {\n          auth: {\n            type: 'jwt',\n            credentials: 'ws_jwt_token',\n          },\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'jwt',\n        credentials: 'ws_jwt_token',\n      });\n    });\n\n    it('should handle array values in headers', () => {\n      const result = authBridge.extractCredentials({\n        headers: {\n          authorization: ['Bearer token1', 'Bearer token2'],\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'jwt',\n        credentials: 'token1',\n      });\n    });\n\n    it('should handle array values in query', () => {\n      const result = authBridge.extractCredentials({\n        query: {\n          apikey: ['key1', 'key2'],\n        },\n      });\n\n      expect(result).toEqual({\n        type: 'apikey',\n        credentials: 'key1',\n      });\n    });\n\n    it('should return undefined when no credentials found', () => {\n      const result = authBridge.extractCredentials({\n        headers: {},\n        query: {},\n      });\n\n      expect(result).toBeUndefined();\n    });\n\n    it('should ignore invalid WebSocket metadata', () => {\n      const result = authBridge.extractCredentials({\n        metadata: {\n          auth: {\n            type: 'invalid',\n            credentials: 'test',\n          },\n        },\n      });\n\n      expect(result).toBeUndefined();\n    });\n  });\n\n  describe('MCP_TOOL_PERMISSIONS', () => {\n    it('should have permissions for all browser control tools', () => {\n      const browserTools = ['navigate', 'click', 'type', 'scroll', 'waitForSelector', 'evaluate'];\n      \n      browserTools.forEach(tool => {\n        expect(MCP_TOOL_PERMISSIONS[tool]).toBe(Permission.CONTEXT_EXECUTE);\n      });\n    });\n\n    it('should have read permissions for information tools', () => {\n      const infoTools = ['screenshot', 'getTitle', 'getUrl', 'getContent', 'getCookies'];\n      \n      infoTools.forEach(tool => {\n        expect(MCP_TOOL_PERMISSIONS[tool]).toBe(Permission.CONTEXT_READ);\n      });\n    });\n\n    it('should have appropriate permissions for session management', () => {\n      expect(MCP_TOOL_PERMISSIONS['createSession']).toBe(Permission.SESSION_CREATE);\n      expect(MCP_TOOL_PERMISSIONS['closeSession']).toBe(Permission.SESSION_DELETE);\n      expect(MCP_TOOL_PERMISSIONS['listSessions']).toBe(Permission.SESSION_LIST);\n    });\n\n    it('should have appropriate permissions for context management', () => {\n      expect(MCP_TOOL_PERMISSIONS['createContext']).toBe(Permission.CONTEXT_CREATE);\n      expect(MCP_TOOL_PERMISSIONS['getContext']).toBe(Permission.CONTEXT_READ);\n      expect(MCP_TOOL_PERMISSIONS['updateContext']).toBe(Permission.CONTEXT_UPDATE);\n      expect(MCP_TOOL_PERMISSIONS['deleteContext']).toBe(Permission.CONTEXT_DELETE);\n      expect(MCP_TOOL_PERMISSIONS['listContexts']).toBe(Permission.CONTEXT_LIST);\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/mcp/execute-in-context-tool.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'InMemorySessionStore' is defined but never used.","line":8,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'contextStore' is defined but never used.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'userService' is defined but never used.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logger' is defined but never used.","line":11,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":11,"endColumn":16}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MCP Execute-in-Context Tool Tests\n * @module tests/unit/mcp/execute-in-context-tool\n * @description Unit tests for the execute-in-context MCP tool\n */\n\nimport { MCPServer } from '../../../src/mcp/server.js';\nimport { InMemorySessionStore } from '../../../src/store/in-memory-session-store.js';\nimport { contextStore } from '../../../src/store/context-store.js';\nimport { userService } from '../../../src/mcp/auth/user-service.js';\nimport { logger } from '../../../src/utils/logger.js';\nimport { vi, describe, it, expect, beforeEach } from 'vitest';\nimport type { Application } from 'express';\n\n// Mock dependencies\nvi.mock('../../../src/store/context-store.js');\nvi.mock('../../../src/mcp/auth/user-service.js');\nvi.mock('../../../src/utils/logger.js', () => ({\n  logger: {\n    info: vi.fn(),\n    error: vi.fn(),\n    child: vi.fn(() => ({\n      info: vi.fn(),\n      error: vi.fn(),\n      warn: vi.fn(),\n      debug: vi.fn(),\n    })),\n  },\n}));\n\ndescribe('MCP Execute-in-Context Tool', () => {\n  let mcpServer: MCPServer;\n  let mockApp: Partial<Application>;\n  let mockRestAdapter: any;\n\n  beforeEach(() => {\n    vi.clearAllMocks();\n    \n    // Create a mock Express app\n    mockApp = {};\n    \n    // Create mock REST adapter\n    mockRestAdapter = {\n      executeRequest: vi.fn(),\n    };\n    \n    // Create MCP server instance\n    mcpServer = new MCPServer(mockApp as Application);\n    \n    // Replace the REST adapter with our mock\n    (mcpServer as any).restAdapter = mockRestAdapter;\n  });\n\n  describe('execute-in-context tool', () => {\n    it('should execute a command in a context successfully', async () => {\n      // Arrange\n      const contextId = 'test-context-123';\n      const command = 'navigate';\n      const parameters = { url: 'https://example.com' };\n      \n      // Mock successful REST adapter response\n      mockRestAdapter.executeRequest.mockResolvedValue({\n        content: [{\n          type: 'text',\n          text: JSON.stringify({\n            success: true,\n            result: { currentUrl: 'https://example.com' },\n          }),\n        }],\n        metadata: {\n          status: 200,\n          requestId: 'test-request-123',\n        },\n      });\n      \n      // Act\n      const result = await (mcpServer as any).executeInContextTool({\n        contextId,\n        command,\n        parameters,\n      });\n      \n      // Assert\n      expect(mockRestAdapter.executeRequest).toHaveBeenCalledWith({\n        operation: {\n          method: 'POST',\n          endpoint: `/v1/contexts/${contextId}/execute`,\n          body: {\n            action: command,\n            params: parameters,\n          },\n        },\n        auth: undefined,\n        sessionId: undefined,\n      });\n      \n      expect(result.content).toHaveLength(1);\n      expect(result.content[0].type).toBe('text');\n      \n      const responseData = JSON.parse(result.content[0].text);\n      expect(responseData).toEqual({\n        success: true,\n        result: { currentUrl: 'https://example.com' },\n      });\n    });\n\n    it('should handle missing contextId', async () => {\n      // Act\n      const result = await (mcpServer as any).executeInContextTool({\n        command: 'navigate',\n        parameters: { url: 'https://example.com' },\n      });\n      \n      // Assert\n      expect(result.content).toHaveLength(1);\n      expect(result.content[0].type).toBe('text');\n      \n      const responseData = JSON.parse(result.content[0].text);\n      expect(responseData.error).toBe('Context ID is required');\n      expect(responseData.code).toBe('INVALID_CONTEXT_ID');\n    });\n\n    it('should handle missing command', async () => {\n      // Act\n      const result = await (mcpServer as any).executeInContextTool({\n        contextId: 'test-context-123',\n        parameters: { url: 'https://example.com' },\n      });\n      \n      // Assert\n      expect(result.content).toHaveLength(1);\n      expect(result.content[0].type).toBe('text');\n      \n      const responseData = JSON.parse(result.content[0].text);\n      expect(responseData.error).toBe('Command is required');\n      expect(responseData.code).toBe('INVALID_COMMAND');\n    });\n\n    it('should use session authentication when sessionId is provided', async () => {\n      // Arrange\n      const contextId = 'test-context-123';\n      const command = 'navigate';\n      const sessionId = 'test-session-456';\n      \n      mockRestAdapter.executeRequest.mockResolvedValue({\n        content: [{\n          type: 'text',\n          text: JSON.stringify({ success: true }),\n        }],\n      });\n      \n      // Act\n      await (mcpServer as any).executeInContextTool({\n        contextId,\n        command,\n        sessionId,\n      });\n      \n      // Assert\n      expect(mockRestAdapter.executeRequest).toHaveBeenCalledWith({\n        operation: {\n          method: 'POST',\n          endpoint: `/v1/contexts/${contextId}/execute`,\n          body: {\n            action: command,\n            params: {},\n          },\n        },\n        auth: {\n          type: 'session',\n          credentials: sessionId,\n        },\n        sessionId,\n      });\n    });\n\n    it('should handle REST adapter errors gracefully', async () => {\n      // Arrange\n      const error = new Error('Network error');\n      mockRestAdapter.executeRequest.mockRejectedValue(error);\n      \n      // Act\n      const result = await (mcpServer as any).executeInContextTool({\n        contextId: 'test-context-123',\n        command: 'navigate',\n        parameters: { url: 'https://example.com' },\n      });\n      \n      // Assert\n      expect(result.content).toHaveLength(1);\n      expect(result.content[0].type).toBe('text');\n      \n      const responseData = JSON.parse(result.content[0].text);\n      expect(responseData.error).toBe('Network error');\n      expect(responseData.code).toBe('EXECUTION_FAILED');\n    });\n\n    it('should handle unparseable response gracefully', async () => {\n      // Arrange\n      mockRestAdapter.executeRequest.mockResolvedValue({\n        content: [{\n          type: 'text',\n          text: 'Not valid JSON',\n        }],\n      });\n      \n      // Act\n      const result = await (mcpServer as any).executeInContextTool({\n        contextId: 'test-context-123',\n        command: 'navigate',\n      });\n      \n      // Assert\n      expect(result.content).toHaveLength(1);\n      expect(result.content[0].type).toBe('text');\n      \n      const responseData = JSON.parse(result.content[0].text);\n      expect(responseData.result).toBe('Not valid JSON');\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/mcp/execute-tool-verification.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/mcp/mcp-server.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_tools' is assigned a value but never used.","line":62,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":62,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_tools' is assigned a value but never used.","line":68,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":68,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_tools' is assigned a value but never used.","line":74,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":74,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_resources' is assigned a value but never used.","line":82,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":82,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_resources' is assigned a value but never used.","line":88,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":88,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockSession' is assigned a value but never used.","line":96,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":24},{"ruleId":"@typescript-eslint/no-unsafe-return","severity":2,"message":"Unsafe return of an `any` typed value.","line":178,"column":63,"nodeType":"ObjectExpression","messageId":"unsafeReturn","endLine":183,"endColumn":8}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Unit tests for MCP Server\n * @module tests/unit/mcp/mcp-server\n */\n\nimport { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';\nimport { MCPServer } from '../../../src/mcp/server.js';\nimport { logger } from '../../../src/utils/logger.js';\n\n// Mock dependencies\njest.mock('../../../src/utils/logger.js');\njest.mock('../../../src/store/session-store.js');\njest.mock('../../../src/store/context-store.js');\n\ndescribe('MCP Server', () => {\n  let mcpServer: MCPServer;\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n    mcpServer = new MCPServer();\n  });\n  \n  afterEach(async () => {\n    // Clean up any resources\n    try {\n      await mcpServer.stop();\n    } catch (error) {\n      // Server might not be started\n    }\n  });\n\n  describe('Server Initialization', () => {\n    it('should create server with correct metadata', () => {\n      expect(mcpServer).toBeDefined();\n      expect(mcpServer).toBeInstanceOf(MCPServer);\n    });\n\n    it('should log server startup', async () => {\n      // Set environment to use stdio transport\n      process.env.MCP_TRANSPORT = 'stdio';\n      \n      // Mock the stdio transport connection\n      const mockConnect = jest.fn().mockResolvedValue(undefined);\n      jest.spyOn(mcpServer as any, 'server', 'get').mockReturnValue({\n        connect: mockConnect,\n        close: jest.fn(),\n      });\n      \n      await mcpServer.start();\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'Starting MCP server',\n          transportType: 'stdio',\n        })\n      );\n    });\n  });\n\n  describe('Tool Registration', () => {\n    it('should register execute-api tool', () => {\n      const _tools = (mcpServer as any).server._handlers?.get('tools/list');\n      // This test will be implemented once we can access the registered tools\n      expect(mcpServer).toBeDefined();\n    });\n\n    it('should register session management tools', () => {\n      const _tools = (mcpServer as any).server._handlers?.get('tools/list');\n      // This test will be implemented once we can access the registered tools\n      expect(mcpServer).toBeDefined();\n    });\n\n    it('should register browser context tools', () => {\n      const _tools = (mcpServer as any).server._handlers?.get('tools/list');\n      // This test will be implemented once we can access the registered tools\n      expect(mcpServer).toBeDefined();\n    });\n  });\n\n  describe('Resource Registration', () => {\n    it('should register API catalog resource', () => {\n      const _resources = (mcpServer as any).server._handlers?.get('resources/list');\n      // This test will be implemented once we can access the registered resources\n      expect(mcpServer).toBeDefined();\n    });\n\n    it('should register health resource', () => {\n      const _resources = (mcpServer as any).server._handlers?.get('resources/list');\n      // This test will be implemented once we can access the registered resources\n      expect(mcpServer).toBeDefined();\n    });\n  });\n\n  describe('Tool Execution', () => {\n    it('should handle create-session tool call', async () => {\n      const mockSession = {\n        id: 'test-session-123',\n        userId: 'testuser',\n        createdAt: new Date().toISOString(),\n        expiresAt: new Date(Date.now() + 3600000).toISOString(),\n      };\n      \n      const result = await (mcpServer as any).createSessionTool({\n        username: 'testuser',\n        password: 'testpass',\n        duration: 3600,\n      });\n      \n      expect(result).toHaveProperty('content');\n      expect(result.content[0].type).toBe('text');\n      \n      const sessionData = JSON.parse(result.content[0].text);\n      expect(sessionData).toHaveProperty('id');\n      expect(sessionData).toHaveProperty('userId', 'testuser');\n    });\n\n    it('should handle unknown tool error', async () => {\n      await expect(\n        (mcpServer as any).server.handleRequest({\n          method: 'tools/call',\n          params: {\n            name: 'unknown-tool',\n            arguments: {},\n          },\n        })\n      ).rejects.toThrow();\n    });\n  });\n\n  describe('Resource Access', () => {\n    it('should return API catalog', async () => {\n      const result = await (mcpServer as any).getApiCatalog();\n      \n      expect(result).toHaveProperty('contents');\n      expect(result.contents[0].mimeType).toBe('application/json');\n      \n      const catalog = JSON.parse(result.contents[0].text);\n      expect(catalog).toHaveProperty('rest');\n      expect(catalog).toHaveProperty('grpc');\n      expect(catalog).toHaveProperty('websocket');\n    });\n\n    it('should return system health', async () => {\n      const result = await (mcpServer as any).getSystemHealth();\n      \n      expect(result).toHaveProperty('contents');\n      expect(result.contents[0].mimeType).toBe('application/json');\n      \n      const health = JSON.parse(result.contents[0].text);\n      expect(health).toHaveProperty('status', 'healthy');\n      expect(health).toHaveProperty('services');\n    });\n  });\n\n  describe('Transport Support', () => {\n    it('should support stdio transport', async () => {\n      process.env.MCP_TRANSPORT = 'stdio';\n      \n      const mockConnect = jest.fn().mockResolvedValue(undefined);\n      jest.spyOn(mcpServer as any, 'server', 'get').mockReturnValue({\n        connect: mockConnect,\n        close: jest.fn(),\n      });\n      \n      await mcpServer.start();\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP server started with stdio transport',\n        })\n      );\n    });\n\n    it('should support HTTP transport', async () => {\n      process.env.MCP_TRANSPORT = 'http';\n      \n      // Mock HTTP transport creation\n      jest.mock('../../../src/mcp/transport/index.js', () => ({\n        ...jest.requireActual('../../../src/mcp/transport/index.js'),\n        createHttpTransport: jest.fn().mockReturnValue({\n          start: jest.fn().mockResolvedValue(undefined),\n        }),\n      }));\n      \n      await mcpServer.start();\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP HTTP transport started',\n        })\n      );\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should log errors during tool execution', async () => {\n      const mockError = new Error('Tool execution failed');\n      \n      // Mock a tool that throws an error\n      jest.spyOn(mcpServer as any, 'executeApiTool').mockRejectedValue(mockError);\n      \n      try {\n        await (mcpServer as any).server.handleRequest({\n          method: 'tools/call',\n          params: {\n            name: 'execute-api',\n            arguments: {},\n          },\n        });\n      } catch (error) {\n        // Expected error\n      }\n      \n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP tool execution failed',\n          tool: 'execute-api',\n          error: 'Tool execution failed',\n        })\n      );\n    });\n\n    it('should handle resource not found errors', async () => {\n      await expect(\n        (mcpServer as any).server.handleRequest({\n          method: 'resources/read',\n          params: {\n            uri: 'api://unknown-resource',\n          },\n        })\n      ).rejects.toThrow();\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/mcp/transport.test.ts","messages":[{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":58,"column":7,"nodeType":"AwaitExpression","messageId":"await","endLine":58,"endColumn":30,"suggestions":[{"messageId":"removeAwait","fix":{"range":[1771,1776],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/await-thenable","severity":2,"message":"Unexpected `await` of a non-Promise (non-\"Thenable\") value.","line":115,"column":7,"nodeType":"AwaitExpression","messageId":"await","endLine":115,"endColumn":30,"suggestions":[{"messageId":"removeAwait","fix":{"range":[3413,3418],"text":""},"desc":"Remove unnecessary `await`."}]},{"ruleId":"@typescript-eslint/strict-boolean-expressions","severity":1,"message":"Unexpected object value in conditional. The condition is always true.","line":129,"column":11,"nodeType":"Identifier","messageId":"conditionErrorObject","endLine":129,"endColumn":20},{"ruleId":"require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":194,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":194,"endColumn":58},{"ruleId":"@typescript-eslint/require-await","severity":2,"message":"Async arrow function has no 'await' expression.","line":194,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"missingAwait","endLine":194,"endColumn":58}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Unit tests for MCP Transport Layer\n * @module tests/unit/mcp/transport\n */\n\nimport { describe, it, expect, jest, beforeEach, afterEach } from '@jest/globals';\nimport { StdioTransport, HttpTransport, TransportType, getTransportType } from '../../../src/mcp/transport/index.js';\nimport { logger } from '../../../src/utils/logger.js';\n\n// Mock dependencies\njest.mock('../../../src/utils/logger.js');\njest.mock('fs', () => ({\n  readFileSync: jest.fn().mockReturnValue('mock-cert-content'),\n}));\n\ndescribe('MCP Transport Layer', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    delete process.env.MCP_TRANSPORT;\n    delete process.env.MCP_HTTP_PORT;\n    delete process.env.MCP_HTTP_HOST;\n  });\n\n  describe('Transport Type Detection', () => {\n    it('should default to stdio transport', () => {\n      expect(getTransportType()).toBe(TransportType.STDIO);\n    });\n\n    it('should detect stdio transport from environment', () => {\n      process.env.MCP_TRANSPORT = 'stdio';\n      expect(getTransportType()).toBe(TransportType.STDIO);\n    });\n\n    it('should detect HTTP transport from environment', () => {\n      process.env.MCP_TRANSPORT = 'http';\n      expect(getTransportType()).toBe(TransportType.HTTP);\n    });\n\n    it('should detect HTTP transport from websocket alias', () => {\n      process.env.MCP_TRANSPORT = 'websocket';\n      expect(getTransportType()).toBe(TransportType.HTTP);\n    });\n\n    it('should detect HTTP transport from ws alias', () => {\n      process.env.MCP_TRANSPORT = 'ws';\n      expect(getTransportType()).toBe(TransportType.HTTP);\n    });\n  });\n\n  describe('StdioTransport', () => {\n    let transport: StdioTransport;\n    \n    beforeEach(() => {\n      transport = new StdioTransport();\n    });\n    \n    afterEach(async () => {\n      await transport.close();\n    });\n\n    it('should create stdio transport instance', () => {\n      expect(transport).toBeDefined();\n      expect(transport.getTransport()).toBeDefined();\n    });\n\n    it('should handle stdin errors', () => {\n      const mockError = new Error('stdin error');\n      process.stdin.emit('error', mockError);\n      \n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP stdio input error',\n          error: 'stdin error',\n        })\n      );\n    });\n\n    it('should handle stdout errors', () => {\n      const mockError = new Error('stdout error');\n      process.stdout.emit('error', mockError);\n      \n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP stdio output error',\n          error: 'stdout error',\n        })\n      );\n    });\n\n    it('should handle SIGINT signal', () => {\n      const closeSpy = jest.spyOn(transport, 'close');\n      process.emit('SIGINT', 'SIGINT');\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP stdio transport received SIGINT',\n        })\n      );\n      expect(closeSpy).toHaveBeenCalled();\n    });\n\n    it('should handle SIGTERM signal', () => {\n      const closeSpy = jest.spyOn(transport, 'close');\n      process.emit('SIGTERM', 'SIGTERM');\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP stdio transport received SIGTERM',\n        })\n      );\n      expect(closeSpy).toHaveBeenCalled();\n    });\n\n    it('should close transport gracefully', async () => {\n      await transport.close();\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'Closing MCP stdio transport',\n        })\n      );\n    });\n  });\n\n  describe('HttpTransport', () => {\n    let transport: HttpTransport;\n    \n    afterEach(async () => {\n      if (transport) {\n        try {\n          await transport.stop();\n        } catch (error) {\n          // Transport might not be started\n        }\n      }\n    });\n\n    it('should create HTTP transport with default config', () => {\n      transport = new HttpTransport();\n      expect(transport).toBeDefined();\n      expect(transport.getHttpServer()).toBeDefined();\n      expect(transport.getWebSocketServer()).toBeDefined();\n    });\n\n    it('should create HTTP transport with custom config', () => {\n      transport = new HttpTransport({\n        port: 3002,\n        host: '0.0.0.0',\n        useTls: false,\n      });\n      expect(transport).toBeDefined();\n    });\n\n    it('should create HTTPS transport when TLS enabled', () => {\n      transport = new HttpTransport({\n        useTls: true,\n        tlsCertPath: '/path/to/cert',\n        tlsKeyPath: '/path/to/key',\n      });\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'Creating HTTPS server for MCP',\n        })\n      );\n    });\n\n    it('should throw error when TLS enabled without cert paths', () => {\n      expect(() => {\n        new HttpTransport({\n          useTls: true,\n        });\n      }).toThrow('TLS certificate and key paths required when TLS is enabled');\n    });\n\n    it('should start HTTP transport', async () => {\n      transport = new HttpTransport({ port: 0 }); // Use port 0 for random available port\n      \n      const startPromise = transport.start();\n      \n      // Simulate server listening\n      const server = transport.getHttpServer();\n      server.emit('listening');\n      \n      await startPromise;\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP HTTP transport started',\n        })\n      );\n    });\n\n    it('should handle WebSocket connections', async () => {\n      transport = new HttpTransport({ port: 0 });\n      \n      const wsServer = transport.getWebSocketServer();\n      const mockWs = {\n        on: jest.fn(),\n        close: jest.fn(),\n      };\n      const mockRequest = {\n        socket: {\n          remoteAddress: '127.0.0.1',\n        },\n      };\n      \n      // Simulate WebSocket connection\n      wsServer.emit('connection', mockWs, mockRequest);\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP HTTP transport connection established',\n          clientIp: '127.0.0.1',\n        })\n      );\n      \n      expect(mockWs.on).toHaveBeenCalledWith('error', expect.any(Function));\n      expect(mockWs.on).toHaveBeenCalledWith('close', expect.any(Function));\n    });\n\n    it('should handle WebSocket errors', () => {\n      transport = new HttpTransport({ port: 0 });\n      \n      const wsServer = transport.getWebSocketServer();\n      const mockError = new Error('WebSocket server error');\n      \n      wsServer.emit('error', mockError);\n      \n      expect(logger.error).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP WebSocket server error',\n          error: 'WebSocket server error',\n        })\n      );\n    });\n\n    it('should stop HTTP transport gracefully', async () => {\n      transport = new HttpTransport({ port: 0 });\n      \n      // Mock server close methods\n      const httpServer = transport.getHttpServer();\n      const wsServer = transport.getWebSocketServer();\n      \n      jest.spyOn(wsServer, 'close').mockImplementation((callback) => {\n        if (callback) {callback();}\n      });\n      \n      jest.spyOn(httpServer, 'close').mockImplementation((callback) => {\n        if (callback) {callback();}\n        return httpServer;\n      });\n      \n      await transport.stop();\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'Stopping MCP HTTP transport',\n        })\n      );\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP WebSocket server closed',\n        })\n      );\n      \n      expect(logger.info).toHaveBeenCalledWith(\n        expect.objectContaining({\n          msg: 'MCP HTTP server closed',\n        })\n      );\n    });\n  });\n\n  describe('Factory Functions', () => {\n    it('should create stdio transport using factory', async () => {\n      const transportModule = await import('../../../src/mcp/transport/index.js');\n      const transport = transportModule.createStdioTransport();\n      expect(transport).toBeInstanceOf(StdioTransport);\n    });\n\n    it('should create HTTP transport using factory', async () => {\n      const transportModule = await import('../../../src/mcp/transport/index.js');\n      const transport = transportModule.createHttpTransport({ port: 0 });\n      expect(transport).toBeInstanceOf(HttpTransport);\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/puppeteer/action-executor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/puppeteer/browser-health-checker.test.ts","messages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":97,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":97,"endColumn":37},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":128,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":128,"endColumn":31},{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":134,"column":32,"nodeType":"CallExpression","messageId":"returnsValue","endLine":134,"endColumn":57,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[4197,4222],"text":"{setTimeout(resolve, 2000)}"},"desc":"Wrap the expression in `{}`."}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":229,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":229,"endColumn":31},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":242,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":242,"endColumn":31}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Health Checker Unit Tests\n * @module tests/unit/puppeteer/browser-health-checker\n * @nist si-4 \"Information system monitoring\"\n * @nist au-6 \"Audit review, analysis, and reporting\"\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { jest } from '@jest/globals';\nimport type { Browser, Page } from 'puppeteer';\n\n// Set environment to test\nprocess.env.NODE_ENV = 'test';\nprocess.env.LOG_LEVEL = 'silent';\n\n// Create mock logger\nconst mockLogger = {\n  info: jest.fn(),\n  debug: jest.fn(),\n  error: jest.fn(),\n  warn: jest.fn(),\n  child: jest.fn(() => mockLogger),\n};\n\n// Mock modules\njest.mock('../../../src/utils/logger.js', () => ({\n  createLogger: jest.fn(() => mockLogger),\n}));\n\njest.mock('puppeteer', () => ({\n  launch: jest.fn(),\n}));\n\n// Import modules\nimport { BrowserHealthChecker } from '../../../src/puppeteer/pool/browser-health-checker.js';\nimport type { BrowserInstance } from '../../../src/puppeteer/interfaces/browser-pool.interface.js';\nimport * as puppeteer from 'puppeteer';\n\ndescribe('BrowserHealthChecker', () => {\n  let healthChecker: BrowserHealthChecker;\n  let mockBrowser: jest.Mocked<Browser>;\n  let mockPage: jest.Mocked<Page>;\n  let mockInstance: BrowserInstance;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Setup mock page with default successful responses\n    mockPage = {\n      close: jest.fn(),\n      url: jest.fn(() => 'about:blank'),\n      goto: jest.fn(),\n      evaluate: jest.fn().mockResolvedValue(42), // Default: responsive\n      metrics: jest.fn().mockResolvedValue({\n        JSHeapUsedSize: 100 * 1024 * 1024, // 100MB - normal usage\n        JSHeapTotalSize: 200 * 1024 * 1024,\n      }),\n    } as unknown as jest.Mocked<Page>;\n\n    // Setup mock browser with default healthy responses\n    mockBrowser = {\n      newPage: jest.fn().mockResolvedValue(mockPage),\n      close: jest.fn(),\n      pages: jest.fn().mockResolvedValue([mockPage]), // Single page - normal count\n      process: jest.fn(() => ({ pid: 12345 })),\n      isConnected: jest.fn(() => true), // Default: connected\n      on: jest.fn(),\n      off: jest.fn(),\n    } as unknown as jest.Mocked<Browser>;\n\n    // Setup mock instance\n    mockInstance = {\n      id: 'browser-123',\n      browser: mockBrowser,\n      createdAt: new Date(),\n      lastUsedAt: new Date(),\n      useCount: 10,\n      pageCount: 1,\n      pid: 12345,\n    };\n\n    healthChecker = new BrowserHealthChecker({\n      maxMemoryMB: 512,\n      maxPageCount: 10,\n      responseTimeout: 1000, // Shorter timeout for tests\n      checkInterval: 10000,\n    });\n  });\n\n  describe('Connection Health', () => {\n    it('should detect healthy browser connection', async () => {\n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(true);\n      expect(result.connectionHealthy).toBe(true);\n      expect(mockBrowser.isConnected).toHaveBeenCalled();\n    });\n\n    it('should detect disconnected browser', async () => {\n      mockBrowser.isConnected.mockReturnValue(false);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(false);\n      expect(result.connectionHealthy).toBe(false);\n      expect(result.reason).toContain('Browser disconnected');\n    });\n\n    it('should handle browser without process', async () => {\n      mockBrowser.process.mockReturnValue(null);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(false);\n      expect(result.reason).toContain('Browser process not found');\n    });\n  });\n\n  describe('Responsiveness Check', () => {\n    it('should detect responsive browser', async () => {\n      mockPage.evaluate.mockResolvedValue(42);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(true);\n      expect(result.responsive).toBe(true);\n      expect(mockPage.evaluate).toHaveBeenCalledWith(expect.any(Function));\n    });\n\n    it('should detect unresponsive browser', async () => {\n      // Mock a long-running promise that exceeds the timeout\n      mockPage.evaluate.mockImplementation(() => \n        new Promise(resolve => setTimeout(resolve, 2000)) // Longer than 1000ms timeout\n      );\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(false);\n      expect(result.responsive).toBe(false);\n      expect(result.reason).toContain('Browser unresponsive');\n    }, 10000); // Increase test timeout\n\n    it('should handle evaluation errors', async () => {\n      mockPage.evaluate.mockRejectedValue(new Error('Evaluation failed'));\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(false);\n      expect(result.responsive).toBe(false);\n      expect(result.reason).toContain('Browser unresponsive');\n    });\n  });\n\n  describe('Memory Usage Check', () => {\n    it('should detect normal memory usage', async () => {\n      mockPage.metrics.mockResolvedValue({\n        JSHeapUsedSize: 100 * 1024 * 1024, // 100MB\n        JSHeapTotalSize: 200 * 1024 * 1024,\n      } as any);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(true);\n      expect(result.memoryHealthy).toBe(true);\n      expect(result.metrics.memoryUsageMB).toBeCloseTo(100, 1);\n    });\n\n    it('should detect excessive memory usage', async () => {\n      mockPage.metrics.mockResolvedValue({\n        JSHeapUsedSize: 600 * 1024 * 1024, // 600MB\n        JSHeapTotalSize: 800 * 1024 * 1024,\n      } as any);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(false);\n      expect(result.memoryHealthy).toBe(false);\n      expect(result.reason).toContain('Excessive memory usage');\n      expect(result.metrics.memoryUsageMB).toBeCloseTo(600, 1);\n    });\n\n    it('should handle memory check failures', async () => {\n      mockPage.metrics.mockRejectedValue(new Error('Metrics failed'));\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      // Should still be healthy if only metrics fail\n      expect(result.isHealthy).toBe(true);\n      expect(result.memoryHealthy).toBe(true);\n      expect(result.metrics.memoryUsageMB).toBe(0);\n    });\n  });\n\n  describe('Page Count Check', () => {\n    it('should detect normal page count', async () => {\n      mockBrowser.pages.mockResolvedValue([mockPage, mockPage, mockPage]);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(true);\n      expect(result.pageCountHealthy).toBe(true);\n      expect(result.metrics.pageCount).toBe(3);\n    });\n\n    it('should detect excessive page count', async () => {\n      const pages = Array(15).fill(mockPage);\n      mockBrowser.pages.mockResolvedValue(pages);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.isHealthy).toBe(false);\n      expect(result.pageCountHealthy).toBe(false);\n      expect(result.reason).toContain('Too many pages');\n      expect(result.metrics.pageCount).toBe(15);\n    });\n  });\n\n  describe('Restart Functionality', () => {\n    it('should restart unhealthy browser', async () => {\n      const newBrowser = { ...mockBrowser };\n      (puppeteer.launch as jest.Mock).mockResolvedValue(newBrowser);\n      \n      mockBrowser.isConnected.mockReturnValue(false);\n      \n      const launchOptions = { headless: true };\n      const result = await healthChecker.restartBrowser(mockInstance, launchOptions);\n      \n      expect(mockBrowser.close).toHaveBeenCalled();\n      expect(puppeteer.launch).toHaveBeenCalledWith(launchOptions);\n      expect(result).toBe(newBrowser);\n    });\n\n    it('should handle restart failures', async () => {\n      (puppeteer.launch as jest.Mock).mockRejectedValue(new Error('Launch failed'));\n      \n      const launchOptions = { headless: true };\n      \n      await expect(healthChecker.restartBrowser(mockInstance, launchOptions))\n        .rejects.toThrow('Launch failed');\n      \n      expect(mockBrowser.close).toHaveBeenCalled();\n    });\n\n    it('should handle close failures during restart', async () => {\n      const newBrowser = { ...mockBrowser };\n      (puppeteer.launch as jest.Mock).mockResolvedValue(newBrowser);\n      \n      mockBrowser.close.mockRejectedValue(new Error('Close failed'));\n      \n      const launchOptions = { headless: true };\n      const result = await healthChecker.restartBrowser(mockInstance, launchOptions);\n      \n      // Should still launch new browser\n      expect(result).toBe(newBrowser);\n      expect(mockLogger.error).toHaveBeenCalledWith(\n        expect.objectContaining({ error: expect.any(Error) }),\n        'Failed to close unhealthy browser'\n      );\n    });\n  });\n\n  describe('Metrics Collection', () => {\n    it('should collect comprehensive metrics', async () => {\n      mockPage.metrics.mockResolvedValue({\n        JSHeapUsedSize: 100 * 1024 * 1024,\n        JSHeapTotalSize: 200 * 1024 * 1024,\n        Timestamp: Date.now(),\n      } as any);\n      \n      mockBrowser.pages.mockResolvedValue([mockPage, mockPage]);\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.metrics).toEqual({\n        memoryUsageMB: expect.any(Number),\n        pageCount: 2,\n        useCount: 10,\n        uptime: expect.any(Number),\n        lastChecked: expect.any(Date),\n      });\n    });\n\n    it('should calculate uptime correctly', async () => {\n      const createdAt = new Date(Date.now() - 60000); // 1 minute ago\n      mockInstance.createdAt = createdAt;\n      \n      const result = await healthChecker.checkHealth(mockInstance);\n      \n      expect(result.metrics.uptime).toBeGreaterThanOrEqual(59000);\n      expect(result.metrics.uptime).toBeLessThanOrEqual(61000);\n    });\n  });\n\n  describe('Batch Health Checks', () => {\n    it('should check multiple browsers', async () => {\n      const instances = [\n        mockInstance,\n        { ...mockInstance, id: 'browser-456' },\n        { ...mockInstance, id: 'browser-789' },\n      ];\n      \n      const results = await healthChecker.checkMultiple(instances);\n      \n      expect(results.size).toBe(3);\n      expect(results.get('browser-123')).toBeDefined();\n      expect(results.get('browser-456')).toBeDefined();\n      expect(results.get('browser-789')).toBeDefined();\n    });\n\n    it('should handle failures in batch checks', async () => {\n      const healthyInstance = mockInstance;\n      const unhealthyBrowser = {\n        ...mockBrowser,\n        isConnected: jest.fn(() => false),\n      };\n      const unhealthyInstance = {\n        ...mockInstance,\n        id: 'browser-456',\n        browser: unhealthyBrowser,\n      };\n      \n      const results = await healthChecker.checkMultiple([\n        healthyInstance,\n        unhealthyInstance,\n      ]);\n      \n      expect(results.get('browser-123')?.isHealthy).toBe(true);\n      expect(results.get('browser-456')?.isHealthy).toBe(false);\n    });\n  });\n\n  describe('Auto-Recovery', () => {\n    it('should perform auto-recovery when enabled', async () => {\n      const newBrowser = { ...mockBrowser };\n      (puppeteer.launch as jest.Mock).mockResolvedValue(newBrowser);\n      \n      healthChecker = new BrowserHealthChecker({\n        maxMemoryMB: 512,\n        maxPageCount: 10,\n        responseTimeout: 5000,\n        checkInterval: 10000,\n        enableAutoRecovery: true,\n      });\n      \n      mockBrowser.isConnected.mockReturnValue(false);\n      \n      const launchOptions = { headless: true };\n      const result = await healthChecker.checkAndRecover(mockInstance, launchOptions);\n      \n      expect(result.recovered).toBe(true);\n      expect(result.newBrowser).toBe(newBrowser);\n      expect(puppeteer.launch).toHaveBeenCalled();\n    });\n\n    it('should not recover healthy browsers', async () => {\n      healthChecker = new BrowserHealthChecker({\n        maxMemoryMB: 512,\n        maxPageCount: 10,\n        responseTimeout: 5000,\n        checkInterval: 10000,\n        enableAutoRecovery: true,\n      });\n      \n      const result = await healthChecker.checkAndRecover(mockInstance, {});\n      \n      expect(result.recovered).toBe(false);\n      expect(result.newBrowser).toBeUndefined();\n    });\n\n    it('should respect auto-recovery disabled setting', async () => {\n      mockBrowser.isConnected.mockReturnValue(false);\n      \n      const result = await healthChecker.checkAndRecover(mockInstance, {});\n      \n      expect(result.recovered).toBe(false);\n      expect(result.health.isHealthy).toBe(false);\n    });\n  });\n\n  describe('Configuration', () => {\n    it('should update configuration', () => {\n      healthChecker.updateConfig({\n        maxMemoryMB: 1024,\n        responseTimeout: 10000,\n      });\n      \n      expect(mockLogger.info).toHaveBeenCalledWith(\n        expect.objectContaining({ \n          maxMemoryMB: 1024,\n          responseTimeout: 10000,\n        }),\n        'Health checker configuration updated'\n      );\n    });\n\n    it('should validate configuration values', () => {\n      expect(() => {\n        healthChecker.updateConfig({ maxMemoryMB: -1 });\n      }).toThrow('Invalid configuration: maxMemoryMB must be positive');\n      \n      expect(() => {\n        healthChecker.updateConfig({ maxPageCount: 0 });\n      }).toThrow('Invalid configuration: maxPageCount must be positive');\n      \n      expect(() => {\n        healthChecker.updateConfig({ responseTimeout: -1000 });\n      }).toThrow('Invalid configuration: responseTimeout must be positive');\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/puppeteer/browser-pool.test.ts","messages":[{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":213,"column":42,"nodeType":"CallExpression","messageId":"returnsValue","endLine":213,"endColumn":66,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[6219,6243],"text":"{setTimeout(resolve, 100)}"},"desc":"Wrap the expression in `{}`."}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":253,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":253,"endColumn":33},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":274,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":274,"endColumn":28},{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":290,"column":42,"nodeType":"CallExpression","messageId":"returnsValue","endLine":290,"endColumn":66,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[8542,8566],"text":"{setTimeout(resolve, 150)}"},"desc":"Wrap the expression in `{}`."}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":295,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":295,"endColumn":31},{"ruleId":"no-promise-executor-return","severity":2,"message":"Return values from promise executor functions cannot be read.","line":304,"column":42,"nodeType":"CallExpression","messageId":"returnsValue","endLine":304,"endColumn":66,"suggestions":[{"messageId":"wrapBraces","fix":{"range":[8981,9005],"text":"{setTimeout(resolve, 150)}"},"desc":"Wrap the expression in `{}`."}]},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":309,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":309,"endColumn":31},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":359,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":359,"endColumn":36},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":387,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":387,"endColumn":31},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":396,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":396,"endColumn":31},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":414,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":414,"endColumn":31},{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":425,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":425,"endColumn":31}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Browser Pool Unit Tests\n * @module tests/unit/puppeteer/browser-pool\n * @nist si-4 \"Information system monitoring\"\n * @nist au-6 \"Audit review, analysis, and reporting\"\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { jest } from '@jest/globals';\nimport type { Browser, Page } from 'puppeteer';\n\n// Set environment to test\nprocess.env.NODE_ENV = 'test';\nprocess.env.LOG_LEVEL = 'silent';\n\n// Create mock logger\nconst mockLogger = {\n  info: jest.fn(),\n  debug: jest.fn(),\n  error: jest.fn(),\n  warn: jest.fn(),\n  child: jest.fn(() => mockLogger),\n};\n\n// Mock puppeteer\nconst mockBrowser = {\n  newPage: jest.fn(),\n  close: jest.fn(),\n  pages: jest.fn(),\n  process: jest.fn(() => ({ pid: 12345 })),\n  isConnected: jest.fn(() => true),\n  on: jest.fn(),\n  off: jest.fn(),\n} as unknown as jest.Mocked<Browser>;\n\nconst mockPage = {\n  close: jest.fn(),\n  url: jest.fn(() => 'about:blank'),\n  goto: jest.fn(),\n  evaluate: jest.fn().mockResolvedValue(42),\n  setRequestInterception: jest.fn(),\n  metrics: jest.fn().mockResolvedValue({\n    JSHeapUsedSize: 100 * 1024 * 1024, // 100MB\n    JSHeapTotalSize: 200 * 1024 * 1024,\n  }),\n} as unknown as jest.Mocked<Page>;\n\nmockBrowser.newPage.mockResolvedValue(mockPage);\nmockBrowser.pages.mockResolvedValue([mockPage]);\n\n// Mock modules\njest.mock('puppeteer', () => ({\n  launch: jest.fn().mockResolvedValue(mockBrowser),\n}));\n\njest.mock('../../../src/utils/logger.js', () => ({\n  createLogger: jest.fn(() => mockLogger),\n  logSecurityEvent: jest.fn().mockResolvedValue(undefined),\n  SecurityEventType: {\n    SERVICE_START: 'SERVICE_START',\n    SERVICE_STOP: 'SERVICE_STOP',\n    RESOURCE_CREATED: 'RESOURCE_CREATED',\n    RESOURCE_DELETED: 'RESOURCE_DELETED',\n    ACCESS_DENIED: 'ACCESS_DENIED',\n  },\n}));\n\n// Import modules\nimport { BrowserPool } from '../../../src/puppeteer/pool/browser-pool.js';\nimport type { BrowserPoolOptions, BrowserInstance } from '../../../src/puppeteer/interfaces/browser-pool.interface.js';\nimport * as puppeteer from 'puppeteer';\n\ndescribe('BrowserPool', () => {\n  let pool: BrowserPool;\n  let options: BrowserPoolOptions;\n\n  beforeEach(() => {\n    // Reset all mocks\n    jest.clearAllMocks();\n    \n    // Reset puppeteer mock\n    (puppeteer.launch as jest.Mock).mockResolvedValue(mockBrowser);\n\n    // Setup pool options\n    options = {\n      maxBrowsers: 3,\n      maxPagesPerBrowser: 5,\n      launchOptions: {\n        headless: true,\n        args: ['--no-sandbox'],\n      },\n      idleTimeout: 30000,\n      healthCheckInterval: 10000,\n      recycleAfterUses: 100,\n      enableRequestInterception: true,\n    };\n\n    pool = new BrowserPool(options);\n  });\n\n  afterEach(async () => {\n    await pool.shutdown(true);\n  });\n\n  describe('Pool Initialization', () => {\n    it('should initialize pool with correct configuration', async () => {\n      await pool.initialize();\n      \n      const metrics = pool.getMetrics();\n      expect(metrics.totalBrowsers).toBe(0);\n      expect(metrics.activeBrowsers).toBe(0);\n      expect(metrics.idleBrowsers).toBe(0);\n    });\n\n    it('should apply configuration options correctly', () => {\n      pool.configure({ maxBrowsers: 5 });\n      // Configuration should be updated\n      expect(mockLogger.info).toHaveBeenCalledWith(\n        expect.objectContaining({ maxBrowsers: 5 }),\n        'Browser pool configuration updated'\n      );\n    });\n\n    it('should reject invalid configuration', () => {\n      expect(() => {\n        pool.configure({ maxBrowsers: -1 });\n      }).toThrow('Invalid configuration: maxBrowsers must be positive');\n    });\n  });\n\n  describe('Browser Acquisition and Release', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n    });\n\n    it('should acquire a browser instance', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      \n      expect(instance).toBeDefined();\n      expect(instance.id).toBeDefined();\n      expect(instance.browser).toBe(mockBrowser);\n      expect(instance.useCount).toBe(1);\n      \n      const metrics = pool.getMetrics();\n      expect(metrics.totalBrowsers).toBe(1);\n      expect(metrics.activeBrowsers).toBe(1);\n      expect(metrics.idleBrowsers).toBe(0);\n    });\n\n    it('should release a browser back to pool', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      await pool.releaseBrowser(instance.id, 'session-123');\n      \n      const metrics = pool.getMetrics();\n      expect(metrics.activeBrowsers).toBe(0);\n      expect(metrics.idleBrowsers).toBe(1);\n    });\n\n    it('should reuse idle browsers', async () => {\n      const instance1 = await pool.acquireBrowser('session-123');\n      await pool.releaseBrowser(instance1.id, 'session-123');\n      \n      const instance2 = await pool.acquireBrowser('session-456');\n      \n      expect(instance2.id).toBe(instance1.id);\n      expect(instance2.useCount).toBe(2);\n      expect(puppeteer.launch).toHaveBeenCalledTimes(1);\n    });\n\n    it('should handle concurrent acquisitions', async () => {\n      let launchCount = 0;\n      (puppeteer.launch as jest.Mock).mockImplementation(() => {\n        launchCount++;\n        return {\n          ...mockBrowser,\n          // Create unique browser instances\n          _id: launchCount,\n        };\n      });\n\n      const promises = [\n        pool.acquireBrowser('session-1'),\n        pool.acquireBrowser('session-2'),\n        pool.acquireBrowser('session-3'),\n      ];\n\n      const instances = await Promise.all(promises);\n      \n      expect(instances).toHaveLength(3);\n      expect(new Set(instances.map(i => i.id)).size).toBe(3);\n      expect(puppeteer.launch).toHaveBeenCalledTimes(3);\n    });\n  });\n\n  describe('Pool Size Limits', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n    });\n\n    it('should enforce maximum browser limit', async () => {\n      // Acquire max browsers\n      const instances = await Promise.all([\n        pool.acquireBrowser('session-1'),\n        pool.acquireBrowser('session-2'),\n        pool.acquireBrowser('session-3'),\n      ]);\n\n      // Should queue when at limit\n      const acquirePromise = pool.acquireBrowser('session-4');\n      \n      // Give some time to ensure it's queued\n      await new Promise<void>(resolve => setTimeout(resolve, 100));\n      \n      // Release one browser\n      await pool.releaseBrowser(instances[0].id, 'session-1');\n      \n      // Now the queued request should complete\n      const instance4 = await acquirePromise;\n      expect(instance4).toBeDefined();\n    });\n\n    it('should timeout acquisition requests', async () => {\n      // Fill the pool\n      await Promise.all([\n        pool.acquireBrowser('session-1'),\n        pool.acquireBrowser('session-2'),\n        pool.acquireBrowser('session-3'),\n      ]);\n\n      // Configure short timeout\n      pool.configure({ acquisitionTimeout: 100 } as any);\n\n      // This should timeout\n      await expect(pool.acquireBrowser('session-4')).rejects.toThrow(\n        'Browser acquisition timeout'\n      );\n    });\n  });\n\n  describe('Page Management', () => {\n    let instance: BrowserInstance;\n\n    beforeEach(async () => {\n      await pool.initialize();\n      instance = await pool.acquireBrowser('session-123');\n    });\n\n    it('should create a new page', async () => {\n      const page = await pool.createPage(instance.id, 'session-123');\n      \n      expect(page).toBe(mockPage);\n      expect(mockBrowser.newPage).toHaveBeenCalled();\n      expect(instance.pageCount).toBe(1);\n    });\n\n    it('should enforce page limit per browser', async () => {\n      // Create max pages\n      for (let i = 0; i < 5; i++) {\n        await pool.createPage(instance.id, 'session-123');\n      }\n\n      // Should reject when at limit\n      await expect(pool.createPage(instance.id, 'session-123')).rejects.toThrow(\n        'Page limit reached for browser'\n      );\n    });\n\n    it('should close pages', async () => {\n      await pool.createPage(instance.id, 'session-123');\n      \n      await pool.closePage(instance.id, 'session-123');\n      \n      expect(mockPage.close).toHaveBeenCalled();\n      expect(instance.pageCount).toBe(0);\n    });\n  });\n\n  describe('Idle Timeout', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n      pool.configure({ idleTimeout: 100 }); // 100ms for testing\n    });\n\n    it('should clean up idle browsers after timeout', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      await pool.releaseBrowser(instance.id, 'session-123');\n\n      // Wait for idle timeout\n      await new Promise<void>(resolve => setTimeout(resolve, 150));\n      \n      const cleaned = await pool.cleanupIdle();\n      \n      expect(cleaned).toBe(1);\n      expect(mockBrowser.close).toHaveBeenCalled();\n      \n      const metrics = pool.getMetrics();\n      expect(metrics.totalBrowsers).toBe(0);\n    });\n\n    it('should not clean up active browsers', async () => {\n      await pool.acquireBrowser('session-123'); // Keep active\n\n      await new Promise<void>(resolve => setTimeout(resolve, 150));\n      \n      const cleaned = await pool.cleanupIdle();\n      \n      expect(cleaned).toBe(0);\n      expect(mockBrowser.close).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Health Checks', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n    });\n\n    it('should perform health check on all browsers', async () => {\n      const instance1 = await pool.acquireBrowser('session-1');\n      const instance2 = await pool.acquireBrowser('session-2');\n\n      const healthResults = await pool.healthCheck();\n      \n      expect(healthResults.size).toBe(2);\n      expect(healthResults.get(instance1.id)).toBe(true);\n      expect(healthResults.get(instance2.id)).toBe(true);\n    });\n\n    it('should detect unhealthy browsers', async () => {\n      const unhealthyBrowser = {\n        ...mockBrowser,\n        isConnected: jest.fn(() => false),\n      };\n      (puppeteer.launch as jest.Mock).mockResolvedValue(unhealthyBrowser);\n\n      const instance = await pool.acquireBrowser('session-123');\n      \n      const healthResults = await pool.healthCheck();\n      \n      expect(healthResults.get(instance.id)).toBe(false);\n    });\n\n    it('should restart unhealthy browsers', async () => {\n      const unhealthyBrowser = {\n        ...mockBrowser,\n        isConnected: jest.fn(() => false),\n      };\n      \n      (puppeteer.launch as jest.Mock)\n        .mockResolvedValueOnce(unhealthyBrowser)\n        .mockResolvedValueOnce(mockBrowser); // New healthy browser\n\n      const instance = await pool.acquireBrowser('session-123');\n      await pool.releaseBrowser(instance.id, 'session-123');\n      \n      // Perform health check which should trigger restart\n      await pool.healthCheck();\n      \n      expect(unhealthyBrowser.close).toHaveBeenCalled();\n      expect(puppeteer.launch).toHaveBeenCalledTimes(2);\n    });\n  });\n\n  describe('Browser Recycling', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n      pool.configure({ recycleAfterUses: 3 });\n    });\n\n    it('should recycle browser after specified uses', async () => {\n      let instance = await pool.acquireBrowser('session-1');\n      const originalId = instance.id;\n      \n      // Use the browser 3 times\n      for (let i = 0; i < 2; i++) {\n        await pool.releaseBrowser(instance.id, 'session-1');\n        instance = await pool.acquireBrowser('session-1');\n        expect(instance.useCount).toBe(i + 2);\n      }\n\n      // Release the browser after 3rd use - this should trigger recycling\n      await pool.releaseBrowser(instance.id, 'session-1');\n\n      // Next acquisition should get a new browser\n      const newInstance = await pool.acquireBrowser('session-new');\n      expect(newInstance.id).not.toBe(originalId);\n      expect(mockBrowser.close).toHaveBeenCalled();\n    });\n\n    it('should manually recycle a browser', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      await pool.releaseBrowser(instance.id, 'session-123');\n      \n      await pool.recycleBrowser(instance.id);\n      \n      expect(mockBrowser.close).toHaveBeenCalled();\n      const metrics = pool.getMetrics();\n      expect(metrics.totalBrowsers).toBe(0);\n    });\n  });\n\n  describe('Graceful Shutdown', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n    });\n\n    it('should shutdown gracefully', async () => {\n      await pool.acquireBrowser('session-1');\n      const instance2 = await pool.acquireBrowser('session-2');\n      await pool.releaseBrowser(instance2.id, 'session-2');\n\n      await pool.shutdown();\n      \n      expect(mockBrowser.close).toHaveBeenCalledTimes(2);\n      \n      const metrics = pool.getMetrics();\n      expect(metrics.totalBrowsers).toBe(0);\n    });\n\n    it('should force shutdown when requested', async () => {\n      await pool.acquireBrowser('session-1'); // Keep active\n      \n      await pool.shutdown(true);\n      \n      expect(mockBrowser.close).toHaveBeenCalled();\n    });\n\n    it('should reject new acquisitions after shutdown', async () => {\n      await pool.shutdown();\n      \n      await expect(pool.acquireBrowser('session-123')).rejects.toThrow(\n        'Browser pool is shutting down'\n      );\n    });\n  });\n\n  describe('Metrics Collection', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n    });\n\n    it('should track browser lifecycle metrics', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      \n      // Add a small delay to ensure measurable lifetime\n      await new Promise<void>(resolve => { setTimeout(resolve, 10); });\n      \n      await pool.releaseBrowser(instance.id, 'session-123');\n      \n      // Manually destroy the browser to test lifetime calculation\n      await pool.recycleBrowser(instance.id);\n      \n      const metrics = pool.getMetrics();\n      \n      expect(metrics.browsersCreated).toBe(1);\n      expect(metrics.browsersDestroyed).toBe(1);\n      expect(metrics.avgBrowserLifetime).toBeGreaterThan(0);\n    });\n\n    it('should calculate utilization percentage', async () => {\n      await pool.acquireBrowser('session-1');\n      await pool.acquireBrowser('session-2');\n      \n      const metrics = pool.getMetrics();\n      \n      expect(metrics.utilizationPercentage).toBeCloseTo(66.67, 1); // 2/3 * 100\n    });\n\n    it('should track page counts', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      await pool.createPage(instance.id, 'session-123');\n      await pool.createPage(instance.id, 'session-123');\n      \n      const metrics = pool.getMetrics();\n      \n      expect(metrics.totalPages).toBe(2);\n      expect(metrics.activePages).toBe(2);\n    });\n  });\n\n  describe('Error Handling', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n    });\n\n    it('should handle browser launch failures', async () => {\n      (puppeteer.launch as jest.Mock).mockRejectedValue(new Error('Launch failed'));\n\n      await expect(pool.acquireBrowser('session-123')).rejects.toThrow('Launch failed');\n      \n      const metrics = pool.getMetrics();\n      expect(metrics.totalBrowsers).toBe(0);\n    });\n\n    it('should handle page creation failures', async () => {\n      mockBrowser.newPage.mockRejectedValue(new Error('Page creation failed'));\n\n      const instance = await pool.acquireBrowser('session-123');\n      \n      await expect(pool.createPage(instance.id, 'session-123')).rejects.toThrow(\n        'Page creation failed'\n      );\n    });\n\n    it('should handle browser close failures gracefully', async () => {\n      mockBrowser.close.mockRejectedValue(new Error('Close failed'));\n\n      const instance = await pool.acquireBrowser('session-123');\n      await pool.releaseBrowser(instance.id, 'session-123');\n      \n      // Should not throw\n      await expect(pool.recycleBrowser(instance.id)).resolves.not.toThrow();\n      \n      expect(mockLogger.error).toHaveBeenCalledWith(\n        expect.objectContaining({ error: expect.any(Error) }),\n        'Failed to close browser'\n      );\n    });\n\n    it('should validate session IDs', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      \n      // Try to release with wrong session ID\n      await expect(pool.releaseBrowser(instance.id, 'wrong-session')).rejects.toThrow(\n        'Unauthorized: Browser not acquired by this session'\n      );\n    });\n  });\n\n  describe('Browser Instance Helpers', () => {\n    beforeEach(async () => {\n      await pool.initialize();\n    });\n\n    it('should get browser by ID', async () => {\n      const instance = await pool.acquireBrowser('session-123');\n      \n      const retrieved = pool.getBrowser(instance.id);\n      expect(retrieved).toBe(instance);\n    });\n\n    it('should list all browsers', async () => {\n      await pool.acquireBrowser('session-1');\n      await pool.acquireBrowser('session-2');\n      \n      const browsers = pool.listBrowsers();\n      expect(browsers).toHaveLength(2);\n    });\n\n    it('should return undefined for non-existent browser', () => {\n      const browser = pool.getBrowser('non-existent');\n      expect(browser).toBeUndefined();\n    });\n  });\n});","usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/puppeteer/integration.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/puppeteer/page-manager.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/routes/health.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/store/in-memory-session-store.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/utils/test-examples.test.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/unbound-method","severity":2,"message":"Avoid referencing unbound methods which may cause unintentional scoping of `this`.\nIf your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.","line":85,"column":14,"nodeType":"MemberExpression","messageId":"unboundWithoutThisAnnotation","endLine":85,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-console","severity":2,"message":"Unexpected console statement.","line":147,"column":9,"nodeType":"MemberExpression","messageId":"unexpected","endLine":147,"endColumn":20,"suggestions":[{"messageId":"removeConsole","data":{"propertyName":"log"},"fix":{"range":[4330,4361],"text":""},"desc":"Remove the console.log()."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/unit/ws/server.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]},{"filePath":"/home/william/git/puppeteer-mcp/tests/utils/test-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-return-await","replacedBy":[]}]}]
